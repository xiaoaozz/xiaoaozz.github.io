<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>MySQL面经篇 | 小奥</title><meta name="keywords" content="MySQL面经"><meta name="author" content="小奥,3189137314@qq.com"><meta name="copyright" content="小奥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="MySQL面经篇"><meta name="application-name" content="MySQL面经篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="MySQL面经篇"><meta property="og:url" content="http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/index.html"><meta property="og:site_name" content="小奥"><meta property="og:description" content="MySQL面试题汇总基础数据库三大范式第一范式：数据库的每一列都是不可分割的原子项。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 第三范式：在第二范式的基础上，非主键只依赖于主键，不依赖于其他非主键，即不存在依赖传递。 char和varchar的区别（1）存储"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/png/19.png"><meta property="article:author" content="小奥"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/png/19.png"><meta name="description" content="MySQL面试题汇总基础数据库三大范式第一范式：数据库的每一列都是不可分割的原子项。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 第三范式：在第二范式的基础上，非主键只依赖于主键，不依赖于其他非主键，即不存在依赖传递。 char和varchar的区别（1）存储"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 编程知识爱好者","🔍 分享与热心帮助","🏠 面试总结小能手","🔨 设计开发一条龙","🤝 源码阅读与解析","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小奥","link":"链接: ","source":"来源: 小奥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小奥',
  title: 'MySQL面经篇',
  postAI: '',
  pageFillDescription: 'MySQL面试题汇总, 基础, 数据库三大范式, char和varchar的区别, drop、truncate和delete的区别, select from ab和join的区别, 左连接和右连接, group by的用法, Limit分页的用法, where和having的区别, union和union all的区别, 索引, 什么是索引, 什么是全文索引, 数据库索引有什么作用, 说说你对索引的理解, 索引为什么能提升检索的效率, 主键是什么索引, 如何避免回表查询, 哪些列需要建立索引, 建立索引的原则, 说说你对B+树的理解, 索引的数据结构是什么样的, 索引底层采用的什么数据结构, 索引的分类, 一颗B+树能存储多少条数据, 为什么要使用B+树作为索引, B+树索引和hash索引的区别, B树和B+树的区别, B+树影响IO次数的因素, B+树的层数取决于什么因素, B+树的每一层越宽越好吗？, B+树如何实现平衡, 聚簇索引和非聚簇索引的区别, 索引查询过程, 索引失效的场景, 存储引擎, MySQL的执行引擎有哪些, MyISAM和InnoDB的区别如何选择, MyISAM索引和InnoDB索引的区别, SQL优化, limit深度分页优化, sql执行较慢如何排查和优化, 如何定位和处理慢查询, 如何对SQL进行调优, MySQL事务, 事务如何使用, 事务的特性, 事务的隔离级别, 并发事务会出现的问题, MySQL的默认隔离级别是什么, 生产环境数据库使用哪种隔离级别, MySQL中的锁, 锁的分类面试题汇总基础数据库三大范式第一范式数据库的每一列都是不可分割的原子项第二范式在第一范式的基础上非主键列完全依赖于主键而不能是依赖于主键的一部分第三范式在第二范式的基础上非主键只依赖于主键不依赖于其他非主键即不存在依赖传递和的区别存储方式类型的数据是定长的当存储时会将所有的字符都填充到定长检索时会去掉空格因此存储时占用的空间固定而类型的数据是变长的它只会存储实际使用的字符因此存储时占用的空间是可变的查找效率的查找效率比要高字符串长度类型的数据长度是固定的可以存储到个字符而类型的数据长度是可变的可以存储到个字符使用场景通常类型的数据适合存储长度固定的数据例如国家代码邮编等而类型的数据适合存储长度不固定的数据例如用户名地址等和的区别作用范围会删除整张表和表结构以及表的索引约束和触发器只删除全部表数据表的结构索引约束等会被保留只删除表的全部或者部分数据表结构约束索引等会被保留作用方式是语句执行删除操作的过程是每次从表中删除一行并同时将该行的删除操作作为事务记录在日志中保存以便于进行回滚操作是语句删除行是不能恢复的并且在删除过程中不会激活与表有关的触发器执行速度比较块原数据不放到中不能回滚条件限制和不支持添加条件而支持条件执行速度执行速度是逐行执行的并且在执行时会把操作日志记录下来以备日后回滚使用所以的执行速度是比较慢的而的操作是先复制一个新的表结构然后删除掉原来的表所以它的执行速度居中而的执行速度最快和的区别使用的是隐式连接也被称为笛卡尔积对于表中的每一行都会将表中的所有行与之匹配生成一个新的结果集这种连接通常会导致结果集非常大因为它将两个表中的所有数据都组合在一起而且没有经过任何的筛选或者限制使用的的显示连接它使用子句来指定连接条件只有满足条件的数据行才会被返回这种连接方式可以减少结果集的大小同时还可以更加精细的筛选和限制左连接和右连接外连接通过来实现它将返回两张表中满足连接条件的数据同时返回不满足条件的数据外连接有两种形式左连接和右连接左外连接简称为左连接它会返回左表中的所有记录和右表中满足连接条件的记录两表关联左表全部保留右表关联不上用表示字段列表表表条件右外连接简称为右连接它会返回右表中的所有记录和左表中满足连接条件的记录两表关联右表全部保留左表关联不上用表示字段列表表表条件全连接两表的内容均保留没有关联的字段用表示在中使用表示字段列表表字段列表表对于联合查询的多张表的列表必须要保持一致字段类型也要保持一致会将全部的数据直接合并在一起会对合并之后的数据去重的用法一般用于分组统计就是可以根据一个或者多个字段对查询到的数据进行分组如果单独使用的话会返回每组第一行的数据的常规用法就是配合聚合函数利用分组信息进行统计同时还可以配合进行筛选过滤另一方面子句中不能使用除了分组字段和聚合函数之外的其他字段分页的用法子句可以用于强制语句返回指定的记录数字段表名参数参数字段表名参数参数为了与兼容参数指定第一个返回记录行的偏移量从开始参数指定返回记录行的最大数目如果只给定一个参数那么表示返回的最大记录行数目如果第二个参数为表示第一个参数的偏移量之后的所有的数据和的区别是一个约束声明在对查询结果返回之前将不符合条件的数据给去掉是在结果返回之前起作用的中不能使用聚合函数即使用条件过滤出特定的行是一个过滤声明是在查询返回结果集以后对查询结果进行的过滤操作在中可以使用聚合函数另一方面子句中不能使用除了分组字段和聚合函数之外的其他字段从性能的角度来说子句中如果使用了分组字段作为过滤条件应该替换成子句因为可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据性能会更好和的区别和的用法都是联合查询结果它们的区别如下显示结果不同会自动压缩多个结果集合中的重复结果而则是将所有的结果显示出来对重复结果的处理不同是取唯一值会筛选掉重复的记录有去重的效果而是直接链接取到的是所有值对排序的处理不同将会按照字段的顺序进行排序只是简单的将两个结果和合并返回从效率上来说要比的效率要高另外使用和必须保证各个查询的列数必须相同并且每个列的类型是一样的但是列名不一定需要相等索引什么是索引索引是对数据库中的一列或者多列的值进行排序的一种数据结构可以帮助实现快速查询和检索数据优点提高数据检索的效率降低数据库的成本通过索引对数据进行排序降低数据排序的成本降低的消耗缺点索引需要使用物理文件存储占用一定的空间索引大大提高的查询效率但是同时降低了的执行效率如实现增删改的时候效率降低什么是全文索引一文给你讲清楚全文索引实战和原理掘金全文索引就是通过建立倒排索引可以极大的提升检索效率解决判断字段受否包含的问题如果我们使用模糊查询那么当匹配字符在前面的时候索引就会失效这时检索效率比较低全文索引就可以解决这个问题数据库索引有什么作用数据库索引是一种特殊的数据结构可以提高数据库查询操作的效率它通过预先建立一个包含目标数据的索引表加快了数据库中大数据量的查询速度具体来说索引可以为数据库表中的一列或多列创建一个快速查找路径并将它们存储在内存或磁盘中当我们执行一条查询时数据库引擎会首先检查是否存在适用于该查询的索引如果找到就可以直接使用索引进行查询避免了对整个数据库表的扫描从而提高了查询速度说说你对索引的理解索引是一种用于提高查询效率的数据结构它可以帮助快速定位到符合查询条件的数据通常情况下索引会被创建在数据表的某一列或多列上以加速这些列的查询操作在中常见的索引类型包括索引哈希索引全文索引等索引一共分为三种索引是中最常用的索引类型它是一种基于数据结构的索引在大多数情况下可以快速地定位到需要查询的数据索引对于范围查询和排序操作也比较高效因为它可以快速地遍历索引树来定位数据哈希索引则是一种基于哈希表的索引它可以提供的查询效率即查询的速度非常快但是哈希索引只适用于等值查询不能用于范围查询和排序操作全文索引则是一种用于处理文本数据的索引它可以快速地定位到包含查询关键词的文本数据全文索引在处理大量文本数据时可以提高查询效率但是它的创建和维护成本较高在使用索引时需要注意以下几点索引并不是越多越好过多的索引会影响插入更新和删除操作的性能对于频繁查询的列应该尽可能地创建索引而对于不经常使用的列则不需要创建索引在创建索引时应该考虑到查询的效率和索引的大小避免创建过大的索引在进行数据修改操作时尽量减少索引的使用避免出现频繁的索引重建和更新操作索引为什么能提升检索的效率索引能提高检索的效率主要有以下几个方面减少了对数据的扫描的数量和范围提高了数据的查询速度对于没有索引的情况下数据库需要通过全表扫描查找符合条件的数据而如果表中建立了索引则可以通过直接读取索引进行定位从而避免了大量的全表扫描减少了数据扫描的数量和范围优化了排序操作当查询包含子句时索引可以帮助优化排序操作使结果更快地返回主键是什么索引在中主键是一种特殊的索引用于唯一标识数据表中的每一行数据主键可以是一个或多个列的组合并且它们的值必须是唯一的且不能为空当创建主键时会自动为主键列创建一个索引来加速主键查找操作由于主键值是唯一的因此主键索引可以帮助快速地定位到数据表中的唯一一行数据这对于频繁查询和更新主键列的操作非常有帮助此外主键索引还可以作为其他索引的引用例如外键约束从而保证数据表之间的关联关系需要注意的是当表中没有主键或主键不明确时会使用一个名为隐藏主键的索引来代替这个隐藏主键索引是一个自增整数列用来唯一标识数据表中的每一行数据如何避免回表查询尽量使用覆盖索引尽可能使用覆盖索引即在查询结果中包含所有需要返回的列这样就不需要回到数据表中检索数据行可以直接从索引中获取结果需要注意的是覆盖索引通常只适用于查询比较简单的情况索引优化优化查询语句尽量使用优化的索引例如如果查询语句中包含多个列则可以创建一个包含这些列的复合索引以提高查询效率在创建索引时还可以使用前缀索引全文索引等技术来优化索引效率哪些列需要建立索引适合建立索引主键强制该列的唯一性和组织表中的数据结构外键经常用于表连接加快表之间的连接速度经常需要查询的列建立索引增加搜索速度经常需要排序的列因为索引已经排序利用索引的排序加快查询的速度经常需要统计或者分组的字段不适合建立索引表中记录比较少的基本用不到条件的列文本或者超长字段的列频繁进行数据操作的列数据重复且分布平均的列建立索引的原则索引是提高查询效率的重要手段之一但是索引的建立也需要一定的原则和注意事项下面是建立索引的一些原则确定需要建立索引的列在建立索引之前需要先确定需要建立索引的列通常建议将索引建在经常使用作为查询条件的列上或者在数据表中唯一或者高度重复的列上如果索引太多或者太少都可能会影响查询性能选择适当的索引类型支持多种索引类型如索引哈希索引等不同的索引类型适合不同的查询场景需要根据实际情况选择适当的索引类型不要在过多列上建立联合索引联合索引可以在多个列上建立索引通常可以提高查询效率但是在建立联合索引时需要注意不要在过多列上建立联合索引否则会影响索引的效率避免在索引列上使用函数或运算符在查询条件中如果使用了函数或运算符会导致无法使用索引进行查询降低查询效率因此在建立索引时需要避免在索引列上使用函数或运算符确保数据表的数据量足够大对于数据量较小的数据表建立索引可能会降低查询性能因此在建立索引之前需要确保数据表的数据量足够大以便充分发挥索引的优势定期优化索引随着数据表中数据的增加和删除索引的效率也会发生变化因此需要定期优化索引以确保索引的效率最大化说说你对树的理解树是一种常见的数据结构常用于实现关系型数据库中的索引树的结构类似于二叉树但其具有以下特点树的非叶子节点存储的是索引信息而叶子节点存储的是数据信息这使得树可以快速定位到数据所在的叶子节点每个节点中的关键字按顺序排列且相邻节点之间的关键字满足顺序约束这使得树可以进行范围查询和排序操作树的每个节点都有多个子节点且每个子节点存储的关键字范围是相同的这使得树可以进行快速的查找和插入操作树的高度较低通常不超过层这使得树的查询插入删除操作都具有较快的速度树的优点在于其能够高效地支持范围查询排序和快速定位数据在实际应用中树常被用于实现关系型数据库的索引结构树的缺点在于其插入和删除操作可能导致树的平衡性失衡需要进行平衡调整操作同时节点的分裂和合并操作会导致性能的损失索引的数据结构是什么样的默认的存储引擎是它采用的是树结构的索引树的特点如下树的非叶子节点存储的是索引信息而叶子节点存储的是数据信息这样可以使得树快速定位到数据所在的叶子节点非叶子节点之间使用双向指针链接且相邻之间的关键字满足顺序约束这使得树可以进行范围查询和排序树的每个节点都有多个子节点且每个子节点存储的关键字的范围是相同的这使得树可以进行快速查询和插入操作索引底层采用的什么数据结构数据库索引底层采用的数据结构有多种常见的包括树是一种自平衡的树状数据结构可用于存储排序后的数据主要用于提高磁盘访问效率树在树的基础上增加了一个链表结构能够更快地进行遍历和范围查询索引使用哈希函数将索引列映射到一个哈希值并将该值与索引表中的记录关联它适用于等值比较的查询操作但不适用于区间查询或模糊查询树是一种用于空间数据索引的树状数据结构可以支持空间数据的查询和分析索引将索引列中的每个值使用二进制位表示其中每个位表示诸如存在不存在等信息通过位运算可以实现类似于布尔运算的复杂查询在选择合适的索引数据结构时需要考虑具体的应用场景和需求如数据规模读写比例查询类型等因素对于大型数据集和频繁的查询操作通常采用树索引而对于空间数据和全文搜索等特殊类型的数据可能需要采用树全文索引等特定的索引结构索引的分类按数据结构分类树索引索引索引按物理存储分类聚簇索引主键索引二级索引辅助索引按字段特性分类主键索引唯一索引普通索引前缀索引按字段个数分类单列索引联合索引一颗树能存储多少条数据为树的层数为什么要使用树作为索引查询速度稳定性存储数据大小查找磁盘次数方面相对于二叉树来说树的层级更少搜索的效率更高相对于来说无论是叶子节点还是非叶子节点都会保存数据这样导致页中的键值减少同样要保存大量的数据只能是增加树的高度这样就会降低了检索的效率相对于索引来说支持范围匹配以及排序操作内存空间一般来说索引本身也很大不可能全部存储在内存中因此索引往往以索引文件的形式存储的磁盘上这样的话索引查找过程中就要产生磁盘消耗相对于内存存取存取的消耗要高几个数量级所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘操作次数的渐进复杂度换句话说索引的结构组织要尽量减少查找过程中磁盘的存取次数树索引和索引的区别是否支持排序哈希索引不支持排序因为哈希表是无序的树索引是有序的并且支持排序是否支持范围查找哈希索引无序所以不支持范围查找是否支持模糊查询哈希索引不支持模糊查询以及索引最左前缀匹配效率方面哈希表中会存在哈希冲突所以哈希索引的性能是不稳定的而树索引的性能是相对稳定的树和树的区别树一种多路自平衡搜索树通过节点存储并对节点进行了排序一个节点可以存储多个元素元素之间也是排序的树树是树的变种叶子节点之间有指针非叶子节点上不存储元素元素的存储都在叶子节点上并且是排好序的区别节点结构树中的每个结点既包含索引键也包含数据并且叶子节点之间没有关系而树种的每个非叶子节点只包含索引键数据只存在叶子节点中叶子节点之间有指针连接查找方式树中通过从根节点开始根据节点中的索引键找到对应的子节点并继续查找直到叶子节点中找到目标数据而在树中只需要从根节点开始根据节点中的索引键找到叶子节点并在叶子节点中查找目标数据插入和删除操作在树中插入和删除数据时需要将数据插入或者删除到对应的叶子节点中如果叶子节点中的数据个数少于阈值则需要将节点中的数据进行调整而在树中插入和删除数据时只需要调整对应的叶子节点并更新父节点中的索引即可范围查找树比树更适合范围查找因为树的所有叶子节点都包含了数据而树的非叶子节点也包含了数据因此在进行范围查找时需要遍历树的所有节点而中只需要遍历叶子节点即可效率树的每个节点都存储了数据因此每次查找的开销比较大而在树中非叶结点不含有数据就可以包含更多关键字磁盘的次数比较少而且每次都需要查找到叶子节点效率比较稳定时间复杂度未为树影响次数的因素树的高度树的高度越低需要访问的节点数就越少从而次数就越少树的高度受到节点大小和节点个数的限制通常情况下节点大小越大节点个数越多树的高度就越低磁盘块的大小磁盘块是磁盘的最小单位磁盘块大小越大每次读取或写入的数据就越多从而次数就越少树节点大小的选择应该与磁盘块大小相适应通常情况下节点大小应该等于或略小于磁盘块大小除了这两个因素树的节点分裂和合并操作也会影响次数在插入和删除数据时如果需要进行节点分裂或合并操作则需要进行额外的操作从而增加了次数因此树的节点分裂和合并操作应该尽量减少这可以通过调整节点大小和阈值来实现树的层数取决于什么因素节点大小树的每个节点存储的关键字个数越多每个节点能够覆盖的数据范围就越大树的层数也就越低通常情况下节点大小应该等于或略小于磁盘块大小这样可以减少次数提高查询效率关键字总数树的关键字总数越多树的层数就越高在设计树的时候应该考虑到数据规模和查询频率避免出现树的层数过高的情况每个节点的叶子节点数树的每个节点存储的子节点数越多树的层数就越低但是子节点数过多也会增加节点的大小导致次数增加在设计树的时候应该平衡节点大小和子节点数使树的层数和查询效率达到一个最优点页分裂和合并操作在插入和删除数据时如果需要进行节点分裂或合并操作则会导致树的层数发生变化分裂操作会使树的层数增加合并操作会使树的层数减少因此树的节点分裂和合并操作应该尽量减少这可以通过调整节点大小和阈值来实现树的每一层越宽越好吗树每一层越宽不一定越好它需要平衡节点宽度和树高度来达到最佳查询性能当树的节点宽度较大时每个节点可以存储更多的键值对可以减少树高度从而减少访问磁盘的次数提高查询性能但是节点宽度过大也会导致节点占用的存储空间变大可能会出现一些存储空间浪费的情况当树的节点宽度较小时节点可以存储的键值对数量较少树的高度可能会增加从而访问磁盘的次数也会增加但是节点宽度较小可以减少存储空间浪费也可以提高节点的利用率因此选择节点宽度的大小应该根据实际情况进行综合考虑通常情况下节点宽度应该根据磁盘块的大小和查询性能的要求进行平衡使得树的高度最小化并且节点的利用率和存储空间利用率也尽可能地高树如何实现平衡树的平衡主要是通过节点的拆分和自行控制行高来实现的节点拆分当一个节点中的关键字数目超过了预定的数目时需要将该节点进行拆分以保证树的平衡具体地将该节点中的关键字一分为二分别分配给两个新节点同时将分裂出的关键字上移到父节点中这样树的高度会增加但是所有节点的关键字数目都得到了控制从而保证了树的平衡自行控制行高树中的叶子节点只存储数据而非数据和索引这样可以避免非叶子节点的频繁访问从而提高查询效率同时为了保证树的平衡可以将所有叶子节点的高度控制在相同的水平上即所有叶子节点的深度相等当叶子节点中的数据发生变化时需要将变化后的节点重新排序并重建叶子节点之间的链表以保证所有叶子节点的深度相等聚簇索引和非聚簇索引的区别聚簇索引是将数据和索引存储在一起与索引的顺序相同它们通常是主键索引因为主键是表中的唯一标识符种索引的优点是可以快速地对表进行搜索和排序当使用聚簇索引进行查找时数据库可以通过直接读取数据页来避免大量的操作从而提高查询效率但缺点是当更新数据时需要对整个表进行重组因此更新操作可能会变得更慢非聚簇索引是将索引和数据分开存储索引包含指向数据行的指针因此当使用非聚簇索引进行查询时数据库需要进行两次磁盘访问一次访问索引页另一次访问数据页这种索引的优点是在进行更新操作时不需要重组整个表因此更新操作更快但缺点是查询时需要额外的操作因此查询速度可能会受到影响索引查询过程解析并且优化查询计划在执行查询之前需要先解析语句并进行优化以确定如何执行查询在优化查询计划时会尝试使用索引来加速查询操作查找索引如果查询语句中包含条件或操作会查找匹配这些条件的索引如果找到多个索引则会选择一个最适合的索引如果没有找到索引则会执行全表扫描读取索引并获取数据行当找到匹配条件的索引后它会使用索引来定位数据行的位置这通常需要从磁盘读取索引和数据行如果数据行不在内存中则需要从磁盘中读取数据行这是查询操作中最耗时的步骤之一过滤数据行会根据条件过滤数据行以删除不匹配的数据行这可以减少需要返回的数据量提高查询速度返回查询结果当找到匹配条件的数据行后它会将这些数据行返回给客户端索引失效的场景个必知的索引失效场景别再踩坑了掘金联合索引不满足最左匹配原则联合索引的使用遵循最左匹配原则在联合索引中最左侧的字段优先匹配在查询的时候如果想让查询条件走索引那么最左边的字段要出现在查询条件中运算操作或者函数操作原因是因为如果没有进行运算操作那么会直接走索引去树中查询数据但是如果我们对字段进行了运算操作或者函数操作实际上是拿新的字段去做查询如果走索引那么需要一个一个去对比认为既然都要对比不如直接全表扫描字符串类型字段不加引号字符串字段如果不加引号会发生隐式转换成类型参数类型与字段类型不匹配模糊查询匹配头部索引本身相当于目录将字符串字段从左到右依次排序而左侧的占位符模糊匹配导致无法正常按照目录进行匹配所以索引会失效连接的条件如果连接的条件左右其中有一个不是索引字段那么如果是单独使用的话肯定是要走全表扫描的连接在一起再次进行索引查询反而是浪费性能了所以索引会失效索引列做或者比较查询使用如果使用正常走索引但是使用索引会失效查询条件使用时如果是主键走索引如果是普通索引则索引失效索引区分度比较高查询优化器发现某个值出现在表的数据行中的百分比惯用的百分比界线是很高的时候会忽略索引进行全表扫描存储引擎的执行引擎有哪些主要有等引擎是一种兼顾高可靠性和高性能的通用存储引擎在之后是默认的存储引擎提供了对事务的支持还提供了行锁和外键的约束是早期的默认的存储引擎不支持事务也不支持外键支持表锁访问速度较快将数据放在内存中数据的处理速度很快但是安全性和可靠性不高和的区别如何选择锁的细粒度不同比更好的支持并发因为的支持行锁而支持表锁行锁对每一条记录上锁所以开销更大但是可以解决脏读和不可重复读的问题相对来说也更容易发生死锁可恢复性有事务日志数据库崩溃后可以通过日志进行恢复没有日志支持查询性能要好于因为在查询过程中是在维护数据缓存并且先要定位到所在数据块然后从数据块定位到数据内存地址来查找数据表结构文件的表结构文件包括表结构定义索引数据而的表数据文件为数据和索引集中存储和表结构定义记录存储顺序按照记录插入顺序按照主键大小顺序有序插入外键和事务均不支持支持对于每一条语言都默认封装成事务自动提交这样会影响速度所以最好把多条语言放在和之间组成一个事务对一个包含外键的表转为会失败操作速度对于前者更优后者更优使用更块因为内部维护了一个计数器可以直接调度存储空间可被压缩存储空间较小的表需要更多的内存和存储会在主内存中建立专用的缓冲池用于高速缓存数据和索引索引方式二者都是树索引前者是堆表后者是索引组织表如果没有特别的需求使用默认的即可要支持事务选择如果不需要可以考虑如果表中绝大多数只是读查询考虑如果既有读也有写考虑索引和索引的区别索引类型不同是聚簇索引是非聚簇索引叶子节点存储数据不同的主键索引的叶子节点存储着行数据因此主键索引非常高效索引的叶子节点存储的是行数据地址需要再寻址一次才能得到数据查询效率不同非主键索引的叶子节点存储的是主键和其他带索引的列数据因此查询时做到覆盖索引会非常高效优化深度分页优化比如这条在执行的过程中通过非聚簇索引去查询主键然后拿到主键再通过聚簇索引进行回表查询查询到满足条件的条数据丢弃前面的条返回最后条优化的思路也很清楚就是减少回表的次数尽量通过索引来查询一般的优化方案是覆盖索引子查询的方式进行优化将非聚簇索引上使用索引覆盖这样就可以不用回表了使用子查询先查询出符合条件的然后对当作条件进行判断延迟关联覆盖索引子查询优化记录上次查询的位置执行较慢如何排查和优化没有索引或者没有命中索引索引可以加速查询如果没有合适的索引或者没有命中索引查询就会变得很慢可以通过分析查询执行计划来确定是否存在索引问题并根据执行计划的建议创建或修改索引单表数据过多导致查询瓶颈如果单表数据过多查询就会变得很慢可以通过分区水平或者垂直拆分表等方法来优化表结构以减少查询数据量网络原因或者机器负载过高如果网络延迟高或者机器负载过高查询就会变得很慢可以通过增加网络带宽优化网络拓扑升级硬件等方法来解决网络或者机器负载问题热点数据导致单点负载不均衡如果热点数据过多可能导致单点负载不均衡影响查询性能可以通过负载均衡缓存分布式存储等方法来解决单点负载不均衡问题如何定位和处理慢查询开启慢查询日志通过开启慢查询日志会记录所有执行时间超过阈值的查询从而可以分析和优化慢查询可以通过设置参数和来控制慢查询日志的行为和阈值使用命令或命令分析查询使用命令可以分析查询的执行计划以便识别潜在的瓶颈和优化机会可以根据的输出来调整查询语句和索引优化查询语句在设计查询语句时应该尽量避免全表扫描使用不必要的子查询和操作等可以通过修改查询语句来提高查询性能创建合适的索引索引可以提高查询性能但需要根据具体情况来选择合适的索引类型和字段可以使用命令来查看表的索引情况调整系统参数可以通过调整的参数来提高查询性能如等如何对进行调优优化主要从三点考虑最大化利用索引尽量避免全表扫描减少无效数据的查询根据慢查询日志定位慢查询慢查询日志记录了所有执行时间超过指定值的语句的日志默认为秒使用或者查看的执行计划首先查看字段字段表示访问表的方式查看是否出现了全表扫描然后查看字段查看是否出现了或者值这两种情况都是可以使用索引优化的最后查看字段查看具体使用了什么类型的索引确定是否需要回表尽可能使用主键索引减少回表查询另外还可以查看字段表示返回结果的行数占需读取行数的百分比的值越大越好事务事务如何使用事务是一组操作的集合它是一个不可分割的最小的工作单位事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求即这些操作要么同时成功要么同时失败开启事务开启事务提交事务回滚事务查看事务的提交方式设置事务的提交方式事务的特性原子性一个事务必须被视为一个不可分割的最小工作单元整个事务中的所有操作要么全部提交成功要么全部失败回滚事务是操作的最小单位不可再分一致性数据库总是从一个一致性转换到另一个一致性即事务发生前和事务发生后数据的完整性必须保持一致隔离性多个事务之间的数据是相互隔离的当并发访问数据库时一个正在执行的事务的修改对其他事务时不可见的持久性一个事务一旦被提交或者回滚它对数据库中的数据的改变是永久性的即使出现错误事务也不允许撤销只能通过补偿性事务事务的隔离级别读未提交指一个事务还没提交时它做的变更就能被其他事务看到读未提交的数据称之为脏读读已提交指一个事务提交之后它做的变更才能被其他事务看到这种隔离级别支持不可重复读因为同一事务在不同时期读取到的数据可能是不一样的可重复读指一个事务执行过程中看到的数据一直跟这个事务启动时看到的数据是一致的引擎的默认隔离级别但是会产生幻读的问题当前事务读取某一范围的数据时另一个事务又在该范围内插入了新行用户再次读取时会出现新的幻影可串行化会对记录加上读写锁在多个事务对这条记录进行读写操作时如果发生了读写冲突的时候后访问的事务必须等前一个事务执行完成才能继续执行查看隔离级别设置隔离级别并发事务会出现的问题脏读脏读指的是读到了其他事务未提交的数据未提交意味着这些数据可能会回滚也就是可能最终不会存到数据库中也就是不存在的数据不可重复读对比可重复读不可重复读指的是在同一事务内不同的时刻读到的同一批数据可能是不一样的可能会受到其他事务的影响比如其他事务改了这批数据并提交了通常针对数据更新操作幻读幻读是针对数据插入操作来说的假设事务对某些行的内容作了更改但是还未提交此时事务插入了与事务更改前的记录相同的记录行并且在事务提交之前先提交了而这时在事务中查询会发现好像刚刚的更改对于某些数据未起作用让用户感觉感觉出现了幻觉这就叫幻读可重复读可重复读指的是在一个事务内最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的的默认隔离级别是什么存储引擎的默认支持的隔离级别时可重复读可以通过命令来查看可以使用生产环境数据库使用哪种隔离级别中的锁锁的分类中的锁可以按照锁的粒度划分成行锁锁定单行数据其他会话可以访问表中的其他行适用于对数据进行细粒度操作时使用表锁锁定整张表其他会话无法访问该表中的任何行适用于对表进行全局操作时使用按照使用方式划分共享锁多个事务可以同时持有相同的共享锁但是不允许进行写操作只能进行读操作使用方式是在查询语句后面加上排他锁只允许一个事务持有它其他事务不能同时持有相同锁也不能进行读写操作使用方式是在需要执行的语句后面加上对于语句会自动加上排他锁按照思想的划分乐观锁总是假设最好的情况因此在进行操作时不加锁而是在提交时检查是否有其他事务已经修改了数据如果没有则提交成功如果有则回滚操作悲观锁总是假设最坏的情况因此在进行操作时先加锁然后再进行数据修改悲观锁会对数据进行加锁保护以防止其他事务再对数据进行修改',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-28 18:04:14',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小奥</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Go面经<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Java面经<sup>1</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 1.05rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">MySQL面经<sup>1</sup></a><a href="/tags/SpringBoot3/" style="font-size: 1.05rem;">SpringBoot3<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 1.05rem;">接口限流<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">计算机网络面经<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/" itemprop="url">MySQL</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>MySQL面经</span></a></span></div></div><h1 class="post-title" itemprop="name headline">MySQL面经篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-26T12:31:19.000Z" title="发表于 2023-12-26 20:31:19">2023-12-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-28T10:04:14.687Z" title="更新于 2023-12-28 18:04:14">2023-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/png/19.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/MySQL/" itemprop="url">MySQL</a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" tabindex="-1" itemprop="url">MySQL面经</a><h1 id="CrawlerTitle" itemprop="name headline">MySQL面经篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小奥</span><time itemprop="dateCreated datePublished" datetime="2023-12-26T12:31:19.000Z" title="发表于 2023-12-26 20:31:19">2023-12-26</time><time itemprop="dateCreated datePublished" datetime="2023-12-28T10:04:14.687Z" title="更新于 2023-12-28 18:04:14">2023-12-28</time></header><h1 id="MySQL面试题汇总"><a href="#MySQL面试题汇总" class="headerlink" title="MySQL面试题汇总"></a>MySQL面试题汇总</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><p>第一范式：数据库的每一列都是不可分割的原子项。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键只依赖于主键，不依赖于其他非主键，即不存在依赖传递。</p>
<h2 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h2><p>（1）<strong>存储方式：</strong><code>char</code>类型的数据是定长的，当存储时，MySQL会将所有的字符都填充到定长，检索时会去掉空格，因此存储时占用的空间固定；而<code>varchar</code>类型的数据是变长的，它只会存储实际使用的字符，因此存储时占用的空间是可变的。</p>
<p>（2）<strong>查找效率：</strong>char的查找效率比varchar要高。</p>
<p>（3）<strong>字符串长度：</strong>char类型的数据长度是固定的，可以存储0到255个字符，而varchar类型的数据长度是可变的，可以存储0到65535个字符。</p>
<p>（4）<strong>使用场景：</strong>通常，char类型的数据适合存储长度固定的数据，例如国家代码、邮编等；而varchar类型的数据适合存储长度不固定的数据，例如用户名、地址等。</p>
<h2 id="drop、truncate和delete的区别"><a href="#drop、truncate和delete的区别" class="headerlink" title="drop、truncate和delete的区别"></a>drop、truncate和delete的区别</h2><p><strong>（1）作用范围</strong>：drop会删除整张表和表结构，以及表的索引、约束和触发器；truncate只删除全部表数据，表的结构、索引、约束等会被保留；delete只删除表的全部或者部分数据，表结构、约束、索引等会被保留。</p>
<p><strong>（2）作用方式：</strong>delete是DML(data maintain language)语句，执行删除操作的过程是每次从表中删除一行，并同时将该行的删除操作作为事务记录在日志中保存以便于进行回滚操作；truncate、drop是DLL(data define language)语句，删除行是不能恢复的，并且在删除过程中不会激活与表有关的触发器，执行速度比较块，原数据不放到rollback segment中，不能回滚。</p>
<p><strong>（3）条件限制：</strong>truncate和drop不支持添加where条件，而delete支持where条件。</p>
<p><strong>（4）执行速度：</strong>执行速度drop &gt; truncate &gt; delete，delete是逐行执行的，并且在执行时会把操作日志记录下来，以备日后回滚使用，所以delete的执行速度是比较慢的；而truncate的操作是先复制一个新的表结构，然后删除掉原来的表，所以它的执行速度居中，而drop的执行速度最快。</p>
<h2 id="select-from-a-b和join的区别"><a href="#select-from-a-b和join的区别" class="headerlink" title="select from a,b和join的区别"></a>select from a,b和join的区别</h2><p>（1）<code>select from a,b</code>使用的是<strong>SQL隐式连接</strong>（也被称为笛卡尔积），对于表a中的每一行，都会将表b中的所有行与之匹配，生成一个新的结果集。这种连接通常会导致结果集非常大，因为它将两个表中的所有数据都组合在一起，而且没有经过任何的筛选或者限制。</p>
<p>（2）<code>join</code>使用的SQL的显示连接，它使用<code>on</code>子句来指定连接条件，只有满足条件的数据行才会被返回，这种连接方式可以减少结果集的大小，同时还可以更加精细的筛选和限制。</p>
<h2 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h2><p>外连接通过outer join来实现，它将返回两张表中满足连接条件的数据，同时返回不满足条件的数据。</p>
<p>外连接有两种形式：左连接和右连接。</p>
<ul>
<li><p>左外连接<code>left join on</code>：简称为左连接，它会返回左表中的所有记录和右表中满足连接条件的记录。</p>
<ul>
<li>两表关联，左表全部保留，右表关联不上用null表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接<code>right join on</code>：简称为右连接，它会返回右表中的所有记录和左表中满足连接条件的记录。</p>
<ul>
<li>两表关联，右表全部保留，左表关联不上用null表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件 ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全连接<code>union</code>：两表的内容均保留，没有关联的字段用null表示。在mysql中使用union表示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B</span><br></pre></td></tr></table></figure>

<p>对于联合查询的多张表的列表必须要保持一致，字段类型也要保持一致。</p>
<p>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重。</p>
</li>
</ul>
<h2 id="group-by的用法"><a href="#group-by的用法" class="headerlink" title="group by的用法"></a>group by的用法</h2><p>group by一般用于分组统计，就是可以根据一个或者多个字段，对查询到的数据进行分组。</p>
<p>group by如果单独使用的话，会返回每组第一行的数据。</p>
<p>group by的常规用法就是配合聚合函数，利用分组信息进行统计，同时还可以配合having进行筛选过滤。</p>
<p>另一方面，having子句中不能使用除了分组字段和聚合函数之外的其他字段。</p>
<h2 id="Limit分页的用法"><a href="#Limit分页的用法" class="headerlink" title="Limit分页的用法"></a>Limit分页的用法</h2><p>limit子句可以用于强制select语句返回指定的记录数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 limit 参数<span class="number">1</span>,参数<span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 limit 参数<span class="number">2</span> <span class="keyword">offset</span> 参数<span class="number">1</span>;（为了与 PostgreSQL 兼容）</span><br><span class="line">参数<span class="number">1</span>：指定第一个返回记录行的偏移量，从<span class="number">0</span>开始</span><br><span class="line">参数<span class="number">2</span>：指定返回记录行的最大数目</span><br><span class="line">如果只给定一个参数，那么表示返回的最大记录行数目。</span><br><span class="line">如果第二个参数为<span class="number">-1</span>，表示第一个参数的偏移量之后的所有的数据</span><br></pre></td></tr></table></figure>

<h2 id="where和having的区别"><a href="#where和having的区别" class="headerlink" title="where和having的区别"></a>where和having的区别</h2><p>（1）where是一个<strong>约束声明</strong>，在对查询结果返回之前将不符合where条件的数据给去掉，where是在结果返回之前起作用的，where中不能使用聚合函数，即使用where条件过滤出特定的行。</p>
<p>（2）having是一个<strong>过滤声明</strong>，是在查询返回结果集以后对查询结果进行的过滤操作，在having中可以使用聚合函数。另一方面，having子句中不能使用除了分组字段和聚合函数之外的其他字段。</p>
<p>从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</p>
<h2 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h2><p>union和union all的用法都是联合查询结果，它们的区别如下：</p>
<p>（1）显示结果不同：union会自动压缩多个结果集合中的重复结果，而union all则是将所有的结果显示出来。</p>
<p>（2）对重复结果的处理不同：union 是取唯一值，会筛选掉重复的记录，有去重的效果；而union all是直接链接，取到的是所有值。</p>
<p>（3）对排序的处理不同：union将会按照字段的顺序进行排序；union all只是简单的将两个结果和合并返回。从效率上来说，union all要比union的效率要高。</p>
<p>另外，使用union和union all必须保证各个select查询的列数必须相同，并且每个列的类型是一样的。但是列名不一定需要相等。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是对数据库中的一列或者多列的值进行排序的一种数据结构，可以帮助MySQL实现快速查询和检索数据。</p>
<p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据库io的成本</li>
<li>通过索引对数据进行排序，降低数据排序的成本，降低cpu的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要使用物理文件存储，占用一定的空间</li>
<li>索引大大提高的查询效率，但是同时降低了SQL的执行效率，如实现增删改的时候，效率降低。</li>
</ul>
<h2 id="什么是全文索引"><a href="#什么是全文索引" class="headerlink" title="什么是全文索引"></a>什么是全文索引</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7101116456489713700">一文给你讲清楚MySql全文索引实战和原理 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>全文索引，就是通过建立倒排索引，可以极大的提升检索效率，解决判断字段受否包含的问题。如果我们使用模糊查询<code>%str%</code>，那么当匹配字符在前面的时候，索引就会失效，这时检索效率比较低。全文索引就可以解决这个问题。</p>
<h2 id="数据库索引有什么作用"><a href="#数据库索引有什么作用" class="headerlink" title="数据库索引有什么作用"></a>数据库索引有什么作用</h2><p>数据库索引是一种特殊的数据结构，可以<strong>提高数据库查询操作的效率</strong>。 它通过预先建立一个包含目标数据的索引表，加快了数据库中大数据量的查询速度。</p>
<p>具体来说，索引可以为数据库表中的一列或多列创建一个快速查找路径，并将它们存储在内存或磁盘中。当我们执行一条 SQL 查询时，数据库引擎会首先检查是否存在适用于该查询的索引，如果找到就可以直接使用索引进行查询，避免了对整个数据库表的扫描，从而提高了查询速度。</p>
<h2 id="说说你对索引的理解"><a href="#说说你对索引的理解" class="headerlink" title="说说你对索引的理解"></a>说说你对索引的理解</h2><p>MySQL索引是一种用于提高查询效率的数据结构，它可以帮助MySQL快速定位到符合查询条件的数据。通常情况下，索引会被创建在数据表的某一列或多列上，以加速这些列的查询操作。在MySQL中，常见的索引类型包括B-Tree索引、哈希索引、全文索引等。</p>
<p>MySQL索引一共分为三种：</p>
<ul>
<li><strong>B-Tree索引</strong>是MySQL中最常用的索引类型，它是一种基于B-Tree数据结构的索引，在大多数情况下可以快速地定位到需要查询的数据。B-Tree索引对于范围查询和排序操作也比较高效，因为它可以快速地遍历索引树来定位数据。</li>
<li><strong>哈希索引</strong>则是一种基于哈希表的索引，它可以提供O(1)的查询效率，即查询的速度非常快。但是哈希索引只适用于等值查询，不能用于范围查询和排序操作。</li>
<li><strong>全文索引</strong>则是一种用于处理文本数据的索引，它可以快速地定位到包含查询关键词的文本数据。全文索引在处理大量文本数据时可以提高查询效率，但是它的创建和维护成本较高。</li>
</ul>
<p>在使用MySQL索引时需要注意以下几点：</p>
<ol>
<li>索引并不是越多越好，过多的索引会影响插入、更新和删除操作的性能。</li>
<li>对于频繁查询的列应该尽可能地创建索引，而对于不经常使用的列则不需要创建索引。</li>
<li>在创建索引时应该考虑到查询的效率和索引的大小，避免创建过大的索引。</li>
<li>在进行数据修改操作时，尽量减少索引的使用，避免出现频繁的索引重建和更新操作。</li>
</ol>
<h2 id="索引为什么能提升检索的效率"><a href="#索引为什么能提升检索的效率" class="headerlink" title="索引为什么能提升检索的效率"></a>索引为什么能提升检索的效率</h2><p>索引能提高检索的效率主要有以下几个方面：</p>
<p>（1）<strong>减少了对数据的扫描的数量和范围，提高了数据的查询速度。</strong>对于没有索引的情况下，数据库需要通过全表扫描查找符合条件的数据。而如果表中建立了索引，则可以通过直接读取索引进行定位，从而避免了大量的全表扫描，减少了数据扫描的数量和范围。</p>
<p>（2）<strong>优化了排序操作</strong>。当 SQL 查询包含 ORDER BY 子句时，索引可以帮助优化排序操作，使结果更快地返回。</p>
<h2 id="主键是什么索引"><a href="#主键是什么索引" class="headerlink" title="主键是什么索引"></a>主键是什么索引</h2><p>在MySQL中，主键是一种特殊的索引，用于唯一标识数据表中的每一行数据。主键可以是一个或多个列的组合，并且它们的值必须是唯一的，且不能为空。当创建主键时，MySQL会自动为主键列创建一个B-Tree索引来加速主键查找操作。</p>
<p>由于主键值是唯一的，因此主键索引可以帮助MySQL快速地定位到数据表中的唯一一行数据，这对于频繁查询和更新主键列的操作非常有帮助。此外，主键索引还可以作为其他索引的引用，例如外键约束，从而保证数据表之间的关联关系。</p>
<p>需要注意的是，当表中没有主键或主键不明确时，MySQL会使用一个名为“隐藏主键”的索引来代替。这个隐藏主键索引是一个自增整数列，用来唯一标识数据表中的每一行数据。</p>
<h2 id="如何避免回表查询"><a href="#如何避免回表查询" class="headerlink" title="如何避免回表查询"></a>如何避免回表查询</h2><p><strong>（1）尽量使用覆盖索引</strong>：尽可能使用覆盖索引，即在查询结果中包含所有需要返回的列，这样MySQL就不需要回到数据表中检索数据行，可以直接从索引中获取结果。需要注意的是，覆盖索引通常只适用于查询比较简单的情况。</p>
<p><strong>（2）索引优化</strong>：优化查询语句，尽量使用优化的索引。例如，如果查询语句中包含多个列，则可以创建一个包含这些列的复合索引，以提高查询效率。在创建索引时，还可以使用前缀索引、全文索引等技术来优化索引效率。</p>
<h2 id="哪些列需要建立索引"><a href="#哪些列需要建立索引" class="headerlink" title="哪些列需要建立索引"></a>哪些列需要建立索引</h2><p>（1）适合建立索引</p>
<ul>
<li>主键，强制该列的唯一性和组织表中的数据结构</li>
<li>外键，经常用于表连接，加快表之间的连接速度</li>
<li>经常需要查询的列（where），建立索引，增加搜索速度</li>
<li>经常需要排序的列，因为索引已经排序，利用索引的排序，加快查询的速度。</li>
<li>经常需要统计或者分组的字段</li>
</ul>
<p>（2）不适合建立索引</p>
<ul>
<li>表中记录比较少的</li>
<li>基本用不到where条件的列</li>
<li>文本或者超长字段的列</li>
<li>频繁进行数据操作的列</li>
<li>数据重复且分布平均的列</li>
</ul>
<h2 id="建立索引的原则"><a href="#建立索引的原则" class="headerlink" title="建立索引的原则"></a>建立索引的原则</h2><p>MySQL索引是提高查询效率的重要手段之一，但是索引的建立也需要一定的原则和注意事项。下面是建立MySQL索引的一些原则：</p>
<p>（1）确定需要建立索引的列</p>
<p>在建立索引之前，需要先确定需要建立索引的列。通常，建议将索引建在经常使用作为查询条件的列上，或者在数据表中唯一或者高度重复的列上。如果索引太多或者太少，都可能会影响查询性能。</p>
<p>（2）选择适当的索引类型</p>
<p>MySQL支持多种索引类型，如B-tree索引、哈希索引等。不同的索引类型适合不同的查询场景，需要根据实际情况选择适当的索引类型。</p>
<p>（3）不要在过多列上建立联合索引</p>
<p>联合索引可以在多个列上建立索引，通常可以提高查询效率。但是在建立联合索引时需要注意，不要在过多列上建立联合索引，否则会影响索引的效率。</p>
<p>（4）避免在索引列上使用函数或运算符</p>
<p>在查询条件中，如果使用了函数或运算符，会导致MySQL无法使用索引进行查询，降低查询效率。因此，在建立索引时需要避免在索引列上使用函数或运算符。</p>
<p>（5）确保数据表的数据量足够大</p>
<p>对于数据量较小的数据表，建立索引可能会降低查询性能。因此，在建立索引之前需要确保数据表的数据量足够大，以便充分发挥索引的优势。</p>
<p>（6）定期优化索引</p>
<p>随着数据表中数据的增加和删除，索引的效率也会发生变化。因此，需要定期优化索引，以确保索引的效率最大化。</p>
<h2 id="说说你对B-树的理解"><a href="#说说你对B-树的理解" class="headerlink" title="说说你对B+树的理解"></a>说说你对B+树的理解</h2><p>B+树是一种常见的数据结构，常用于实现关系型数据库中的索引。B+树的结构类似于二叉树，但其具有以下特点：</p>
<p>（1）B+树的非叶子节点存储的是索引信息，而叶子节点存储的是数据信息。这使得B+树可以快速定位到数据所在的叶子节点。</p>
<p>（2）每个节点中的关键字按顺序排列，且相邻节点之间的关键字满足顺序约束。这使得B+树可以进行范围查询和排序操作。</p>
<p>（3）B+树的每个节点都有多个子节点，且每个子节点存储的关键字范围是相同的。这使得B+树可以进行快速的查找和插入操作。</p>
<p>（4）B+树的高度较低，通常不超过3-4层，这使得B+树的查询、插入、删除操作都具有较快的速度。</p>
<p>B+树的优点在于其能够高效地支持范围查询、排序和快速定位数据。在实际应用中，B+树常被用于实现关系型数据库的索引结构。B+树的缺点在于其插入和删除操作可能导致树的平衡性失衡，需要进行平衡调整操作，同时节点的分裂和合并操作会导致性能的损失。</p>
<h2 id="索引的数据结构是什么样的"><a href="#索引的数据结构是什么样的" class="headerlink" title="索引的数据结构是什么样的"></a>索引的数据结构是什么样的</h2><p>MySQL默认的存储引擎是InnoDB，它采用的是B+树结构的索引。</p>
<p>B+树的特点如下：</p>
<p>（1）B+树的非叶子节点存储的是索引信息，而叶子节点存储的是数据信息。这样可以使得B+树快速定位到数据所在的叶子节点。</p>
<p>（2）非叶子节点之间使用双向指针链接，且相邻之间的关键字满足顺序约束，这使得B+树可以进行范围查询和排序。</p>
<p>（3）B+树的每个节点都有多个子节点，且每个子节点存储的关键字的范围是相同的，这使得B+树可以进行快速查询和插入操作。</p>
<h2 id="索引底层采用的什么数据结构"><a href="#索引底层采用的什么数据结构" class="headerlink" title="索引底层采用的什么数据结构"></a>索引底层采用的什么数据结构</h2><p>数据库索引底层采用的数据结构有多种，常见的包括：</p>
<ul>
<li>B树（B-Tree）：是一种自平衡的树状数据结构，可用于存储排序后的数据，主要用于提高磁盘访问效率。</li>
<li>B+树（B+ Tree）：在 B 树的基础上增加了一个链表结构，能够更快地进行遍历和范围查询。</li>
<li>Hash 索引：使用哈希函数将索引列映射到一个哈希值，并将该值与索引表中的记录关联。它适用于等值比较的查询操作，但不适用于区间查询或模糊查询。</li>
<li>R 树（R-Tree）：是一种用于空间数据索引的树状数据结构，可以支持空间数据的查询和分析。</li>
<li>Bitmap 索引：将索引列中的每个值使用二进制位表示，其中每个位表示诸如“存在”、“不存在”等信息。通过位运算可以实现类似于布尔运算的复杂查询。</li>
</ul>
<p>在选择合适的索引数据结构时需要考虑具体的应用场景和需求，如数据规模、读写比例、查询类型等因素。对于大型数据集和频繁的查询操作，通常采用 B+ 树索引。而对于空间数据和全文搜索等特殊类型的数据，可能需要采用 R 树、全文索引等特定的索引结构。</p>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>（1）按数据结构分类：</p>
<ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-text索引</li>
</ul>
<p>（2）按物理存储分类：</p>
<ul>
<li>聚簇索引(主键索引)</li>
<li>二级索引(辅助索引)</li>
</ul>
<p>（3）按字段特性分类：</p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>前缀索引</li>
</ul>
<p>（4）按字段个数分类：</p>
<ul>
<li>单列索引</li>
<li>联合索引</li>
</ul>
<h2 id="一颗B-树能存储多少条数据"><a href="#一颗B-树能存储多少条数据" class="headerlink" title="一颗B+树能存储多少条数据"></a>一颗B+树能存储多少条数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1280</span> ^ (n - <span class="number">1</span>)) * <span class="number">15</span>  <span class="comment">// n为B+树的层数</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么要使用B-树作为索引"><a href="#为什么要使用B-树作为索引" class="headerlink" title="为什么要使用B+树作为索引"></a>为什么要使用B+树作为索引</h2><p>（查询速度、稳定性、存储数据大小、查找磁盘次数方面）</p>
<p>（1）相对于二叉树来说：B+树的层级更少，搜索的效率更高</p>
<p>（2）相对于B-Tree来说，B-Tree无论是叶子节点还是非叶子节点，都会保存数据，这样导致页中的键值减少，同样要保存大量的数据，只能是增加树的高度，这样就会降低了检索的效率。</p>
<p>（3）相对于Hash索引来说，B+Tree支持范围匹配以及排序操作。</p>
<p>（4）内存空间：一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数。</p>
<h2 id="B-树索引和hash索引的区别"><a href="#B-树索引和hash索引的区别" class="headerlink" title="B+树索引和hash索引的区别"></a>B+树索引和hash索引的区别</h2><p><strong>（1）是否支持排序。</strong>哈希索引不支持排序，因为哈希表是无序的。B+树索引是有序的，并且支持排序。</p>
<p><strong>（2）是否支持范围查找。</strong>哈希索引无序，所以不支持范围查找。</p>
<p><strong>（3）是否支持模糊查询。</strong>哈希索引不支持模糊查询以及索引最左前缀匹配。</p>
<p><strong>（4）效率方面。</strong>哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的。</p>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>（1）B树：一种多路自平衡搜索树，通过节点存储，并对节点进行了排序；一个节点可以存储多个元素，元素之间也是排序的。</p>
<p>（2）B+树：B+树是B树的变种，叶子节点之间有指针，非叶子节点上不存储元素，元素的存储都在叶子节点上，并且是排好序的。</p>
<p>（3）区别：</p>
<ul>
<li><strong>节点结构：</strong>B树中的每个结点既包含索引键也包含数据，并且叶子节点之间没有关系；而B+树种的每个非叶子节点只包含索引键，数据只存在叶子节点中，叶子节点之间有指针连接。</li>
<li><strong>查找方式：</strong>B树中，通过从根节点开始，根据节点中的索引键找到对应的子节点，并继续查找，直到叶子节点中找到目标数据。而在B+树中，只需要从根节点开始，根据节点中的索引键找到叶子节点，并在叶子节点中查找目标数据。</li>
<li><strong>插入和删除操作：</strong>在B树中，插入和删除数据时，需要将数据插入或者删除到对应的叶子节点中，如果叶子节点中的数据个数少于阈值，则需要将节点中的数据进行调整。而在B+树中，插入和删除数据时，只需要调整对应的叶子节点，并更新父节点中的索引即可。</li>
<li><strong>范围查找：</strong>B+树比B树更适合范围查找，因为B+树的所有叶子节点都包含了数据，而B树的非叶子节点也包含了数据，因此在进行范围查找时，需要遍历B树的所有节点，而B+中只需要遍历叶子节点即可。</li>
<li><strong>效率：</strong>B树的每个节点都存储了数据，因此每次查找的IO开销比较大，而在<strong>B+树</strong>中，非叶结点不含有数据，就可以包含更多关键字，磁盘IO的次数比较少，而且每次都需要查找到叶子节点，效率比较稳定，时间复杂度未为O(logN)。</li>
</ul>
<h2 id="B-树影响IO次数的因素"><a href="#B-树影响IO次数的因素" class="headerlink" title="B+树影响IO次数的因素"></a>B+树影响IO次数的因素</h2><p>（1） <strong>B+树的高度：</strong>B+树的高度越低，需要访问的节点数就越少，从而IO次数就越少。B+树的高度受到节点大小和节点个数的限制，通常情况下，节点大小越大，节点个数越多，B+树的高度就越低。</p>
<p>（2）<strong>磁盘块的大小：</strong>磁盘块是磁盘IO的最小单位，磁盘块大小越大，每次读取或写入的数据就越多，从而IO次数就越少。B+树节点大小的选择应该与磁盘块大小相适应，通常情况下，节点大小应该等于或略小于磁盘块大小。</p>
<p>除了这两个因素，B+树的节点分裂和合并操作也会影响IO次数。在插入和删除数据时，如果需要进行节点分裂或合并操作，则需要进行额外的IO操作，从而增加了IO次数。因此，B+树的节点分裂和合并操作应该尽量减少，这可以通过调整节点大小和阈值来实现</p>
<h2 id="B-树的层数取决于什么因素"><a href="#B-树的层数取决于什么因素" class="headerlink" title="B+树的层数取决于什么因素"></a>B+树的层数取决于什么因素</h2><p>（1）<strong>节点大小：</strong>B+树的每个节点存储的关键字个数越多，每个节点能够覆盖的数据范围就越大，B+树的层数也就越低。通常情况下，节点大小应该等于或略小于磁盘块大小，这样可以减少IO次数，提高查询效率。</p>
<p>（2）<strong>关键字总数：</strong>B+树的关键字总数越多，B+树的层数就越高。在设计B+树的时候，应该考虑到数据规模和查询频率，避免出现B+树的层数过高的情况。</p>
<p>（3）<strong>每个节点的叶子节点数：</strong>B+树的每个节点存储的子节点数越多，B+树的层数就越低。但是，子节点数过多也会增加节点的大小，导致IO次数增加。在设计B+树的时候，应该平衡节点大小和子节点数，使B+树的层数和查询效率达到一个最优点。</p>
<p>（4）<strong>页分裂和合并操作：</strong>在插入和删除数据时，如果需要进行节点分裂或合并操作，则会导致B+树的层数发生变化。分裂操作会使B+树的层数增加，合并操作会使B+树的层数减少。因此，B+树的节点分裂和合并操作应该尽量减少，这可以通过调整节点大小和阈值来实现。</p>
<h2 id="B-树的每一层越宽越好吗？"><a href="#B-树的每一层越宽越好吗？" class="headerlink" title="B+树的每一层越宽越好吗？"></a>B+树的每一层越宽越好吗？</h2><p>B+树每一层越宽不一定越好，它需要平衡节点宽度和树高度来达到最佳查询性能。</p>
<p>当B+树的节点宽度较大时，每个节点可以存储更多的键值对，可以减少树高度，从而减少访问磁盘的次数，提高查询性能。但是，节点宽度过大也会导致节点占用的存储空间变大，可能会出现一些存储空间浪费的情况。</p>
<p>当B+树的节点宽度较小时，节点可以存储的键值对数量较少，B+树的高度可能会增加，从而访问磁盘的次数也会增加。但是，节点宽度较小可以减少存储空间浪费，也可以提高节点的利用率。</p>
<p>因此，选择节点宽度的大小应该根据实际情况进行综合考虑。通常情况下，节点宽度应该根据磁盘块的大小和查询性能的要求进行平衡，使得B+树的高度最小化，并且节点的利用率和存储空间利用率也尽可能地高。</p>
<h2 id="B-树如何实现平衡"><a href="#B-树如何实现平衡" class="headerlink" title="B+树如何实现平衡"></a>B+树如何实现平衡</h2><p>B+树的平衡主要是通过节点的拆分和自行控制行高来实现的。</p>
<p>（1）节点拆分。当一个节点中的关键字数目超过了预定的数目时，需要将该节点进行拆分，以保证树的平衡。具体地，将该节点中的关键字一分为二，分别分配给两个新节点，同时将分裂出的关键字上移到父节点中。这样，树的高度会增加1，但是所有节点的关键字数目都得到了控制，从而保证了树的平衡。</p>
<p>（2）自行控制行高。B+树中的叶子节点只存储数据，而非数据和索引，这样可以避免非叶子节点的频繁访问，从而提高查询效率。同时，为了保证B+树的平衡，可以将所有叶子节点的高度控制在相同的水平上，即所有叶子节点的深度相等。当叶子节点中的数据发生变化时，需要将变化后的节点重新排序并重建叶子节点之间的链表，以保证所有叶子节点的深度相等。</p>
<h2 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h2><p><strong>聚簇索引是将数据和索引存储在一起，与索引的顺序相同。</strong>它们通常是主键索引，因为主键是表中的唯一标识符。种索引的优点是可以快速地对表进行搜索和排序。当使用聚簇索引进行查找时，数据库可以通过直接读取数据页来避免大量的I&#x2F;O操作，从而提高查询效率。但缺点是当更新数据时，需要对整个表进行重组，因此更新操作可能会变得更慢。</p>
<p><strong>非聚簇索引是将索引和数据分开存储。</strong>索引包含指向数据行的指针，因此当使用非聚簇索引进行查询时，数据库需要进行两次磁盘访问：一次访问索引页，另一次访问数据页。这种索引的优点是在进行更新操作时不需要重组整个表，因此更新操作更快，但缺点是查询时需要额外的I&#x2F;O操作，因此查询速度可能会受到影响。</p>
<h2 id="索引查询过程"><a href="#索引查询过程" class="headerlink" title="索引查询过程"></a>索引查询过程</h2><p>（1）解析SQL并且优化查询计划。MySQL在执行查询之前，需要先解析SQL语句并进行优化，以确定如何执行查询。在优化查询计划时，MySQL会尝试使用索引来加速查询操作。</p>
<p>（2）查找索引。如果查询语句中包含WHERE条件或JOIN操作，MySQL会查找匹配这些条件的索引。如果找到多个索引，则会选择一个最适合的索引。如果没有找到索引，则会执行全表扫描。</p>
<p>（3）读取索引并获取数据行。当MySQL找到匹配条件的索引后，它会使用索引来定位数据行的位置。这通常需要从磁盘读取索引和数据行。如果数据行不在内存中，则需要从磁盘中读取数据行。这是查询操作中最耗时的步骤之一。</p>
<p>（4）过滤数据行。MySQL会根据WHERE条件过滤数据行，以删除不匹配的数据行。这可以减少需要返回的数据量，提高查询速度。</p>
<p>（5）返回查询结果。当MySQL找到匹配条件的数据行后，它会将这些数据行返回给客户端。</p>
<h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7069562982711164965#heading-6">15个必知的Mysql索引失效场景，别再踩坑了！ - 掘金 (juejin.cn)</a></p>
<p><strong>（1）联合索引不满足最左匹配原则。</strong>联合索引的使用遵循最左匹配原则，在联合索引中，最左侧的字段优先匹配。在查询的时候，如果想让查询条件走索引，那么最左边的字段要出现在查询条件中。</p>
<p><strong>（2）运算操作或者函数操作。</strong>原因是因为如果没有进行运算操作，那么MySQL会直接走索引去B+树中查询数据。但是如果我们对字段进行了运算操作或者函数操作，实际上是拿新的字段去做查询，如果走索引，那么需要一个一个去对比，MySQL认为既然都要对比，不如直接全表扫描。</p>
<p><strong>（3）字符串类型字段不加引号。</strong>字符串字段如果不加引号，会发生隐式转换成int类型，参数类型与字段类型不匹配。</p>
<p><strong>（4）模糊查询匹配头部。</strong>索引本身相当于目录，将字符串字段从左到右依次排序，而左侧的占位符模糊匹配，导致无法正常按照目录进行匹配。所以索引会失效。</p>
<p><strong>（5）or连接的条件。</strong>如果or连接的条件左右其中有一个不是索引字段，那么如果是单独使用的话肯定是要走全表扫描的，连接在一起再次进行索引查询反而是浪费性能了，所以索引会失效。</p>
<p><strong>（6）索引列做 &lt; 、&gt;  或者&lt;&gt; 比较。</strong></p>
<p><strong>（7）查询使用<code>is not null</code>。</strong>如果使用<code>is null</code>正常走索引，但是使用<code>is not null</code>索引会失效。</p>
<p><strong>（8）查询条件使用<code>not in</code>时，如果是主键走索引；如果是普通索引，则索引失效。</strong></p>
<p><strong>（9）索引区分度比较高。</strong>查询优化器发现某个值出现在表的数据行中的百分比(<strong>惯用的百分比界线是30%</strong>)很高的时候，会忽略索引，进行全表扫描。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL的执行引擎有哪些"><a href="#MySQL的执行引擎有哪些" class="headerlink" title="MySQL的执行引擎有哪些"></a>MySQL的执行引擎有哪些</h2><p>主要有<strong>MyISAM</strong>、<strong>InnoDB</strong>、Memery等。</p>
<ul>
<li>InnoDB引擎是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的存储引擎。提供了对事务ACID的支持，还提供了行锁和外键的约束。</li>
<li>MyISAM是MySQL早期的默认的存储引擎，不支持事务、也不支持外键，支持表锁，访问速度较快。</li>
<li>Memery将数据放在内存中，数据的处理速度很快，但是安全性和可靠性不高。</li>
</ul>
<h2 id="MyISAM和InnoDB的区别，如何选择"><a href="#MyISAM和InnoDB的区别，如何选择" class="headerlink" title="MyISAM和InnoDB的区别，如何选择"></a>MyISAM和InnoDB的区别，如何选择</h2><ul>
<li><strong>锁的细粒度不同</strong>：InnoDB比MyISAM更好的支持并发，因为InnoDB的支持行锁，而MyISAM支持表锁，行锁对每一条记录上锁，所以开销更大，但是可以解决脏读和不可重复读的问题，相对来说也更容易发生死锁。</li>
<li><strong>可恢复性</strong>：InnoDB有事务日志，数据库崩溃后可以通过日志进行恢复，MyISAM没有日志支持。</li>
<li><strong>查询性能</strong>：MyISAM要好于InnoDB，因为InnoDB在查询过程中是在维护数据缓存。并且先要定位到所在数据块，然后从数据块定位到数据内存地址来查找数据。</li>
<li><strong>表结构文件</strong>：MyISAM 的表结构文件包括 .frm(表结构定义)，.MYI(索引)、.MYD（数据）；而InnDB的表数据文件为 .ibd(数据和索引集中存储)和.frm(表结构定义)。</li>
<li><strong>记录存储顺序</strong>：MyISAM按照记录插入顺序，InnoDB按照主键大小顺序有序插入。</li>
<li><strong>外键和事务</strong>：MyISAM均不支持，InnoDB支持。对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务。对一个包含外键的InnoDB表转为MYISAM会失败。</li>
<li><strong>操作速度</strong>：对于SELECT前者更优，INSERT、UPDATE、DELETE后者更优。select count(*)使用MyISAM更块，因为内部维护了一个计数器，可以直接调度。</li>
<li><strong>存储空间</strong>：MyISAM可被压缩，存储空间较小，InnoDB的表需要更多的内存和存储，会在主内存中建立专用的缓冲池用于高速缓存数据和索引。</li>
<li><strong>索引方式</strong>：二者都是B+树索引，前者是堆表，后者是索引组织表。</li>
</ul>
<p>如果没有特别的需求，使用默认的InnoDB即可。</p>
<p>要支持事务选择InnoDB，如果不需要可以考虑MyISAM；如果表中绝大多数只是读查询考虑MyISAM，如果既有读也有写考虑InnoDB。</p>
<h2 id="MyISAM索引和InnoDB索引的区别"><a href="#MyISAM索引和InnoDB索引的区别" class="headerlink" title="MyISAM索引和InnoDB索引的区别"></a>MyISAM索引和InnoDB索引的区别</h2><ul>
<li><strong>索引类型不同：</strong>InnDB是聚簇索引，MyISAM是非聚簇索引。</li>
<li><strong>叶子节点存储数据不同：</strong>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li><strong>查询效率不同：</strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="limit深度分页优化"><a href="#limit深度分页优化" class="headerlink" title="limit深度分页优化"></a>limit深度分页优化</h2><p>比如<code>limit 100000, 10</code>，这条SQL在执行的过程中，通过非聚簇索引去查询主键，然后拿到主键再通过聚簇索引进行回表查询，查询到满足条件的100010条数据，丢弃前面的100000条，返回最后10条。</p>
<p>优化的思路也很清楚，就是减少回表的次数，尽量通过索引来查询。</p>
<p>一般的优化方案是 <code>覆盖索引 + 子查询</code>的方式进行优化。</p>
<ul>
<li>将非聚簇索引上使用索引覆盖，这样就可以不用回表了。</li>
<li>使用where子查询，先查询出符合条件的id，然后对id当作条件进行判断。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">inner</span> <span class="keyword">join</span> 延迟关联</span><br><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> s, (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">1000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 覆盖索引</span><br><span class="line"><span class="keyword">select</span> id,username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> username limit <span class="number">10000000</span>, <span class="number">10</span>;   </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 子查询优化</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">10000000</span>, <span class="number">1</span>) limit <span class="number">10</span>; </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 记录上次查询的位置 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10000000</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="sql执行较慢如何排查和优化"><a href="#sql执行较慢如何排查和优化" class="headerlink" title="sql执行较慢如何排查和优化"></a>sql执行较慢如何排查和优化</h2><p>（1）<strong>没有索引或者 SQL 没有命中索引：</strong>索引可以加速 SQL 查询，如果没有合适的索引或者 SQL 没有命中索引，查询就会变得很慢。可以通过分析查询执行计划来确定是否存在索引问题，并根据执行计划的建议创建或修改索引。</p>
<p>（2）<strong>单表数据过多，导致查询瓶颈：</strong>如果单表数据过多，查询就会变得很慢。可以通过分区、水平或者垂直拆分表等方法来优化表结构，以减少查询数据量。</p>
<p>（3）<strong>网络原因或者机器负载过高：</strong>如果网络延迟高或者机器负载过高，SQL 查询就会变得很慢。可以通过增加网络带宽、优化网络拓扑、升级硬件等方法来解决网络或者机器负载问题。</p>
<p>（4）<strong>热点数据导致单点负载不均衡：</strong>如果热点数据过多，可能导致单点负载不均衡，影响 SQL 查询性能。可以通过负载均衡、缓存、分布式存储等方法来解决单点负载不均衡问题。</p>
<h2 id="如何定位和处理慢查询"><a href="#如何定位和处理慢查询" class="headerlink" title="如何定位和处理慢查询"></a>如何定位和处理慢查询</h2><p>（1）<strong>开启慢查询日志。</strong>通过开启慢查询日志，MySQL会记录所有执行时间超过阈值的查询，从而可以分析和优化慢查询。可以通过设置参数<code>slow_query_log</code>和<code>long_query_time</code>来控制慢查询日志的行为和阈值。</p>
<p>（2）<strong>使用EXPLAIN命令或DESC命令分析查询。</strong>使用EXPLAIN命令可以分析查询的执行计划，以便识别潜在的瓶颈和优化机会。可以根据EXPLAIN的输出来调整查询语句和索引。</p>
<p>（3）<strong>优化查询语句。</strong>在设计查询语句时，应该尽量避免全表扫描、使用不必要的子查询和JOIN操作等，可以通过修改查询语句来提高查询性能。</p>
<p>（4）<strong>创建合适的索引。</strong>索引可以提高查询性能，但需要根据具体情况来选择合适的索引类型和字段。可以使用SHOW INDEX命令来查看表的索引情况。</p>
<p>（5）<strong>调整系统参数。</strong>可以通过调整MySQL的参数来提高查询性能，如innodb_buffer_pool_size、query_cache_size等。</p>
<h2 id="如何对SQL进行调优"><a href="#如何对SQL进行调优" class="headerlink" title="如何对SQL进行调优"></a>如何对SQL进行调优</h2><p>SQL优化主要从三点考虑：<strong>最大化利用索引、尽量避免全表扫描、减少无效数据的查询</strong>。</p>
<p>（1）根据慢查询日志定位慢查询SQL。慢查询日志记录了所有执行时间超过指定值的SQL语句的日志，默认为10秒。</p>
<p>（2）使用<strong>explain</strong>或者esc查看SQL的执行计划。</p>
<ul>
<li>首先查看<strong>type</strong>字段，type字段表示访问表的方式，查看是否出现了全表扫描。</li>
<li>然后查看<strong>extra</strong>字段，查看是否出现了filesort或者using template值，这两种情况都是可以使用索引优化的。</li>
<li>最后查看<strong>key</strong>字段，查看具体使用了什么类型的索引，确定是否需要回表，尽可能使用主键索引，减少回表查询。</li>
<li>另外还可以查看<strong>filtered</strong>字段，表示返回结果的行数占需读取行数的百分比，filter的值越大越好。</li>
</ul>
<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><h2 id="事务如何使用"><a href="#事务如何使用" class="headerlink" title="事务如何使用"></a>事务如何使用</h2><p>事务是一组操作的集合，它是一个不可分割的最小的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction; # 开启事务 </span><br><span class="line"><span class="keyword">begin</span>; # 开启事务</span><br><span class="line"><span class="keyword">commit</span>; # 提交事务 </span><br><span class="line"><span class="keyword">rollback</span>; # 回滚事务 </span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>; # 查看事务的提交方式</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span>; # 设置事务的提交方式</span><br></pre></td></tr></table></figure>

<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p><strong>（1）原子性（atomicity）</strong>：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。事务是操作的最小单位，不可再分。</p>
<p><strong>（2）一致性（consistency）</strong>：数据库总是从一个一致性转换到另一个一致性。即事务发生前和事务发生后，数据的完整性必须保持一致。</p>
<p><strong>（3）隔离性（isolation）</strong>：多个事务之间的数据是相互隔离的，当并发访问数据库时，一个正在执行的事务的修改对其他事务时不可见的。</p>
<p><strong>（4）持久性（durability）</strong>：一个事务一旦被提交或者回滚，它对数据库中的数据的改变是永久性的。即使出现错误，事务也不允许撤销，只能通过“补偿性事务”。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>**读未提交(read uncommitted)**：指一个事务还没提交时，它做的变更就能被其他事务看到。读未提交的数据，称之为脏读(Dirty Read)。</p>
<p>**读已提交(read committed)**：指一个事务提交之后，它做的变更才能被其他事务看到。这种隔离级别支持不可重复读(Nonrepeatable Read)，因为同一事务在不同时期读取到的数据可能是不一样的。</p>
<p><strong>可重复读(repeatable read)<strong>：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，</strong>MySQL InnoDB 引擎的默认隔离级别</strong>。但是会产生幻读的问题，当前事务读取某一范围的数据时，另一个事务又在该范围内插入了新行，用户再次读取时，会出现新的“幻影”。</p>
<p>**可串行化(serializable )**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<blockquote>
<p>查看隔离级别</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction_isolation</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置隔离级别</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>

<h2 id="并发事务会出现的问题"><a href="#并发事务会出现的问题" class="headerlink" title="并发事务会出现的问题"></a>并发事务会出现的问题</h2><p><strong>脏读</strong>：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。</p>
<p><strong>不可重复读</strong>：对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新操作。</p>
<p><strong>幻读</strong>：幻读是针对数据插入操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，让用户感觉感觉出现了幻觉，这就叫幻读。</p>
<p><strong>可重复读</strong>：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。</p>
<h2 id="MySQL的默认隔离级别是什么"><a href="#MySQL的默认隔离级别是什么" class="headerlink" title="MySQL的默认隔离级别是什么"></a>MySQL的默认隔离级别是什么</h2><p>MySQL InnoDB 存储引擎的默认支持的隔离级别时<code>REPEATABLE-READ</code>（可重复读）。</p>
<p>可以通过<code>select @@tx_isolation;</code> 命令来查看，MySQL8.0可以使用<code>select @@transaction_isolation;</code>。</p>
<h2 id="生产环境数据库使用哪种隔离级别"><a href="#生产环境数据库使用哪种隔离级别" class="headerlink" title="生产环境数据库使用哪种隔离级别"></a>生产环境数据库使用哪种隔离级别</h2><h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>MySQL中的锁可以按照<strong>锁的粒度</strong>划分成：</p>
<p><strong>（1）行锁</strong>：锁定单行数据，其他会话可以访问表中的其他行，适用于对数据进行细粒度操作时使用。</p>
<p><strong>（2）表锁</strong>：锁定整张表，其他会话无法访问该表中的任何行，适用于对表进行全局操作时使用。</p>
<p>按照<strong>使用方式</strong>划分：</p>
<p><strong>（1）共享锁</strong>：多个事务可以同时持有相同的共享锁，但是不允许进行写操作，只能进行读操作。使用方式是在查询语句后面加上<code>lock in share mode</code>。</p>
<p><strong>（2）排他锁</strong>：只允许一个事务持有它，其他事务不能同时持有相同锁，也不能进行读写操作。使用方式是在需要执行的语句后面加上<code>for update</code>。对于update语句，MySQL会自动加上排他锁。</p>
<p>按照<strong>思想</strong>的划分：</p>
<p><strong>（1）乐观锁</strong>：总是假设最好的情况，因此在进行操作时不加锁，而是在提交时检查是否有其他事务已经修改了数据，如果没有，则提交成功，如果有，则回滚操作。</p>
<p><strong>（2）悲观锁</strong>：总是假设最坏的情况，因此在进行操作时先加锁，然后再进行数据修改。悲观锁会对数据进行加锁保护，以防止其他事务再对数据进行修改。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小奥</div><div class="post-copyright__author_desc">浮生若梦 为欢几何</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/')">MySQL面经篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=MySQL面经篇&amp;url=http://example.com/2023/12/26/MySQL%E9%9D%A2%E7%BB%8F%E7%AF%87/&amp;pic=/img/png/19.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小奥</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/MySQL/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>MySQL<span class="categoryesPageCount">2</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/MySQL%E9%9D%A2%E7%BB%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>MySQL面经<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/png/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/25/MySQL%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/16.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL联合索引最左匹配原则详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/26/Java%E9%9D%A2%E7%BB%8F%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java面经篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">Java、数据库、中间件</b>相关的学习笔记，还有<b style="color:#fff">面试题总结</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小奥</h1><div class="author-info__desc">浮生若梦 为欢几何</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoaozz" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-number">1.</span> <span class="toc-text">MySQL面试题汇总</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">数据库三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">char和varchar的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#drop%E3%80%81truncate%E5%92%8Cdelete%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">drop、truncate和delete的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-from-a-b%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">select from a,b和join的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%8F%B3%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.5.</span> <span class="toc-text">左连接和右连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">group by的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Limit%E5%88%86%E9%A1%B5%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">Limit分页的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#where%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">where和having的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union%E5%92%8Cunion-all%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">union和union all的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.</span> <span class="toc-text">什么是索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">什么是全文索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">数据库索引有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">说说你对索引的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E5%8D%87%E6%A3%80%E7%B4%A2%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">3.5.</span> <span class="toc-text">索引为什么能提升检索的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.6.</span> <span class="toc-text">主键是什么索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.7.</span> <span class="toc-text">如何避免回表查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%88%97%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">3.8.</span> <span class="toc-text">哪些列需要建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">3.9.</span> <span class="toc-text">建立索引的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9B-%E6%A0%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.10.</span> <span class="toc-text">说说你对B+树的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">3.11.</span> <span class="toc-text">索引的数据结构是什么样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E7%9A%84%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.12.</span> <span class="toc-text">索引底层采用的什么数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.13.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%A2%97B-%E6%A0%91%E8%83%BD%E5%AD%98%E5%82%A8%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">3.14.</span> <span class="toc-text">一颗B+树能存储多少条数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">3.15.</span> <span class="toc-text">为什么要使用B+树作为索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8Chash%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">B+树索引和hash索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.17.</span> <span class="toc-text">B树和B+树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E5%BD%B1%E5%93%8DIO%E6%AC%A1%E6%95%B0%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">3.18.</span> <span class="toc-text">B+树影响IO次数的因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E5%B1%82%E6%95%B0%E5%8F%96%E5%86%B3%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9B%A0%E7%B4%A0"><span class="toc-number">3.19.</span> <span class="toc-text">B+树的层数取决于什么因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E6%AF%8F%E4%B8%80%E5%B1%82%E8%B6%8A%E5%AE%BD%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">B+树的每一层越宽越好吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1"><span class="toc-number">3.21.</span> <span class="toc-text">B+树如何实现平衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.22.</span> <span class="toc-text">聚簇索引和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.23.</span> <span class="toc-text">索引查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.24.</span> <span class="toc-text">索引失效的场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">4.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">4.1.</span> <span class="toc-text">MySQL的执行引擎有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">4.2.</span> <span class="toc-text">MyISAM和InnoDB的区别，如何选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E7%B4%A2%E5%BC%95%E5%92%8CInnoDB%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">MyISAM索引和InnoDB索引的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#limit%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">limit深度分页优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E6%89%A7%E8%A1%8C%E8%BE%83%E6%85%A2%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">sql执行较慢如何排查和优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%A4%84%E7%90%86%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.3.</span> <span class="toc-text">如何定位和处理慢查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9SQL%E8%BF%9B%E8%A1%8C%E8%B0%83%E4%BC%98"><span class="toc-number">5.4.</span> <span class="toc-text">如何对SQL进行调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">MySQL事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">事务如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">并发事务会出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.5.</span> <span class="toc-text">MySQL的默认隔离级别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">生产环境数据库使用哪种隔离级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">MySQL中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">锁的分类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/04/SpringBoot3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="SpringBoot3响应式编程详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot3响应式编程详解"/></a><div class="content"><a class="title" href="/2024/01/04/SpringBoot3%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/" title="SpringBoot3响应式编程详解">SpringBoot3响应式编程详解</a><time datetime="2024-01-04T03:02:09.000Z" title="发表于 2024-01-04 11:02:09">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/03/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E5%AE%9E%E8%B7%B5%E7%AF%87/" title="接口限流实践篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/20.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="接口限流实践篇"/></a><div class="content"><a class="title" href="/2024/01/03/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E5%AE%9E%E8%B7%B5%E7%AF%87/" title="接口限流实践篇">接口限流实践篇</a><time datetime="2024-01-03T12:27:06.000Z" title="发表于 2024-01-03 20:27:06">2024-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/03/SpringCloud%E4%BD%BF%E7%94%A8%E7%AF%87/" title="SpringCloud使用篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud使用篇"/></a><div class="content"><a class="title" href="/2024/01/03/SpringCloud%E4%BD%BF%E7%94%A8%E7%AF%87/" title="SpringCloud使用篇">SpringCloud使用篇</a><time datetime="2024-01-03T08:40:38.000Z" title="发表于 2024-01-03 16:40:38">2024-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F%E7%AF%87/" title="计算机网络面经篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/20.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络面经篇"/></a><div class="content"><a class="title" href="/2023/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F%E7%AF%87/" title="计算机网络面经篇">计算机网络面经篇</a><time datetime="2023-12-27T13:50:57.000Z" title="发表于 2023-12-27 21:50:57">2023-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/27/Go%E9%9D%A2%E7%BB%8F%E7%AF%87/" title="Go面经篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go面经篇"/></a><div class="content"><a class="title" href="/2023/12/27/Go%E9%9D%A2%E7%BB%8F%E7%AF%87/" title="Go面经篇">Go面经篇</a><time datetime="2023-12-27T13:50:40.000Z" title="发表于 2023-12-27 21:50:40">2023-12-27</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="小奥" target="_blank">小奥</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Go面经<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Java面经<sup>1</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 0.88rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">MySQL面经<sup>1</sup></a><a href="/tags/SpringBoot3/" style="font-size: 0.88rem;">SpringBoot3<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 0.88rem;">接口限流<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">计算机网络面经<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8956954060&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小奥 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>