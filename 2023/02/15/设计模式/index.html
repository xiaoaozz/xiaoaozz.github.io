<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>设计模式 | 小奥</title><meta name="keywords" content="设计模式"><meta name="author" content="小奥,3189137314@qq.com"><meta name="copyright" content="小奥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="设计模式"><meta name="application-name" content="设计模式"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="设计模式"><meta property="og:url" content="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><meta property="og:site_name" content="小奥"><meta property="og:description" content="目录第一章 设计模式概述软件设计模式(Software Design Pattern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。  设计模式分类  （1）创建型模式 用于描述“怎样创建对"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/png/12.png"><meta property="article:author" content="小奥"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/png/12.png"><meta name="description" content="目录第一章 设计模式概述软件设计模式(Software Design Pattern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。  设计模式分类  （1）创建型模式 用于描述“怎样创建对"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 编程知识爱好者","🔍 分享与热心帮助","🏠 面试总结小能手","🔨 设计开发一条龙","🤝 源码阅读与解析","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小奥","link":"链接: ","source":"来源: 小奥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小奥',
  title: '设计模式',
  postAI: '',
  pageFillDescription: '目录, 第一章 设计模式概述, 第二章 UML图, 2.1 类图概述, 2.2 类图的作用, 2.3 类图表示法, (1)类的表示方式, (2)类与类之间关系的表示方式, 关联关系, ① 单向关联, ② 双向关联, ③ 自关联, 聚合关系, 组合关系, 依赖关系, 继承关系, 实现关系, 第三章 软件设计原则, 3.1开闭原则, 3.2里氏代换原则, 3.3依赖倒转原则, 3.4 接口隔离原则, 3.5 迪米特法则, 3.6 合成复用法则, 第四章 创建者模式, 4.1 单例设计模式, (1)创建方式, ①饿汉式, ②懒汉式, ③双重检查, ④静态内部类, ⑤枚举(恶汉式), (2)存在的问题, ① 序列化破坏单例模式, ②反射破坏单例模式, (3)问题的解决, ① 序列化、反序列化方式破坏单例模式的解决, ② 反射破坏单例模式的解决, (4)(单例应用)Runtime类, 4.2 工厂模式, (1)概述, (2)简单工厂模式, ①结构, ② 实现, ③ 扩展, ④优缺点, (3)工厂方法模式, ①结构, ②实现, ③优缺点, (3)抽象工厂模式, ①概念, ②结构, ③实现, ③优缺点, (5)模式扩展, ① 简单工厂+配置文件解除耦合, (6)(工厂应用)Collection.iterator方法, 4.3 原型模式, (1)概述, (2)结构, (3)实现, (4)案例, (5)使用场景, (6)扩展(深克隆), 4.4 建造者模式, (1)概述, (2)结构, (3)实例, (4)优缺点, (5)使用场景, (6) 模式扩展, (7)建造者模式对比, ① 工厂方法模式VS建造者模式, ②抽象工厂模式VS建造者模式, 第五章 结构型模式, 5.1 代理模式, (1)概述, (2)结构, (3)静态代理, (4)动态代理, (5)CGLIB动态代理, (6)三种代理的对比, (7)优缺点, (8)使用场景, 5.2 适配器模式, (1)概述, (2) 结构, (3)类适配器模式, (4)对象适配器模式, (5) 应用场景, 5.3 装饰者模式, (1)概述, (2)结构, (3)案例, (4)优缺点, (5)使用场景, (6)实例, (7)代理和装饰的区别, 5.4 桥接模式, (1)概述, (2)结构, (3)案例, (4)使用场景, 5.5 外观模式, (1)概述, (2) 结构, (3)案例, (4)使用场景, 5.6 组合模式, (1)概述, (2)结构, (3)案例, (4)分类, (5)优点, (6)应用场景, 5.7 享元模式, (1)概述, (2)结构, (3)案例, (4)优缺点, 第六章 行为型模式, 6.1 模板方法模式, (1)概述, (2)结构, (3) 案例, (4)优缺点, (5)适用场景, 6.2 策略模式, (1)结构, (2)案例, (3)优缺点, (4)适用场景, 6.3 命令模式, (1)结构, (2)案例实现, (3) 优缺点, (4)适用场景, (5)Runnable应用, 6.4 责任链模式, (1) 结构, (2)案例实现, (3) 优缺点, 6.5 状态模式, (1)结构, (2)案例实现, (3)优缺点, (4)使用场景, 6.6 观察者模式, (1)结构, (2)案例实现, (3)优缺点, (4)使用场景, (5)JDK中提供的实现, 6.7 中介模式, (1)结构, (2)案例实现, (3)优缺点, (4)使用场景, 6.8 迭代器模式, (1)结构, (2)案例, (3)优缺点, (4)适用场景, (5)集合源码应用, 6.9 访问者模式, (1)结构, (2)案例实现, (3)优缺点, (4)使用场景, (5)扩展, ① 分派, ② 动态分派, ③ 静态分派, ④ 双分派, 6.10 备忘录模式, (1)结构, (2)案例实现, ① 白箱备忘录模式, ② 黑箱备忘录模式, (3)优缺点, (4)适用场景, 6.11 解释器模式, (1)结构, (2)案例实现, (3)优缺点, (4)适用场景目录第一章设计模式概述软件设计模式又称设计模式是一套被反复使用多数人知晓的经过分类编目的代码设计经验的总结它描述了在软件设计过程中的一些不断重复发生的问题以及该问题的解决方案设计模式分类创建型模式用于描述怎样创建对象它的主要特点是将对象的创建与使用分离分别是工厂方法抽象工厂建造者原型和单例种创建型模式结构型模式用于描述如何将类或者对象按某种布局组成更大的结构分别是适配器桥接组合装饰器外观享元代理等种结构型模式行为型模式用于描述类或者对象之间怎样相互写作共同完成单个对象无法单独完成的任务以及怎样分配职责分别是解释器模板方法职责链命令迭代器中介者备忘录观察者状体策略访问者等种行为型模式第二章图统一建模语言是用来设计软件的可视化建模语言它的特点是简单统一图形化能表达软件设计中的动态与静态信息从目标系统的不同角度出发定义了用例图类图对象图状态图活动图时序图协作图构件图部署图等种图类图概述类图是显示了模型的静态结构特别是模型中存在的类类的内部结构以及它们与其他类的关系等类图不显示暂时性的信息类图是面向对象建模的主要组成部分类图的作用在软件工程中类图是一种静态的结构图描述了系统的类的集合类的属性和类之间的关系可以简化了人们对系统的理解类图是系统分析和设计阶段的重要产物是系统编码和测试的重要模型类图表示法类的表示方式在类图中类使用包含类名属性和方法且带有分割线的矩形来表示比如下图中表示一个图它包含和这三个属性以及方法属性方法名称前加的加号和减号表示了这个属性方法的可见性类图中表示可见性的符号有三种表示表示表示属性的完整表示方式是可见性名称类型缺省值方法的完整表示方式是可见性名称参数列表返回类型注意中括号里面的内容是可选的类图还有其他的表示方式类与类之间关系的表示方式关联关系关联关系是对象之间的一种引用关系用于表示一类对象与另一类对象之间的联系如老师和学生师傅和徒弟丈夫和妻子等关联关系是类与类之间最常用的一种关系分为一般关联关系聚合关系和组合关系我们先介绍一般关联关联又可以分为单向关联双向关联自关联单向关联在类图中单向关联用一个带箭头的实线表示上图表示每个顾客都有一个地址这通过让类持有一个类型为的成员变量类实现双向关联从上图中我们很容易看出所谓的双向关联就是双方各自持有对方类型的成员变量在类图中双向关联用一个不带箭头的直线表示上图中在类中维护一个表示一个顾客可以购买多个商品在类中维护一个类型的成员变量表示这个产品被哪个顾客所购买自关联自关联在类图中用一个带有箭头且指向自身的线表示上图的意思就是类包含类型为的成员变量也就是自己包含自己聚合关系聚合关系是关联关系的一种是强关联关系是整体和部分之间的关系聚合关系也是通过成员对象来实现的其中成员对象是整体对象的一部分但是成员对象可以脱离整体对象而独立存在例如学校与老师的关系学校包含老师但如果学校停办了老师依然存在在类图中聚合关系可以用带空心菱形的实线来表示菱形指向整体下图所示是大学和教师的关系图组合关系组合表示类之间的整体与部分的关系但它是一种更强烈的聚合关系在组合关系中整体对象可以控制部分对象的生命周期一旦整体对象不存在部分对象也将不存在部分对象不能脱离整体对象而存在例如头和嘴的关系没有了头嘴也就不存在了在类图中组合关系用带实心菱形的实线来表示菱形指向整体下图所示是头和嘴的关系图依赖关系依赖关系是一种使用关系它是对象之间耦合度最弱的一种关联方式是临时性的关联在代码中某个类的方法通过局部变量方法的参数或者对静态方法的调用来访问另一个类被依赖类中的某些方法来完成一些职责在类图中依赖关系使用带箭头的虚线来表示箭头从使用类指向被依赖的类下图所示是司机和汽车的关系图司机驾驶汽车继承关系继承关系是对象之间耦合度最大的一种关系表示一般与特殊的关系是父类与子类之间的关系是一种继承关系在类图中泛化关系用带空心三角箭头的实线来表示箭头从子类指向父类在代码实现时使用面向对象的继承机制来实现泛化关系例如类和类都是类的子类其类图如下图所示实现关系实现关系是接口与实现类之间的关系在这种关系中类实现了接口类中的操作实现了接口中所声明的所有的抽象操作在类图中实现关系使用带空心三角箭头的虚线来表示箭头从实现类指向接口例如汽车和船实现了交通工具其类图如图所示第三章软件设计原则在软件开发中为了提高软件系统的可维护性和可复用性增加软件的可扩展性和灵活性程序员要尽量根据条原则来开发程序从而提高软件开发效率节约软件开发成本和维护成本开闭原则对扩展开放对修改关闭在程序需要进行拓展的时候不能去修改原有的代码而是实现一个热插拔的效果可以让程序的扩展性更好易于维护和升级要想实现开闭原则我们需要使用接口抽象类因为抽象类的灵活性好适应性广只要抽象的合理可以基本保持软件架构的稳定而软件中易变的细节可以从抽象类派生出来实现类进行扩展当软件需要发生变化时只需要根据需求重新派生一个实现类来扩展就可以了下面以搜狗输入法的皮肤为例介绍开闭原则的应用例搜狗输入法的皮肤设计分析搜狗输入法的皮肤是输入法背景图片窗口颜色和声音等元素的组合用户可以根据自己的喜爱更换自己的输入法的皮肤也可以从网上下载新的皮肤这些皮肤有共同的特点可以为其定义一个抽象类而每个具体的皮肤和是其子类用户窗体可以根据需要选择或者增加新的主题而不需要修改原代码所以它是满足开闭原则的里氏代换原则里氏代换原则是面向对象设计的基本原则之一里氏代换原则任何基类可以出现的地方子类一定可以出现通俗理解子类可以扩展父类的功能但不能改变父类原有的功能换句话说子类继承父类时除添加新的方法完成新增功能外尽量不要重写父类的方法如果通过重写父类的方法来完成新的功能这样写起来虽然简单但是整个继承体系的可复用性会比较差特别是运用多态比较频繁时程序运行出错的概率会非常大下面看一个里氏替换原则中经典的一个例子例正方形不是长方形在数学领域里正方形毫无疑问是长方形它是一个长宽相等的长方形所以我们开发的一个与几何图形相关的软件系统就可以顺理成章的让正方形继承自长方形代码如下长方形类正方形由于正方形的长和宽相同所以在方法和中对长度和宽度都需要赋相同值类是我们的软件系统中的一个组件它有一个方法依赖基类方法是类中的一个方法用来实现宽度逐渐增长的效果实现宽度逐渐增长的效果打印长方形的长和宽我们运行一下这段代码就会发现假如我们把一个普通长方形作为参数传入方法就会看到长方形宽度逐渐增长的效果当宽度大于长度代码就会停止这种行为的结果符合我们的预期假如我们再把一个正方形作为参数传入方法后就会看到正方形的宽度和长度都在不断增长代码会一直运行下去直至系统产生溢出错误所以普通的长方形是适合这段代码的正方形不适合我们得出结论在方法中类型的参数是不能被类型的参数所代替如果进行了替换就得不到预期结果因此类和类之间的继承关系违反了里氏代换原则它们之间的继承关系不成立正方形不是长方形如何改进呢此时我们需要重新设计他们之间的关系抽象出来一个四边形接口让类和类实现接口依赖倒转原则高层模块不应该依赖低层模块两者都应该依赖其抽象抽象不应该依赖细节细节应该依赖抽象简单的说就是要求对抽象进行编程不要对实现进行编程这样就降低了客户与实现模块间的耦合下面看一个例子来理解依赖倒转原则例组装电脑现要组装一台电脑需要配件硬盘内存条只有这些配置都有了计算机才能正常的运行选择有很多选择如等硬盘可以选择希捷西数等内存条可以选择金士顿海盗船等类图如下代码如下希捷硬盘类使用希捷硬盘存储数据使用希捷希捷硬盘取数据数据处理器使用处理器金士顿内存条使用金士顿作为内存条电脑计算机工作从硬盘中获取的数据为测试类测试类用来组装电脑上面代码可以看到已经组装了一台电脑但是似乎组装的电脑的只能是的内存条只能是金士顿的硬盘只能是希捷的这对用户肯定是不友好的用户有了机箱肯定是想按照自己的喜好选择自己喜欢的配件根据依赖倒转原则进行改进代码我们只需要修改类让类依赖抽象各个配件的接口而不是依赖于各个组件具体的实现类类图如下电脑计算机工作注意之前的具体的类要实现这些接口如类图中所示面向对象的开发很好的解决了这个问题一般情况下抽象的变化概率很小让用户程序依赖于抽象实现的细节也依赖于抽象即使实现细节不断变动只要抽象不变客户程序就不需要变化这大大降低了客户程序与实现细节的耦合度接口隔离原则客户端不应该被迫依赖于它不使用的方法一个类对另一个类的依赖应该建立在最小的接口上下面看一个例子来理解接口隔离原则例安全门案例我们需要创建一个黑马品牌的安全门该安全门具有防火防水防盗的功能可以将防火防水防盗功能提取成一个接口形成一套规范类图如下上面的设计我们发现了它存在的问题黑马品牌的安全门具有防盗防水防火的功能现在如果我们还需要再创建一个传智品牌的安全门而该安全门只具有防盗防水功能呢很显然如果实现接口就违背了接口隔离原则那么我们如何进行修改呢看如下类图代码如下防盗接口防火接口防水接口类防盗防火防水类防盗防火迪米特法则迪米特法则又叫最少知识原则只和你的直接朋友交谈不跟陌生人说话其含义是如果两个软件实体无须直接通信那么就不应当发生直接的相互调用可以通过第三方转发该调用其目的是降低类之间的耦合度提高模块的相对独立性迪米特法则中的朋友是指当前对象本身当前对象的成员对象当前对象所创建的对象当前对象的方法参数等这些对象同当前对象存在关联聚合或组合关系可以直接访问这些对象的方法下面看一个例子来理解迪米特法则例明星与经纪人的关系实例明星由于全身心投入艺术所以许多日常事务由经纪人负责处理如和粉丝的见面会和媒体公司的业务洽淡等这里的经纪人是明星的朋友而粉丝和媒体公司是陌生人所以适合使用迪米特法则类图如下代码如下明星类粉丝类媒体公司类经纪人类与明星见面了与明星洽淡业务合成复用法则合成复用原则是指尽量先使用组合或者聚合等关联关系来实现其次才考虑使用继承关系来实现通常类的复用分为继承复用和合成复用两种继承复用虽然有简单和易实现的优点但它也存在以下缺点继承复用破坏了类的封装性因为继承会将父类的实现细节暴露给子类父类对子类是透明的所以这种复用又称为白箱复用子类与父类的耦合度高父类的实现的任何改变都会导致子类的实现发生变化这不利于类的扩展与维护它限制了复用的灵活性从父类继承而来的实现是静态的在编译时已经定义所以在运行时不可能发生变化采用组合或聚合复用时可以将已有对象纳入新对象中使之成为新对象的一部分新对象可以调用已有对象的功能它有以下优点它维持了类的封装性因为成分对象的内部细节是新对象看不见的所以这种复用又称为黑箱复用对象间的耦合度低可以在类的成员位置声明抽象复用的灵活性高这种复用可以在运行时动态进行新对象可以动态地引用与成分对象类型相同的对象下面看一个例子来理解合成复用原则例汽车分类管理程序汽车按动力源划分可分为汽油汽车电动汽车等按颜色划分可分为白色汽车黑色汽车和红色汽车等如果同时考虑这两种分类其组合就很多类图如下从上面类图我们可以看到使用继承复用产生了很多子类如果现在又有新的动力源或者新的颜色的话就需要再定义新的类我们试着将继承复用改为聚合复用看一下第四章创建者模式创建型模式的主要关注点是怎样创建对象它的主要特点是将对象的创建与使用分离这样可以降低系统的耦合度使用者不需要关注对象的创建细节创建者模式分为单例模式工厂方法模式抽象工程模式原型模式建造者模式单例设计模式单例模式如果一个类只允许创建一个对象或者实例那么这个类就是一个单例类这张设计模式就叫做单例模式这种类型的设计模式属于创建型模式它提供了一种创建对象的最佳方式这种模式涉及到一个单一的类该类负责创建自己的对象同时确保只有单个对象被创建这个类提供了一种访问其唯一的对象的方式可以直接访问不需要实例化该类的对象为什么要使用单例模式处理资源访问冲突比如我们自定义的日志打印类如果不同的方法调用返回不同的实例那么可能最后我们输出的日志就会产生盖覆盖或者乱序的现象表示全局唯一类比如配置信息在全局中只能存在一个单例模式的实现单例设计模式分为两种饿汉式类加载就会导致该单实例对象被创建懒汉式类加载不会导致该单实例对象被创建而是首次使用该对象的时候才会创建创建方式饿汉式静态常量在成员位置创建该类的对象私有构造方法对外提供静态方法获取该对象优点写法比较简单在类加载的时候就完成了实例化避免了线程同步问题缺点在类加载的时候就完成实例化没有达到懒加载的效果如果不使用这个实例就会造成内存的浪费静态代码块该方式的对象的创建是在静态代码块中也是随着类的加载而创建所以和静态常量的方式基本一致懒汉式线程不安全优点这种方式实现了懒加载当调用方法获取类的对象的时候才会创建类的对象缺点只能在单线程环境下使用如果是多线程环境便会出现线程不安全问题线程安全同步方法优点实现了懒加载保证线程安全缺点执行效率比较低线程安全同步代码块双重检查双重检查锁模式是一种非常好的单例实现模式解决了单例性能线程安全问题上面的双重检测锁模式看上去完美无缺其实是存在问题在多线程的情况下可能会出现空指针问题出现问题的原因是在实例化对象的时候会进行优化和指令重排序操作要解决双重检查锁模式带来空指针异常的问题只需要使用关键字关键字可以保证可见性和有序性添加关键字之后的双重检查锁模式是一种比较好的单例实现模式能够保证在多线程的情况下线程安全也不会有性能问题静态内部类这种方式跟饿汉式方式采用的机制类似但又有不同两者都是采用了类装载的机制来保证初始化实例时只有一个线程不同的地方在饿汉式方式是只要类被装载就会实例化没有的作用而静态内部类方式在类被装载时并不会立即实例化而是在需要实例化时调用方法才会装载类从而完成的实例化枚举恶汉式借助提供的枚举类来实现单例模式不仅能避免多线程同步问题而且还能防止反序列化重新创建新的对象单例模式的优缺点优点保证系统内该类只存在一个对象实例节省了系统的资源缺点要想实例化一个单例对象必须使用相应的获取对象的方法不能使用存在的问题序列化破坏单例模式使上面定义的单例类可以创建多个对象枚举方式除外有两种方式分别是序列化和反射序列化和反序列化静态内部类方式类往文件中写入对象从文件中读取对象创建对象输入流对象第一个读取对象获取类的对象创建对象输出流将对象写出到文件中上面程序的运行结果是说明序列化和反序列化已经破坏了单例设计模式反射破坏单例模式类获取类的字节码对象获取类的私有无参构造方法对象取消访问检查上面代码的运行结果是表明序列化和反序列化已经破坏了单例设计模式问题的解决序列化反序列化方式破坏单例模式的解决在类中添加方法在反序列化时被反射调用如果定义了这个方法就返回这个方法的值如果没有定义则返回新出来的对象定义了这个方法就返回这个方法的值原理我们可以查看类的源码我们再查看方法再点入查看返回执行通过反射创建新的单例类通过反射调用类中的方法将返回值赋值给变量这样多次调用类中的方法继而就会调用我们定义的方法所以返回的是同一个对象反射破坏单例模式的解决饿汉式在成员位置创建该类的对象懒汉式单例模式不能被反射破坏私有构造方法对外提供静态方法获取该对象当通过反射方式调用构造方法进行创建创建时直接抛异常不运行此中操作懒汉式懒汉式单例无法阻止反射破坏我们仍然执行刚才的测试方法发现仍能得到结果并没有抛出异常原因是我们通过反射创建实例和静态调用方法获得实例的位置互换了所以一开始通过反射创建实例调用构造器此时构造器中的判断是无用的所以这种方式不适用懒汉式单例模式来防止被反射破坏的单例应用类私有化构造函数提供一个公开的方法并且接受对象的私有化私有化构造函数从上面源代码中可以看出类使用的是恶汉式静态属性方式来实现单例模式的工厂模式概述中万物皆对象这些对象都需要创建如果创建的时候直接该对象就会对该对象耦合严重假如我们要更换对象所有对象的地方都需要修改一遍这显然违背了软件设计的开闭原则如果我们使用工厂来生产对象我们就只和工厂打交道就可以了彻底和对象解耦如果要更换对象直接在工厂里更换该对象即可达到了与对象解耦的目的设计模式之工厂模式种详解及代码示例博客园在工厂模式中创建对象时不会对客户端暴露创建逻辑并且是通过一个共同的接口来指向新创建的对象它属于创建型模式但不属于种设计模式使用工厂方法代替操作的一种模式工厂模式有三种简单工厂模式工厂方法模式和抽象工厂方式简单工厂模式简单工厂模式不是一种设计模式反而比较像是一种编程习惯由一个工厂对象决定创建出哪一种产品类的实例简单工厂的实质是由一个工厂类根据传入的类型动态决定应该创建哪一个产品类适用场景工厂类负责创建的对象比较少客户端应用层只需要知道传入工厂类的参数对于如何创建对象并不关心结构抽象产品定义了产品的规范描述了产品的主要特征和功能具体产品实现或者继承抽象产品的子类具体工厂提供了创建产品的方法调用者通过该方法获取产品实现适用场景调用者只需要知道传入产品的参数对于创建对象的逻辑并不关心例咖啡店点餐系统需求设计一个咖啡类并定义其两个子类美式咖啡和拿铁咖啡再设计一个咖啡店类咖啡店具有点咖啡的功能使用简单工厂模式对该需求进行改进类图如下工厂类代码如下工厂处理创建对象的细节一旦有了类中的就变成此对象的客户后期如果需要对象直接从工厂中获取即可这样也就解除了和实现类的耦合同时又产生了新的耦合对象和工厂对象的耦合工厂对象和商品对象的耦合后期如果再加新品种的咖啡我们势必要需求修改的代码违反了开闭原则工厂类的客户端可能有很多比如创建美团外卖等这样只需要修改工厂类的代码省去其他的修改操作扩展在开发中我们还可以将工厂类中的创建对象的功能定义为静态的这个就是静态工厂模式它也不是种设计模式中的优缺点优点封装了创建对象的过程通过参数直接获取对象实现了对象创建和业务逻辑的分离如果要实现新产品直接修改工厂类扩展性更强缺点工厂类不够灵活增加新产品还要修改工厂类代码违背了开闭原则工厂方法模式工厂方法模式完美的解决了简单工厂模式的缺点完全遵守开闭原则定义一个用于创建对象的接口让子类决定实例化哪个产品类对象工厂方法使一个产品类的实例化延迟到其工厂的子类适用场景客户只知道创建产品的工厂名而不知道具体的产品名创建对象的任务由多个具体子工厂中的某一个完成而抽象工厂只提供创建产品的接口客户不关心创建产品的细节只关心产品的品牌结构抽象工厂提供了创建产品的接口调用者通过它访问具体工厂的工厂方法来创建产品具体工厂主要是实现抽象工厂中的抽象方法完成具体产品的创建抽象产品定义了产品的规范描述了产品的主要特性和功能具体产品实现了抽象产品角色所定义的接口由具体工厂来创建它同具体工厂之间一一对应实现使用工厂方法对简单工厂进行改进类图如下代码如下抽象工厂具体工厂咖啡店类从以上的编写的代码可以看到要增加产品类时也要相应地增加工厂类不需要修改工厂类的代码了这样就解决了简单工厂模式的缺点工厂方法模式是简单工厂模式的进一步抽象由于使用了多态性工厂方法模式保持了简单工厂模式的优点而且克服了它的缺点优缺点优点用户只需要关系所需产品对应的工厂无须关心创建细节加入新产品符合开闭原则提高扩展性缺点增加产品类的时候也要增加相应的工厂类增加了系统的复杂性抽象工厂模式前面介绍的工厂方法模式中考虑的是一类产品的生产如畜牧场只养动物电视机厂只生产电视机传智播客只培养计算机软件专业的学生等这些工厂只生产同种类产品同种类产品称为同等级产品也就是说工厂方法模式只考虑生产同等级的产品但是在现实生活中许多工厂是综合型的工厂能生产多等级种类的产品如电器厂既生产电视机又生产洗衣机或空调大学既有软件专业又有生物专业等抽象工厂模式将考虑多等级产品的生产将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族下图所示横轴是产品等级也就是同一类产品纵轴是产品族也就是同一品牌的产品同一品牌的产品产自同一个工厂概念是一种为访问类提供一个创建一组相关或相互依赖对象的接口且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构抽象工厂模式是工厂方法模式的升级版本工厂方法模式只生产一个等级的产品而抽象工厂模式可生产多个等级的产品使用条件系统中有多个产品族每个具体工厂创建同一族但属于不同等级结构的产品系统一次只可能消费其中某一族产品即同族的产品一起适用适用场景当需要创建的对象是一系列相互关联或相互依赖的产品族时如电器工厂中的电视机洗衣机空调等系统中有多个产品族但每次只使用其中的某一族产品如有人只喜欢穿某一个品牌的衣服和鞋系统中提供了产品的类库且所有产品的接口相同客户端不依赖产品实例的创建细节和内部结构结构抽象工厂提供了创建产品的接口它包含多个创建产品的方法可以创建多个不同等级的产品具体工厂主要是实现抽象工厂中的多个抽象方法完成具体产品的创建抽象产品定义了产品的规范描述了产品的主要特性和功能抽象工厂模式有多个抽象产品具体产品实现了抽象产品角色所定义的接口由具体工厂来创建它同具体工厂之间是多对一的关系实现例咖啡店业务改变现咖啡店业务发生改变不仅要生产咖啡还要生产甜点如提拉米苏抹茶慕斯等要是按照工厂方法模式需要定义提拉米苏类抹茶慕斯类提拉米苏工厂抹茶慕斯工厂甜点工厂类很容易发生类爆炸情况其中拿铁咖啡美式咖啡是一个产品等级都是咖啡提拉米苏抹茶慕斯也是一个产品等级拿铁咖啡和提拉米苏是同一产品族也就是都属于意大利风味美式咖啡和抹茶慕斯是同一产品族也就是都属于美式风味所以这个案例可以使用抽象工厂模式实现类图如下抽象工厂具体工厂美式甜点工厂意大利风味甜点如果要加同一个产品族的话只需要再加一个对应的工厂类即可不需要修改其他的类优缺点优点当一个产品族中的多个对象被设计成一起工作时他能保证客户端始终只使用同一个产品族中的对象缺点当产品族需要增加一个新的产品时所有的工厂类都需要被修改模式扩展简单工厂配置文件解除耦合可以通过工厂模式配置文件的方式解除工厂对象和产品对象的耦合在工厂类中加载配置文件中的全类名并创建对象进行存储客户端如果需要对象直接进行获取即可第一步定义配置文件为了演示方便我们使用配置文件名称为第二步改进工厂类遍历集合对象根据键获取值全类名获取字节码对象静态成员变量用来存储创建的对象键存储的是名称值存储的是对应的对象而读取配置文件以及创建对象写在静态代码块中目的就是只需要执行一次工厂应用方法令狐冲风清扬任我行获取迭代器对象使用迭代器遍历使用迭代器遍历集合获取集合中的元素而单列集合获取迭代器的方法就使用到了工厂方法模式我们看通过类图看看结构接口是抽象工厂类是具体的工厂类接口是抽象商品类的内部类是具体的商品类在具体的工厂类中方法创建具体的商品类的对象另外类中的方法使用的是工厂模式类中的方法使用的是工厂模式原型模式概述用一个已经创建的实例作为原型通过复制该原型对象来创建一个和原型对象相同的新对象结构原型模式包含如下角色抽象原型类规定了具体原型对象必须实现的的方法具体原型类实现抽象原型类的方法它是可被复制的对象访问类使用具体原型类中的方法来复制新的对象接口类图如下实现原型模式的克隆分为浅克隆和深克隆浅克隆创建一个新对象新对象的属性和原来对象完全相同对于非基本类型属性仍指向原有属性所指向的对象的内存地址深克隆创建一个新对象属性中引用的其他对象也会被克隆不再指向原有对象地址中的类中提供了方法来实现浅克隆接口是上面的类图中的抽象原型类而实现了接口的子实现类就是具体的原型类代码如下具体原型类具体的原型对象创建完毕具体原型复制成功测试访问类原型对象和克隆对象是一个对象具体的原型对象创建完毕具体原型复制成功原型对象和克隆对象是一个对象案例例用原型模式生成三好学生奖状同一学校的三好学生奖状除了获奖人姓名不同其他都相同可以使用原型模式复制多个三好学生奖状出来然后在修改奖状上的名字即可类图如下代码如下奖状类同学在学年第一学期中表现优秀被评为三好学生特发此状测试类张三李四张三同学在学年第一学期中表现优秀被评为三好学生特发此状李四同学在学年第一学期中表现优秀被评为三好学生特发此状使用场景对象的创建非常复杂可以使用原型模式快速创建对象性能和安全要求比较高扩展深克隆将上面三好学生奖状案例中的类的属性改为类的属性代码如下奖状类同学在学年第一学期中表现优秀被评为三好学生特发此状测试类张三河南李四判断对象和对象是否是同一个对象和是同一个对象和是同一个对象李四同学在学年第一学期中表现优秀被评为三好学生特发此状李四同学在学年第一学期中表现优秀被评为三好学生特发此状对象和对象是同一个对象就会产生将对象中属性值改为李四两个奖状对象中显示的都是李四这就是浅克隆的效果对具体原型类中的引用类型的属性进行引用的复制这种情况需要使用深克隆而进行深克隆需要使用对象流代码如下测试类张三河南创建对象输出流对象将对象写出到文件中创建对象出入流对象李四判断对象和对象是否是同一个对象和是同一个对象和是同一个对象张三同学在学年第一学期中表现优秀被评为三好学生特发此状李四同学在学年第一学期中表现优秀被评为三好学生特发此状注意类和类必须实现接口否则会抛异常建造者模式概述将一个复杂对象的构建与表示分离使得同样的构建过程可以创建不同的表示分离了部件的构造由来负责和装配由负责从而可以构造出复杂的对象这个模式适用于某个对象的构建过程复杂的情况由于实现了构建和装配的解耦不同的构建器相同的装配也可以做出不同的对象相同的构建器不同的装配顺序也可以做出不同的对象也就是实现了构建算法装配算法的解耦实现了更好的复用建造者模式可以将部件和其组装过程分开一步一步创建一个复杂的对象用户只需要指定复杂对象的类型就可以得到该对象而无须知道其内部的具体构造细节结构建造者模式包含如下角色抽象建造者类这个接口规定要实现复杂对象的那些部分的创建并不涉及具体的部件对象的创建具体建造者类实现接口完成复杂产品的各个部件的具体创建方法在构造过程完成后提供产品的实例产品类要创建的复杂对象指挥者类调用具体建造者来创建复杂对象的各个部分在指导者中不涉及具体产品的信息只负责保证对象各部分完整创建或按某种顺序创建类图如下实例例创建共享单车生产自行车是一个复杂的过程它包含了车架车座等组件的生产而车架又有碳纤维铝合金等材质的车座有橡胶真皮等材质对于自行车的生产就可以使用建造者模式这里是产品包含车架车座等组件是抽象建造者和是具体的建造者是指挥者类图如下具体代码如下自行车类抽象建造者类具体建造者类铝合金车架真皮车座碳纤维车架橡胶车座指挥者类测试类上面示例是模式的常规用法指挥者类在建造者模式中具有很重要的作用它用于指导具体构建者如何构建产品控制调用先后次序并向调用者返回完整的产品类但是有些情况下需要简化系统结构可以把指挥者类和抽象建造者进行结合抽象类这样做确实简化了系统结构但同时也加重了抽象建造者类的职责也不是太符合单一职责原则如果过于复杂建议还是封装到中优缺点优点建造者模式的封装性很好使用建造者模式可以有效的封装变化在使用建造者模式的场景中一般产品类和建造者类是比较稳定的因此将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性在建造者模式中客户端不必知道产品内部组成的细节将产品本身与产品的创建过程解耦使得相同的创建过程可以创建不同的产品对象可以更加精细地控制产品的创建过程将复杂产品的创建步骤分解在不同的方法中使得创建过程更加清晰也更方便使用程序来控制创建过程建造者模式很容易进行扩展如果有新的需求通过实现一个新的建造者类就可以完成基本上不用修改之前已经测试通过的代码因此也就不会对原有功能引入风险符合开闭原则缺点造者模式所创建的产品一般具有较多的共同点其组成部分相似如果产品之间的差异性很大则不适合使用建造者模式因此其使用范围受到一定的限制使用场景建造者模式创建的是复杂对象其产品的各个部分经常面临着剧烈的变化但将它们组合在一起的算法却相对稳定所以它通常在以下场合使用创建的对象较复杂由多个部件构成各部件面临着复杂的变化但构件间的建造顺序是稳定的创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式即产品的构建过程和最终的表示是独立的模式扩展建造者模式除了上面的用途外在开发中还有一个常用的使用方式就是当一个类构造器需要传入很多参数时如果创建这个类的实例代码可读性会非常差而且很容易引入错误此时就可以利用建造者模式进行重构重构前代码如下三星屏幕金士顿华硕上面在客户端代码中构建对象传递了四个参数如果参数更多呢代码的可读性及使用的成本就是比较高重构后代码方法华硕金士顿三星重构后的代码在使用起来更方便某种程度上也可以提高开发效率从软件设计上对程序员的要求比较高建造者模式对比工厂方法模式建造者模式工厂方法模式注重的是整体对象的创建方式而建造者模式注重的是部件构建的过程意在通过一步一步地精确构造创建出一个复杂的对象举一个简单的例子来说如果要制造一辆汽车如果使用工厂方法模式则直接生产出来的是一辆汽车如果使用建造者模式则需要组装发动机轮胎车框等部分最后再显示汽车抽象工厂模式建造者模式抽象工厂模式实现对产品家族的创建一个产品家族是这样的一系列产品具有不同分类维度的产品组合采用抽象工厂模式则是不需要关心构建过程只关心什么产品由什么工厂生产即可建造者模式则是要求按照指定的步骤建造产品它的主要目的是通过组装零配件而产生一个新产品如果将抽象工厂模式看成汽车配件生产工厂生产一个产品族的产品那么建造者模式就是一个汽车组装工厂通过对部件的组装可以返回一辆完整的汽车第五章结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构它分为类结构型模式和对象结构型模式前者采用继承机制来组织接口和类后者釆用组合或聚合来组合对象由于组合关系或聚合关系比继承关系耦合度低满足合成复用原则所以对象结构型模式比类结构型模式具有更大的灵活性结构型模式分为以下七种代理模式适配器模式装饰者模式桥接模式外观模式组合模式享元模式代理模式概述由于某些原因需要给某对象提供一个代理以控制对该对象的访问这时访问对象不适合或者不能直接引用目标对象代理对象作为访问对象和目标对象之间的中介中的代理按照代理类生成时机不同又分为静态代理和动态代理静态代理代理类在编译期就生成而动态代理代理类则是在运行时动态生成动态代理又有代理和代理两种结构代理模式分为三种角色抽象主题类通过接口或抽象类声明真实主题和代理对象实现的业务方法真实主题类实现了抽象主题中的具体业务是代理对象所代表的真实对象是最终要引用的对象代理类提供了与真实主题相同的接口其内部含有对真实主题的引用它可以访问控制或扩展真实主题的功能静态代理例火车站卖票如果要买火车票的话需要去火车站买票坐车到火车站排队等一系列的操作显然比较麻烦而火车站在多个地方都有代售点我们去代售点买票就方便很多了这个例子其实就是典型的代理模式火车站是目标对象代售点是代理对象类图如下卖票接口卖票接口火车站火车站卖票代售点代理点收取一些服务费用测试类从上面代码中可以看出测试类直接访问的是类对象也就是说作为访问对象和目标对象的中介同时也对方法进行了增强代理点收取一些服务费用动态代理接下来我们使用动态代理实现上面案例先说说提供的动态代理中提供了一个动态代理类并不是我们上述所说的代理对象的类而是提供了一个创建代理对象的静态方法方法来获取代理对象卖票接口火车站火车站卖票代理工厂声明目标对象使用获取代理对象类加载器用于加载代理类通过目标对象获取类加载器代理类实现的接口的字节码对象代理对象的调用处理程序方法的参数说明代理对象对接口中的方法进行封装的对象代理对象调用接口方法时传递的实际参数代理点收取一些服务费用动态代理测试类思考是代理类吗不是代理模式中所说的代理类它是一个代理工厂工厂中提供的一个方法用于获取代理对象而代理类是在程序运行过程中的动态的在内存中生成的类可以通过上述测试类中的获取动态代理类的全限定类名我们通过工具查看代理类的结构该代码剔除了的代理代码这里的就是我们通过创建代理对象传入的实现类对象省略方法省略这里调用的其实就是我们之前自定义的方法省略代理类实现了接口也就是说使用动态代理时真实类和代理类实现同样的接口代理类将我们提供的匿名内部类对象传递给了父类动态代理的执行流程在测试类中通过代理对象调用方法根据多态的特性执行的是代理类中的方法代理类中的方法中又调用了接口的自实现类对象的方法方法通过反射执行了真实对象所属类中的方法动态代理同样是上面的案例我们再次使用代理实现如果没有定义接口只定义了火车站类很显然代理是无法使用了因为动态代理要求必须定义接口对接口进行代理是一个功能强大高性能的代码生成包它为没有实现接口的类提供代理为的动态代理提供了很好的补充是第三方提供的包所以需要引入包的坐标火车站火车站卖票代理工厂类真实的代理对象创建对象类似于动态代理的类设置父类的字节码对象设置回调函数创建代理对象代理对象真实对象中的方法的实例实际参数代理对象中的方法的实例代理点收取服务费用动态代理方式三种代理的对比代理和代理使用实现动态代理底层采用字节码生成框架使用字节码技术生成代理类在之前比使用反射效率要高唯一需要注意的是不能对声明为的类或者方法进行代理因为原理是动态生成被代理类的子类在逐步对动态代理优化之后在调用次数较少的情况下代理效率高于代理效率只有当进行大量调用的时候和比代理效率低一点但是到的时候代理效率高于代理所以如果有接口使用动态代理如果没有接口使用代理动态代理和静态代理动态代理与静态代理相比较最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理这样在接口方法数量比较多的时候我们可以进行灵活处理而不需要像静态代理那样每一个方法进行中转如果接口增加一个方法静态代理模式除了所有实现类需要实现这个方法外所有代理类也需要实现此方法增加了代码维护的复杂度而动态代理不会出现该问题优缺点优点代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用代理对象可以扩展目标对象的功能代理模式能将客户端与目标对象分离在一定程度上降低了系统的耦合度缺点增加了系统的复杂度使用场景远程代理本地服务通过网络请求远程服务为了实现本地到远程的通信我们需要实现网络通信处理其中可能的异常为良好的代码设计和可维护性我们将网络通信部分隐藏起来只暴露给本地服务一个接口通过该接口即可访问远程服务提供的功能而不必过多关心通信部分的细节防火墙代理当你将浏览器配置成使用代理功能时防火墙就将你的浏览器的请求转给互联网当互联网返回响应时代理服务器再把它转给你的浏览器保护代理控制对一个对象的访问如果需要可以给不同的用户提供不同级别的使用权限适配器模式概述将一个类的接口转换成客户希望的另外一个接口使得原本由于接口不兼容而不能一起工作的那些类能一起工作适配器模式分为类适配器模式和对象适配器模式前者类之间的耦合度比后者高且要求程序员了解现有组件库中的相关组件的内部结构所以应用相对较少些结构适配器模式包含以下主要角色目标接口当前系统业务所期待的接口它可以是抽象类或接口适配者类它是被访问和适配的现存组件库中的组件接口适配器类它是一个转换器通过继承或引用适配者的对象把适配者接口转换成目标接口让客户按目标接口的格式访问适配者类适配器模式实现方式定义一个适配器类来实现当前系统的业务接口同时又继承现有组件库中已经存在的组件例读卡器现有一台电脑只能读取卡而要读取卡中的内容的话就需要使用到适配器模式创建一个读卡器将卡中的内容读取出来类图如下代码如下接口读取卡方法写入卡功能实现类电脑类接口读取卡方法写入卡功能实现类适配器类兼容测试类类适配器模式违背了合成复用原则类适配器是客户类有一个接口规范的情况下可用反之不可用对象适配器模式实现方式对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中该类同时实现当前系统的业务接口例读卡器我们使用对象适配器模式将读卡器的案例进行改写类图如下代码如下类适配器模式的代码我们只需要修改适配器类和测试类适配器类对象测试类注意还有一个适配器模式是接口适配器模式当不希望实现一个接口中所有的方法时可以创建一个抽象类实现所有方法而此时我们只需要继承该抽象类即可应用场景以前开发的系统存在满足新系统功能需求的类但其接口同新系统的接口不一致使用第三方提供的组件但组件接口定义和自己要求的接口定义不同装饰者模式概述我们先来看一个快餐店的例子快餐店有炒面炒饭这些快餐可以额外附加鸡蛋火腿培根这些配菜当然加配菜需要额外加钱每个配菜的价钱通常不太一样那么计算总价就会显得比较麻烦使用继承的方式存在的问题扩展性不好如果要再加一种配料火腿肠我们就会发现需要给和分别定义一个子类如果要新增一个快餐品类炒河粉的话就需要定义更多的子类产生过多的子类装饰者模式是指在不改变现有对象结构的情况下动态地给该对象增加一些职责即增加其额外功能的模式结构装饰模式中的角色抽象构件角色定义一个抽象接口以规范准备接收附加责任的对象具体构件角色实现抽象构件通过装饰角色为其添加一些职责抽象装饰角色继承或实现抽象构件并包含具体构件的实例可以通过其子类扩展具体构件的功能具体装饰角色实现抽象装饰的相关方法并给具体构件对象添加附加的责任案例我们使用装饰者模式对快餐店案例进行改进体会装饰者模式的精髓类图如下代码抽象类计算花费炒饭类炒饭炒面类炒面配料类配料类鸡蛋配料类培根测试类点一份炒饭元点一份加鸡蛋的炒饭元点一份加培根的炒面元炒饭元鸡蛋炒饭元培根炒面元优缺点优点装饰者模式可以带来比继承更加灵活性的扩展功能使用更加方便可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果装饰者模式比继承更具良好的扩展性完美的遵循开闭原则继承是静态的附加责任装饰者则是动态的附加责任装饰类和被装饰类可以独立发展不会相互耦合装饰模式是继承的一个替代模式装饰模式可以动态扩展一个实现类的功能使用场景当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时不能采用继承的情况主要有两类第一类是系统中存在大量独立的扩展为支持每一种组合将产生大量的子类使得子类数目呈爆炸性增长第二类是因为类定义不能继承如类在不影响其他对象的情况下以动态透明的方式给单个对象添加职责当对象的功能要求可以动态地添加也可以再动态地撤销时实例流中的包装类使用到了装饰者模式以举例来说明如下代码创建对象创建对象写数据使用装饰者模式对打的子实现类进行了增强添加了缓冲区提高了读写效率代理和装饰的区别静态代理和装饰者模式的区别相同点都要实现与目标类相同的业务接口在两个类中都要声明目标对象都可以在不修改目标类的前提下增强目标方法不同点目的不同装饰者是为了增强目标对象静态代理是为了保护和隐藏目标对象获取目标对象构建的地方不同装饰者是由外界传递进来可以通过构造方法传递静态代理是在代理类内部创建以此来隐藏目标对象桥接模式概述现在有一个需求需要创建不同的图形并且每个图形都有可能会有不同的颜色我们可以利用继承的方式来设计类的关系我们可以发现有很多的类假如我们再增加一个形状或再增加一种颜色就需要创建更多的类试想在一个有多种可能会变化的维度的系统中用继承方式会造成类爆炸扩展起来不灵活每次在一个维度上新增一个具体实现都要增加多个子类为了更加灵活的设计系统我们此时可以考虑使用桥接模式桥接模式将抽象与实现分离使它们可以独立变化它是用组合关系代替继承关系来实现从而降低了抽象和实现这两个可变维度的耦合度结构桥接模式包含以下主要角色抽象化角色定义抽象类并包含一个对实现化对象的引用扩展抽象化角色是抽象化角色的子类实现父类中的业务方法并通过组合关系调用实现化角色中的业务方法实现化角色定义实现化角色的接口供扩展抽象化角色调用具体实现化角色给出实现化角色接口的具体实现案例例视频播放器需要开发一个跨平台视频播放器可以在不同操作系统平台如等上播放多种格式的视频文件常见的视频格式包括等该播放器包含了两个维度适合使用桥接模式类图如下代码如下接口视频类视频文件视频类文件操作系统版本抽象类具体类具体类测试类战狼视频文件战狼优点桥接模式提高了系统的可扩充性在两个变化维度中任意扩展一个维度都不需要修改原有系统如如果现在还有一种视频文件类型我们只需要再定义一个类实现接口即可其他类不需要发生变化实现细节对客户透明使用场景当一个类存在两个独立变化的维度且这两个维度都需要进行扩展时当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时避免在两个层次之间建立静态的继承联系通过桥接模式可以使它们在抽象层建立一个关联关系外观模式概述外观模式又名门面模式是一种通过为多个复杂的子系统提供一个一致的接口而使这些子系统更加容易被访问的模式该模式对外有一个统一接口外部应用程序不用关心内部子系统的具体的细节这样会大大降低应用程序的复杂度提高了程序的可维护性外观模式是迪米特法则的典型应用结构外观模式包含以下主要角色外观角色为多个子系统对外提供一个共同的接口子系统角色实现系统的部分功能客户可以通过外观角色访问它案例例智能家电控制小明的爷爷已经岁了一个人在家生活每次都需要打开灯打开电视打开空调睡觉时关闭灯关闭电视关闭空调操作起来都比较麻烦所以小明给爷爷买了智能音箱可以通过语音直接控制这些智能家电的开启和关闭类图如下代码如下灯类打开了灯关闭了灯电视类打开了电视关闭了电视空调类打开了空调关闭了空调智能控制类打开关闭请再重复一遍起床了睡觉了测试类创建外观对象客户端直接与外观对象进行交互打开家电关闭家电优点降低了子系统与客户端之间的耦合度使得子系统的变化不会影响调用它的客户类对客户屏蔽了子系统组件减少了客户处理的对象数目并使得子系统使用起来更加容易缺点不符合开闭原则修改很麻烦使用场景对分层结构系统构建时使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系当一个复杂系统的子系统很多时外观模式可以为系统设计一个简单的接口供外界访问当客户端与多个子系统之间存在很大的联系时引入外观模式可将它们分离从而提高子系统的独立性和可移植性组合模式概述组合模式又名部分整体模式是用于把一组相似的对象当作一个单一的对象组合模式依据树形结构来组合对象用来表示部分以及整体层次这种类型的设计模式属于结构型模式它创建了对象组的树形结构结构组合模式主要包括三种角色抽象根节点定义系统各层次对象的共有方法和属性可以预先定义一些默认行为和属性树枝节点定义树枝节点的行为存储子节点组合树枝节点和叶子节点形成一个树形结构叶子节点叶子节点对象其下再无分支是系统层次遍历的最小单位案例例软件菜单我们在访问别的一些管理系统时经常可以看到类似的菜单一个菜单可以包含菜单项菜单项是指不再包含其他内容的菜单条目也可以包含带有其他菜单项的菜单因此使用组合模式描述菜单就很恰当我们的需求是针对一个菜单打印出其包含的所有菜单以及菜单项的名称类图如下代码如下菜单组件类不管是菜单还是菜单项都应该继承该类添加菜单移除菜单获取指定的子菜单获取菜单名称这里的定义为抽象类因为有一些共有的属性和行为要在该类中实现和类就可以只覆盖自己感兴趣的方法而不用搭理不需要或者不感兴趣的方法举例来说类可以包含子菜单因此需要覆盖方法但是就不应该有这些方法这里给出的默认实现是抛出异常你也可以根据自己的需要改写默认实现菜单类菜单类实现除了方法之外的其他所有方法因为菜单类具有添加菜单项移除菜单项和获取子菜单的功能菜单项是菜单项不能再有子菜单所以添加菜单移除菜单和获取子菜单的功能并不能实现测试类学习打印结果学习分类在使用组合模式时根据抽象构件类的定义形式我们可将组合模式分为透明组合模式和安全组合模式两种形式透明组合模式透明组合模式中抽象根节点角色中声明了所有用于管理成员对象的方法比如在示例中声明了方法这样做的好处是确保所有的构件类都有相同的接口透明组合模式也是组合模式的标准形式透明组合模式的缺点是不够安全因为叶子对象和容器对象在本质上是有区别的叶子对象不可能有下一个层次的对象即不可能包含成员对象因此为其提供等方法是没有意义的这在编译阶段不会出错但在运行阶段如果调用这些方法可能会出错如果没有提供相应的错误处理代码安全组合模式在安全组合模式中在抽象构件角色中没有声明任何用于管理成员对象的方法而是在树枝节点类中声明并实现这些方法安全组合模式的缺点是不够透明因为叶子构件和容器构件具有不同的方法且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义因此客户端不能完全针对抽象编程必须有区别地对待叶子构件和容器构件优点组合模式可以清楚地定义分层次的复杂对象表示对象的全部或部分层次它让客户端忽略了层次的差异方便对整个层次结构进行控制客户端可以一致地使用一个组合结构或其中单个对象不必关心处理的是单个对象还是整个组合结构简化了客户端代码在组合模式中增加新的树枝节点和叶子节点都很方便无须对现有类库进行任何修改符合开闭原则组合模式为树形结构的面向对象实现提供了一种灵活的解决方案通过叶子节点和树枝节点的递归组合可以形成复杂的树形结构但对树形结构的控制却非常简单应用场景组合模式正是应树形结构而生所以组合模式的使用场景就是出现树形结构的地方比如文件目录显示多级目录呈现等树形结构数据的操作享元模式概述运用共享技术来有效地支持大量细粒度对象的复用它通过共享已经存在的对象来大幅度减少需要创建的对象数量避免大量相似对象的开销从而提高系统资源的利用率结构享元模式中存在以下两种状态内部状态即不会随着环境的改变而改变的可共享部分外部状态指随环境改变而改变的不可以共享的部分享元模式的实现要领就是区分应用中的这两种状态并将外部状态外部化抽象享元角色通常是一个接口或抽象类在抽象享元类中声明了具体享元类公共的方法这些方法可以向外界提供享元对象的内部数据内部状态同时也可以通过这些方法来设置外部数据外部状态具体享元角色它实现了抽象享元类称为享元对象在具体享元类中为内部状态提供了存储空间通常我们可以结合单例模式来设计具体享元类为每一个具体享元类提供唯一的享元对象非享元角色并不是所有的抽象享元类的子类都需要被共享不能被共享的子类可设计为非共享具体享元类当需要一个非共享具体享元类的对象时可以直接通过实例化创建享元工厂角色负责创建和管理享元角色当客户对象请求一个享元对象时享元工厂检査系统中是否存在符合要求的享元对象如果存在则提供给客户如果不存在的话则创建一个新的享元对象案例例俄罗斯方块下面的图片是众所周知的俄罗斯方块中的一个个方块如果在俄罗斯方块这个游戏中每个不同的方块都是一个实例对象这些对象就要占用很多的内存空间下面利用享元模式进行实现类图如下代码如下抽象方块类俄罗斯方块有不同的形状我们可以对这些形状向上抽取出用来定义共性的属性和行为方块形状颜色具体方块类方块工厂类提供一个方块工厂类用来管理享元对象也就是子类对象该工厂类对象只需要一个所以可以使用单例模式之后如果我们想要生产一个具体的方块比如形方块我们就可以直接调用获取工厂通过工厂获取指定的方块实例并且多次调用返回的是一个实例优缺点优点极大减少内存中相似或相同对象数量节约系统资源提供系统性能享元模式中的外部状态相对独立且不影响内部状态缺点为了使对象可以共享需要将享元对象的部分状态外部化分离内部状态和外部状态使程序逻辑复杂第六章行为型模式行为型模式用于描述程序在运行时复杂的流程控制即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务它涉及算法与对象间职责的分配行为型模式分为类行为模式和对象行为模式前者采用继承机制来在类间分派行为后者采用组合或聚合在对象间分配行为由于组合关系或聚合关系比继承关系耦合度低满足合成复用原则所以对象行为模式比类行为模式具有更大的灵活性行为型模式分为模板方法模式策略模式命令模式职责链模式状态模式观察者模式中介者模式迭代器模式访问者模式备忘录模式解释器模式以上种行为型模式除了模板方法模式和解释器模式是类行为模式其他全部属于对象行为型模式模板方法模式概述模板方法模式定义一个操作中的算法骨架而将算法的一些步骤延迟到子类中使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤结构模板方法模式包含以下主要角色抽象类负责给出一个算法的轮廓和骨架它由一个模板方法和若干个基本方法构成模板方法定义了算法的骨架按某种顺序调用其包含的基本方法基本方法是实现算法各个步骤的方法是模板方法的组成部分基本方法又可以分为三种抽象方法一个抽象方法由抽象类声明由其具体子类实现具体方法一个具体方法由一个抽象类或具体类声明并实现其子类可以进行覆盖也可以直接继承钩子方法在抽象类中已经实现包括用于判断的逻辑方法和需要子类重写的空方法两种具体子类实现抽象类中所定义的抽象方法和钩子方法它们是一个顶级逻辑的组成步骤案例例炒菜炒菜的步骤是固定的分为倒油热油倒蔬菜倒调料品翻炒等步骤现通过模板方法模式来用代码模拟类图如下代码如下抽象模板类第一步倒油第二步热油第三步倒蔬菜第四步倒调味料第五步翻炒第一步倒油是一样的所以直接实现倒油第二步热油是一样的所以直接实现热油第三步倒蔬菜是不一样的一个下包菜一个是下菜心第四步倒调味料是不一样第五步翻炒是一样的所以直接实现炒啊炒啊炒到熟啊炒菜具体子类下锅的蔬菜是包菜下锅的酱料是辣椒下锅的蔬菜是菜心下锅的酱料是蒜蓉测试类为了防止恶意操作一般模板方法上都加上关键字优缺点优点提高代码复用性将相同部分的代码放在抽象的父类中而将不同的代码放入不同的子类中实现了反向控制通过一个父类调用其子类的操作通过对子类的具体实现扩展不同的行为实现了反向控制并符合开闭原则缺点对每个不同的实现都需要定义一个子类这会导致类的个数增加系统更加庞大设计也更加抽象父类中的抽象方法由子类实现子类执行的结果会影响父类的结果这导致一种反向的控制结构它提高了代码阅读的难度适用场景算法的整体步骤很固定但其中个别部分易变时这时候可以使用模板方法模式将容易变的部分抽象出来供子类实现需要通过子类来决定父类算法中某个步骤是否执行实现子类对父类的反向控制策略模式策略模式该模式定义了一系列算法并将每个算法封装起来使它们可以相互替换且算法的变化不会影响使用算法的客户策略模式属于对象行为模式它通过对算法进行封装把使用算法的责任和算法的实现分割开来并委派给不同的对象对这些算法进行管理结构策略模式的主要角色如下抽象策略类这是一个抽象角色通常由一个接口或抽象类实现此角色给出所有的具体策略类所需的接口具体策略类实现了抽象策略定义的接口提供具体的算法实现或行为环境类持有一个策略类的引用最终给客户端调用案例例促销活动一家百货公司在定年度的促销活动针对不同的节日春节中秋节圣诞节推出不同的促销活动由促销员将促销活动展示给客户类图如下代码如下共同促销策略接口所有促销活动的共同接口具体策略角色每个节日具体的促销活动买一送一满减环境角色用于连接上下文即把促销活动推销给用户优缺点优点策略类之间可以相互切换由于策略类都实现同一个接口所以使它们之间可以自由切换易于扩展增加一个新的策略只需要添加一个具体的策略类即可基本不需要改变原有的代码符合开闭原则避免使用多重条件选择语句充分体现面向对象设计思想缺点客户端必须知道所有的策略类并决定使用哪一个策略类策略模式将产生很多的策略类可以使用享元模式在一定程度上减少对象的数量适用场景一个系统需要动态地在几种算法中选择一种时可将每个算法封装到策略类中一个类定义了多种行为并且这些行为在这个类的操作中以多个条件语句的形式出现可将每个条件分支移入它们各自的策略类中以代替这些条件语句系统中各算法彼此完全独立且要求对客户隐藏具体算法的实现细节时系统要求使用算法的客户不应该知道其操作的数据时可使用策略模式来隐藏与算法相关的数据结构多个类只区别在表现行为不同可以使用策略模式在运行时动态选择具体要执行的行为命令模式命令模式将一个请求封装为一个对象使发出请求的责任和执行请求的责任分割开这样两者之间通过命令对象进行沟通这样方便将命令对象进行存储传递调用增加与管理结构命令模式包含以下主要角色抽象命令类角色定义命令的接口声明执行的方法具体命令角色具体的命令实现命令接口通常会持有接收者并调用接收者的功能来完成命令要执行的操作实现者接收者角色接收者真正执行命令的对象任何类都可能成为一个接收者只要它能够实现命令要求实现的相应功能调用者请求者角色要求命令对象执行请求通常会持有命令对象可以持有很多的命令对象这个是客户端真正触发命令并要求命令执行相应操作的地方也就是说相当于使用命令对象的入口案例实现点餐场景顾客把订单交给服务员服务员拿到订单给厨师下达命令厨师根据订单准备餐将上面的案例用代码实现那我们就需要分析命令模式的角色在该案例中由谁来充当服务员调用者角色发起命令的角色厨师接收者角色真正执行命令的角色订单命令中包含的订单类图如下抽象命令类统一的执行方法具体命令类将命令执行者和命令封装到一起桌的订单出餐具体命令执行类餐桌号码存储餐名并且记录份数命令执行者份命令传递者订单来了测试类西红柿鸡蛋面可乐炒米创建命令接收者将订单和接收者封装成对象创建调用者调用优缺点优点降低系统的耦合度命令模式能将调用操作的对象与实现该操作的对象解耦增加或删除命令非常方便采用命令模式增加与删除命令不会影响其他类它满足开闭原则对扩展比较灵活可以实现宏命令命令模式可以与组合模式结合将多个命令装配成一个组合命令即宏命令方便实现和操作命令模式可以与后面介绍的备忘录模式结合实现命令的撤销与恢复缺点使用命令模式可能会导致某些系统有过多的具体命令类系统结构更加复杂适用场景系统需要将请求调用者和请求接收者解耦使得调用者和接收者不直接交互系统需要在不同的时间指定请求将请求排队和执行请求系统需要支持命令的撤销操作和恢复操作应用是一个典型命令模式担当命令的角色充当的是调用者方法就是其执行方法会调用一个方法调用系统方法开启一个线程而接收者是对程序员开放的可以自己定义接收者如下代码执行具体方法责任链模式责任链模式又名职责链模式为了避免请求发送者与多个请求处理者耦合在一起将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链当有请求发生时可将请求沿着这条链传递直到有对象处理它为止结构职责链模式主要包含以下角色抽象处理者角色定义一个处理请求的接口包含抽象处理方法和一个后继连接具体处理者角色实现抽象处理者的处理方法判断能否处理本次请求如果可以处理请求则处理否则将该请求转给它的后继者客户类角色创建处理链并向链头的具体处理者对象提交请求它不关心处理细节和请求的传递过程案例实现现需要开发一个请假流程控制系统请假一天以下的假只需要小组长同意即可请假天到天的假还需要部门经理同意请求天到天还需要总经理同意才行类图如下代码如下请假条实例类姓名请假天数请假内容抽象审批类该领导处理的请假天数区间领导上面还有领导设置请假天数范围上不封顶设置请假天数范围设置上级领导提交请假条如果请假天数达到该领导者的处理要求如果还有上级并且请假天数超过了当前领导的处理范围继续提交流程结束各级领导处理请假条方法具体审批类请假天小组长审批同意请假天部门经理审批同意请假天总经理审批同意测试类小明身体不适小组长部门经理总经理小组长的上级是部门经理部门经理的上级是总经理提交请假申请优缺点优点降低了对象之间的耦合度该模式降低了请求发送者和接收者的耦合度增强了系统的可扩展性可以根据需要增加新的请求处理类满足开闭原则增强了给对象指派职责的灵活性当工作流程发生变化可以动态地改变链内的成员或者修改它们的次序也可动态地新增或者删除责任责任链简化了对象之间的连接一个对象只需保持一个指向其后继者的引用不需保持其他所有处理者的引用这避免了使用众多的或者语句责任分担每个类只需要处理自己该处理的工作不能处理的传递给下一个对象完成明确各类的责任范围符合类的单一职责原则缺点不能保证每个请求一定被处理由于一个请求没有明确的接收者所以不能保证它一定会被处理该请求可能一直传到链的末端都得不到处理对比较长的职责链请求的处理可能涉及多个处理对象系统性能将受到一定影响职责链建立的合理性要靠客户端来保证增加了客户端的复杂性可能会由于职责链的错误设置而导致系统出错如可能会造成循环调用状态模式例通过按钮来控制一个电梯的状态一个电梯有开门状态关门状态停止状态运行状态每一种状态改变都有可能要根据其他状态来更新处理例如如果电梯门现在处于运行时状态就不能进行开门操作而如果电梯门是停止状态就可以执行开门操作类图如下代码如下状态接口电梯的四个状态开门状态关门状态运行状态停止状态设置电梯的状态电梯的动作电梯实例如果已经是开门状态就什么也不做电梯门已打开运行时电梯无法开门电梯门打开了电梯门已关闭运行时电梯门已经是关闭的停止时电梯门也是关闭的电梯门不能打开着运行电梯可以开始运行了已经是运行状态电梯开始运行了开门的电梯已经是停止的电梯停止了电梯停止了测试类问题分析使用了大量的这样的判断也是一样使程序的可阅读性变差扩展性很差如果新加了断电的状态我们需要修改上面判断逻辑状态模式对有状态的对象把复杂的判断逻辑提取到不同的状态对象中允许状态对象在其内部状态发生改变时改变其行为结构状态模式包含以下主要角色环境角色也称为上下文它定义了客户程序需要的接口维护一个当前状态并将与状态相关的操作委托给当前状态对象来处理抽象状态角色定义一个接口用以封装环境对象中的特定状态所对应的行为具体状态角色实现抽象状态所对应的行为案例实现对上述电梯的案例使用状态模式进行改进类图如下代码如下抽象状态类定义一个环境角色也就是封装状态的变化引起的功能变化电梯开门动作电梯关门动动作电梯运行动作电梯停止动作具体状态类开启状态类电梯门开启修改状态动作委托为来执行也就是委托给子类执行这个动作开门状态下不能运行开门状态下电梯已经停止关闭状态类电梯门关闭运行状态类运行的时候不能打开电梯门运行的时候电梯门已经是关闭的电梯正在执行停止状态类电梯已经停止运行环境角色类定义一个当前电梯的状态当前环境改变把当前的环境通知到各个实现类中测试类优缺点优点将所有与某个状态有关的行为放到一个类中并且可以方便地增加新的状态只需要改变对象状态即可改变对象的行为允许状态转换逻辑与状态对象合成一体而不是某一个巨大的条件语句块缺点状态模式的使用必然会增加系统类和对象的个数状态模式的结构与实现都较为复杂如果使用不当将导致程序结构和代码的混乱状态模式对开闭原则的支持并不太好使用场景当一个对象的行为取决于它的状态并且它必须在运行时根据状态改变它的行为时就可以考虑使用状态模式一个操作中含有庞大的分支结构并且这些分支决定于对象的状态时观察者模式观察者模式又被称为发布订阅模式它定义了一种一对多的依赖关系让多个观察者对象同时监听某一个主题对象这个主题对象在状态变化时会通知所有的观察者对象使他们能够自动更新自己结构在观察者模式中有如下角色抽象主题抽象被观察者抽象主题角色把所有观察者对象保存在一个集合里每个主题都可以有任意数量的观察者抽象主题提供一个接口可以增加和删除观察者对象具体主题具体被观察者该角色将有关状态存入具体观察者对象在具体主题的内部状态发生改变时给所有注册过的观察者发送通知抽象观察者是观察者的抽象类它定义了一个更新接口使得在得到主题更改通知时更新自己具体观察者实现抽象观察者定义的更新接口以便在得到主题更改通知时更新自身的状态案例实现例微信公众号在使用微信公众号时大家都会有这样的体验当你关注的公众号中有新内容更新的话它就会推送给关注公众号的微信用户端我们使用观察者模式来模拟这样的场景微信用户就是观察者微信公众号是被观察者有多个的微信用户关注了程序猿这个公众号类图如下代码如下抽象观察者类具体观察者类抽象主题类增加订阅者删除订阅着通知订阅者更新消息具体主题类测试类具体主题实例小红具体观察者实例小明小军观察者订阅具体主题专栏更新啦发布通知优缺点优点降低了目标与观察者之间的耦合关系两者之间是抽象耦合关系被观察者发送通知所有注册的观察者都会收到信息可以实现广播机制缺点如果观察者非常多的话那么所有的观察者收到被观察者发送的通知会耗时如果被观察者有循环依赖的话那么被观察者发送通知会使观察者循环调用会导致系统崩溃使用场景对象间存在一对多关系一个对象的状态发生改变会影响其他对象当一个抽象模型有两个方面其中一个方面依赖于另一方面时中提供的实现在中通过类和接口定义了观察者模式只要实现它们的子类就可以编写观察者模式实例类类是抽象目标类被观察者它有一个集合成员变量用于保存所有要通知的观察者对象下面来介绍它最重要的个方法方法用于将新的观察者对象添加到集合中方法调用集合中的所有观察者对象的方法通知它们数据发生改变通常越晚加入集合的观察者越先得到通知方法用来设置一个类型的内部标志注明目标对象发生了变化当它为时才会通知观察者接口接口是抽象观察者它监视目标对象的变化当目标对象发生变化时观察者得到通知并调用方法进行相应的工作例警察抓小偷警察抓小偷也可以使用观察者模式来实现警察是观察者小偷是被观察者代码如下小偷是一个被观察者所以需要继承类小偷偷东西了通知警察是一个观察者所以需要让其实现接口警察已经盯着你很久了测试类小小偷好警察添加观察者偷东西中介模式一般来说同事类之间的关系是比较复杂的多个同事类之间互相关联时他们之间的关系会呈现为复杂的网状结构这是一种过度耦合的架构即不利于类的复用也不稳定例如在下左图中有六个同事类对象假如对象发生变化那么将会有个对象受到影响如果对象发生变化那么将会有个对象受到影响也就是说同事类之间直接关联的设计是不好的如果引入中介者模式那么同事类之间的关系将变为星型结构从下右图中可以看到任何一个类的变动只会影响的类本身以及中介者这样就减小了系统的耦合一个好的设计必定不会把所有的对象关系处理逻辑封装在本类中而是使用一个专门的类来管理那些不属于自己的行为中介模式又叫调停模式定义一个中介角色来封装一系列对象之间的交互使原有对象之间的耦合松散且可以独立地改变它们之间的交互结构中介者模式包含以下主要角色抽象中介者角色它是中介者的接口提供了同事对象注册与转发同事对象信息的抽象方法具体中介者角色实现中介者接口定义一个来管理同事对象协调各个同事角色之间的交互关系因此它依赖于同事角色抽象同事类角色定义同事类的接口保存中介者对象提供同事对象交互的抽象方法实现所有相互影响的同事类的公共功能具体同事类角色是抽象同事类的实现者当需要与其他同事对象交互时由中介者对象负责后续的交互案例实现例租房现在租房基本都是通过房屋中介房主将房屋托管给房屋中介而租房者从房屋中介获取房屋信息房屋中介充当租房者与房屋所有者之间的中介者类图如下代码如下抽象中介者类申明一个联络方法抽象同事类具体同事类房屋拥有者与中介联系获取信息房主获取到的信息房屋租赁者与中介者联系获取信息租房者获取到的信息具体中介类如果是房主则租户获得信息否则是房主获得信息测试类中介张三李四中介要知道房主和租客需要租三室一厅的房子我这有适合的房源可以商量一下吗优缺点优点松散耦合中介者模式通过把多个同事对象之间的交互封装到中介者对象里面从而使得同事对象之间松散耦合基本上可以做到互补依赖这样一来同事对象就可以独立地变化和复用而不再像以前那样牵一处而动全身了集中控制交互多个同事对象的交互被封装在中介者对象里面集中管理使得这些交互行为发生变化的时候只需要修改中介者对象就可以了当然如果是已经做好的系统那么就扩展中介者对象而各个同事类不需要做修改一对多关联转变为一对一的关联没有使用中介者模式的时候同事对象之间的关系通常是一对多的引入中介者对象以后中介者对象和同事对象的关系通常变成双向的一对一这会让对象的关系更容易理解和实现缺点当同事类太多时中介者的职责将很大它会变得复杂而庞大以至于系统难以维护使用场景系统中对象之间存在复杂的引用关系系统结构混乱且难以理解当想创建一个运行于多个类之间的对象又不想生成新的子类时迭代器模式迭代器模式提供一个对象来顺序访问聚合对象中的一系列数据而不暴露聚合对象的内部表示结构迭代器模式主要包含以下角色抽象聚合角色定义存储添加删除聚合元素以及创建迭代器对象的接口具体聚合角色实现抽象聚合类返回一个具体迭代器的实例抽象迭代器角色定义访问和遍历聚合元素的接口通常包含等方法具体迭代器角色实现抽象迭代器接口中所定义的方法完成对聚合对象的遍历记录遍历的当前位置案例例定义一个可以存储学生对象的容器对象将遍历该容器的功能交由迭代器实现涉及到的类如下代码如下迭代器接口具体的迭代器类抽象容器类具体容器类测试类张三李四王五优缺点优点它支持以不同的方式遍历一个聚合对象在同一个聚合对象上可以定义多种遍历方式在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法我们也可以自己定义迭代器的子类以支持新的遍历方式迭代器简化了聚合类由于引入了迭代器在原有的聚合对象中不需要再自行提供数据遍历等方法这样可以简化聚合类的设计在迭代器模式中由于引入了抽象层增加新的聚合类和迭代器类都很方便无须修改原有代码满足开闭原则的要求缺点增加了类的个数这在一定程度上增加了系统的复杂性适用场景当需要为聚合对象提供多种遍历方式时当需要为遍历不同的聚合结构提供一个统一的接口时当访问一个聚合对象的内容而无须暴露其内部细节的表示时集合源码应用迭代器模式在的很多集合类中被广泛应用接下来看看源码中是如何使用迭代器模式的方法返回的肯定是接口的子实现类对象看完这段代码是不是很熟悉与我们上面代码基本类似单列集合都使用到了迭代器我们以举例来说明抽象聚合类具体的聚合类抽象迭代器返回的是实现了接口的具体迭代器对象访问者模式访问者模式封装一些作用于某种数据结构中的各元素的操作它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作结构访问者模式包含以下主要角色抽象访问者角色定义了对每一个元素访问的行为它的参数就是可以访问的元素它的方法个数理论上来讲与元素类个数的实现类个数是一样的从这点不难看出访问者模式要求元素类的个数不能改变具体访问者角色给出对每一个元素类访问时所产生的具体行为抽象元素角色定义了一个接受访问者的方法其意义是指每一个元素都要可以被访问者访问具体元素角色提供接受访问方法的具体实现而这个具体的实现通常情况下是使用访问者提供的访问该元素类的方法对象结构角色定义当中所提到的对象结构对象结构是一个抽象表述具体点可以理解为一个具有容器性质或者复合对象特性的类它会含有一组元素并且可以迭代这些元素供访问者访问案例实现例给宠物喂食现在养宠物的人特别多我们就以这个为例当然宠物还分为狗猫等要给宠物喂食的话主人可以喂其他人也可以喂食访问者角色给宠物喂食的人具体访问者角色主人其他人抽象元素角色动物抽象类具体元素角色宠物狗宠物猫结构对象角色主人家类图如下代码如下抽象访问者接口具体访问者实例主人喂食猫主人喂食狗其他人喂食猫其他人喂食狗抽象节点具体节点好吃汪汪汪好吃喵喵喵对象结构添加操作测试优缺点优点扩展性好在不修改对象结构中的元素的情况下为对象结构中的元素添加新的功能复用性好通过访问者来定义整个对象结构通用的功能从而提高复用程度分离无关行为通过访问者来分离无关的行为把相关的行为封装在一起构成一个访问者这样每一个访问者的功能都比较单一缺点对象结构变化很困难在访问者模式中每增加一个新的元素类都要在每一个具体访问者类中增加相应的具体操作这违背了开闭原则违反了依赖倒置原则访问者模式依赖了具体类而没有依赖抽象类使用场景对象结构相对稳定但其操作算法经常变化的程序对象结构中的对象需要提供多种不同且不相关的操作而且要避免让这些操作的变化影响对象的结构扩展访问者模式用到了一种双分派的技术分派变量被声明时的类型叫做变量的静态类型有些人又把静态类型叫做明显类型而变量所引用的对象的真实类型又叫做变量的实际类型比如变量的静态类型是实际类型是根据对象的类型而对方法进行的选择就是分派分派又分为两种即静态分派和动态分派静态分派发生在编译时期分派根据静态类型信息发生静态分派对于我们来说并不陌生方法重载就是静态分派动态分派发生在运行时期动态分派动态地置换掉某个方法通过方法的重写支持动态分派动态分派通过方法的重写支持动态分派重写运行执行的子类中的方法编译器在编译时期并不总是知道哪些代码会被执行因为编译器仅仅知道对象的静态类型而不知道对象的真实类型而方法的调用则是根据对象的真实类型而不是静态类型静态分派通过方法重载支持静态分派执行结果为这是为什么呢因为重载方法的分派是根据静态类型进行的这个分派过程在编译时期就完成了双分派所谓双分派技术就是在选择一个方法的时候不仅仅要根据消息接收者的运行时区别还要根据参数的运行时区别在上面代码中客户端将对象做为参数传递给类型的变量调用的方法这里完成第一次分派这里是方法重写所以是动态分派也就是执行实际类型中的方法同时也将自己作为参数传递进去这里就完成了第二次分派这里的类中有多个重载的方法而传递进行的是就是具体的实际类型的对象说到这里我们已经明白双分派是怎么回事了但是它有什么效果呢就是可以实现方法的动态绑定我们可以对上面的程序进行修改上述案例的运行结果如下双分派实现动态绑定的本质就是在重载方法委派的前面加上了继承体系中覆盖的环节由于覆盖是动态的所以重载就是动态的了备忘录模式备忘录模式提供了一种状态恢复的实现机制使得用户可以方便地回到一个特定的历史步骤当新的状态无效或者存在问题时可以使用暂时存储起来的备忘录将状态复原很多软件都提供了撤销操作如记事本等软件在编辑时按组合键时能撤销当前操作使文档恢复到之前的状态还有在浏览器中的后退键数据库事务管理中的回滚操作玩游戏时的中间结果存档功能数据库与操作系统的备份操作棋类游戏中的悔棋功能等都属于这类备忘录模式又叫快照模式在不破坏封装性的前提下捕获一个对象的内部状态并在该对象之外保存这个状态以便以后当需要时能将该对象恢复到原先保存的状态结构备忘录模式的主要角色如下发起人角色记录当前时刻的内部状态信息提供创建备忘录和恢复备忘录数据的功能实现其他业务功能它可以访问备忘录里的所有信息备忘录角色负责存储发起人的内部状态在需要的时候提供这些内部状态给发起人管理者角色对备忘录进行管理提供保存与获取备忘录的功能但其不能对备忘录的内容进行访问与修改备忘录有两个等效的接口窄接口管理者对象和其他发起人对象之外的任何对象看到的是备忘录的窄接口这个窄接口只允许他把备忘录对象传给其他的对象宽接口与管理者看到的窄接口相反发起人对象可以看到一个宽接口这个宽接口允许它读取所有的数据以便根据这些数据恢复这个发起人对象的内部状态案例实现例游戏挑战游戏中的某个场景一游戏角色有生命力攻击力防御力等数据在打前和后一定会不一样的我们允许玩家如果感觉与决斗的效果不理想可以让游戏恢复到决斗之前的状态要实现上述案例有两种方式白箱备忘录模式黑箱备忘录模式白箱备忘录模式备忘录角色对任何对象都提供一个接口即宽接口备忘录角色的内部所存储的状态就对所有对象公开类图如下游戏角色类生命力攻击力防御力初始化状态战斗保存角色状态回复角色状态角色生命力角色攻击力角色防御力游戏状态备忘类角色状态管理者类测试类大战前大战前保存进度大战后大战时损耗严重恢复之前状态恢复之前状态白箱备忘录模式是破坏封装性的但是通过程序员自律同样可以在一定程度上实现模式的大部分用意黑箱备忘录模式备忘录角色对发起人对象提供一个宽接口而为其他对象提供一个窄接口在语言中实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类将设为的内部类从而将对象封装在里面在外面提供一个标识接口给及其他对象使用这样类看到的是所有的接口而及其他对象看到的仅仅是标识接口所暴露出来的接口从而维护了封装型类图如下代码如下窄接口作为一个标识接口发起人类在内部定义备忘录内部类该内部类设置为私有的生命力攻击力防御力初始化状态战斗保存角色状态回复角色状态角色生命力角色攻击力角色防御力负责人角色类负责人角色类能够得到的备忘录对象是以为接口的由于这个接口仅仅是一个标识接口因此负责人角色不可能改变这个备忘录对象的内容测试类大战前大战前保存进度大战后大战时损耗严重恢复之前状态恢复之前状态优缺点优点提供了一种可以恢复状态的机制当用户需要时能够比较方便地将数据恢复到某个历史的状态实现了内部状态的封装除了创建它的发起人之外其他对象都不能够访问这些状态信息简化了发起人类发起人不需要管理和保存其内部状态的各个备份所有状态信息都保存在备忘录中并由管理者进行管理这符合单一职责原则缺点资源消耗大如果要保存的内部状态信息过多或者特别频繁将会占用比较大的内存资源适用场景需要保存与恢复数据的场景如玩游戏时的中间结果的存档功能需要提供一个可回滚操作的场景如记事本等软件在编辑时按组合键还有数据库中事务操作解释器模式例设计一个软件用来进行加减计算我们第一想法就是使用工具类提供对应的加法和减法的工具方法用于两个整数相加用于两个整数相加用于个整数相加上面的形式比较单一有限如果形式变化非常多这就不符合要求因为加法和减法运算两个运算符与数值可以有无限种组合方式比如等等显然现在需要一种翻译识别机器能够解析由数字以及符号构成的合法的运算序列如果把运算符和数字都看作节点的话能够逐个节点的进行读取解析运算这就是解释器模式的思维在解释器模式中我们需要将待解决的问题提取出规则抽象为一种语言比如加减法运算规则为由数值和符号组成的合法序列就是这种语言的句子解释器就是要解析出来语句的含义但是如何描述规则呢文法语法规则文法是用于描述语言的语法结构的形式规则注意这里的符号表示定义为的意思竖线表示或左右的其中一个引号内为字符本身引号外为语法上面规则描述为表达式可以是一个值也可以是或者运算而和又是由表达式结合运算符构成值的类型为整型数抽象语法树在计算机科学中抽象语法树或简称语法树是源代码语法结构的一种抽象表示它以树状的形式表现编程语言的语法结构树上的每个节点都表示源代码中的一种结构用树形来表示符合文法规则的句子结构解释器模式包含以下主要角色抽象表达式角色定义解释器的接口约定解释器的解释操作主要包含解释方法终结符表达式角色是抽象表达式的子类用来实现文法中与终结符相关的操作文法中的每一个终结符都有一个具体终结表达式与之相对应非终结符表达式角色也是抽象表达式的子类用来实现文法中与非终结符相关的操作文法中的每条规则都对应于一个非终结符表达式环境角色通常包含各个解释器需要的数据或是公共的功能一般用来传递被所有解释器共享的数据后面的解释器可以从这里获取这些值客户端主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树然后调用解释器的解释方法当然也可以通过环境角色间接访问解释器的解释方法案例实现例设计实现加减法的软件代码如下抽象表达式终结符表达式非终结符表达式终结符表达式环境类测试类打印结果优缺点优点易于改变和扩展文法由于在解释器模式中使用类来表示语言的文法规则因此可以通过继承等机制来改变或扩展文法每一条文法规则都可以表示为一个类因此可以方便地实现一个简单的语言实现文法较为容易在抽象语法树中每一个表达式节点类的实现方式都是相似的这些类的代码编写都不会特别复杂增加新的解释表达式较为方便如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类原有表达式类代码无须修改符合开闭原则缺点对于复杂文法难以维护在解释器模式中每一条规则至少需要定义一个类因此如果一个语言包含太多文法规则类的个数将会急剧增加导致系统难以管理和维护执行效率较低由于在解释器模式中使用了大量的循环和递归调用因此在解释较为复杂的句子时其速度很慢而且代码的调试过程也比较麻烦适用场景当语言的文法较为简单且执行效率不是关键问题时当问题重复出现且可以用一种简单的语言来进行表达时当一个语言需要解释执行并且语言中的句子可以表示为一个抽象语法树的时候',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-12 19:24:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小奥</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 1.05rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 1.05rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 1.05rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 1.05rem;">Feed流<sup>1</sup></a><a href="/tags/Full-GC/" style="font-size: 1.05rem;">Full GC<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 1.05rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 1.05rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 1.05rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 1.05rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 1.05rem;">ReentrantLock<sup>1</sup></a><a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">SQL优化<sup>2</sup></a><a href="/tags/Servlet/" style="font-size: 1.05rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 1.05rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 1.05rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 1.05rem;">synchronized<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>3</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>2</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 1.05rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 1.05rem;">文件上传<sup>1</sup></a><a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 1.05rem;">死锁<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">算法模板<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">设计模式</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>设计模式</span></a></span></div></div><h1 class="post-title" itemprop="name headline">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-02-15T02:43:45.000Z" title="发表于 2023-02-15 10:43:45">2023-02-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-12T11:24:05.822Z" title="更新于 2024-01-12 19:24:05">2024-01-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/png/12.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><header><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">设计模式</a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url">设计模式</a><h1 id="CrawlerTitle" itemprop="name headline">设计模式</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小奥</span><time itemprop="dateCreated datePublished" datetime="2023-02-15T02:43:45.000Z" title="发表于 2023-02-15 10:43:45">2023-02-15</time><time itemprop="dateCreated datePublished" datetime="2024-01-12T11:24:05.822Z" title="更新于 2024-01-12 19:24:05">2024-01-12</time></header><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="第一章-设计模式概述"><a href="#第一章-设计模式概述" class="headerlink" title="第一章 设计模式概述"></a>第一章 设计模式概述</h2><p>软件设计模式(Software Design Pattern)，又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。</p>
<blockquote>
<p>设计模式分类</p>
</blockquote>
<p>（1）创建型模式</p>
<p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。分别是工厂方法、抽象工厂、建造者、原型和单例5种创建型模式。</p>
<p>（2）结构型模式</p>
<p>用于描述如何将类或者对象按某种布局组成更大的结构。分别是适配器、桥接、组合、装饰器、外观、享元、代理等7种结构型模式。</p>
<p>（3）行为型模式</p>
<p>用于描述类或者对象之间怎样相互写作共同完成单个对象无法单独完成的任务，以及怎样分配职责。分别是解释器、模板方法、职责链、命令、迭代器、中介者、备忘录、观察者、状体、策略、访问者等11种行为型模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230418194645385.png" alt="image-20230418194645385"></p>
<h2 id="第二章-UML图"><a href="#第二章-UML图" class="headerlink" title="第二章 UML图"></a>第二章 UML图</h2><p>统一建模语言(Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p>UML从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图。</p>
<h3 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h3><p>类图(class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h3 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h3><ul>
<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解。</li>
<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>
</ul>
<h3 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h3><h4 id="1-类的表示方式"><a href="#1-类的表示方式" class="headerlink" title="(1)类的表示方式"></a>(1)类的表示方式</h4><p>在UML类图中，类使用包含类名、属性(field)和方法(method)且带有分割线的矩形来表示，比如下图中表示一个Employee图，它包含name，age和address这三个属性，以及work()方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419000623707.png" alt="image-20230419000623707"></p>
<p>属性&#x2F; 方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p>
<ul>
<li>+：表示public</li>
<li>-：表示private</li>
<li>#：表示protected</li>
</ul>
<p>属性的完整表示方式是：<code>可见性 名称: 类型 [ = 缺省值]</code></p>
<p>方法的完整表示方式是： <code>可见性 名称(参数列表) [ :  返回类型] </code></p>
<p>注意：① 中括号里面的内容是可选的  ② UML类图还有其他的表示方式。</p>
<h4 id="2-类与类之间关系的表示方式"><a href="#2-类与类之间关系的表示方式" class="headerlink" title="(2)类与类之间关系的表示方式"></a>(2)类与类之间关系的表示方式</h4><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联又可以分为单向关联，双向关联，自关联。</p>
<h6 id="①-单向关联"><a href="#①-单向关联" class="headerlink" title="① 单向关联"></a>① 单向关联</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419001212710.png" alt="image-20230419001212710"></p>
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<h6 id="②-双向关联"><a href="#②-双向关联" class="headerlink" title="② 双向关联"></a>② 双向关联</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419001510114.png" alt="image-20230419001510114"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。在UML类图中，双向关联用一个不带箭头的直线表示。上图中在customer类中维护一个<code>List&lt;Product&gt;</code>，表示一个顾客可以购买多个商品；在Product类中维护一个customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<h6 id="③-自关联"><a href="#③-自关联" class="headerlink" title="③ 自关联"></a>③ 自关联</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419001748635.png" alt="image-20230419001748635"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的 成员变量，也就是“自己包含自己”。</p>
<h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>
<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体 对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419001916455.png" alt="image-20230419001916455"></p>
<h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在， 部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 </p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002002708.png" alt="image-20230419002002708"></p>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机 和汽车的关系图，司机驾驶汽车：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002051144.png" alt="image-20230419002051144"></p>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一 种继承关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使 用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子 类，其类图如下图所示：、</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002134182.png" alt="image-20230419002134182"></p>
<h5 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h5><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明 的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和 船实现了交通工具，其类图如图 9 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002207730.png" alt="image-20230419002207730"></p>
<h2 id="第三章-软件设计原则"><a href="#第三章-软件设计原则" class="headerlink" title="第三章 软件设计原则"></a>第三章 软件设计原则</h2><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽 量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h3 id="3-1开闭原则"><a href="#3-1开闭原则" class="headerlink" title="3.1开闭原则"></a>3.1开闭原则</h3><p>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是实现一个热插拔的效果。可以让程序的扩展性更好，易于维护和升级。</p>
<p>要想实现开闭原则，我们需要使用接口抽象类。因为抽象类的灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象类派生出来实现类进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p>
<p>【例】 搜狗输入法 的皮肤设计。</p>
<p>分析： <code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个 <code>抽象类（AbstractSkin）</code>，而每个具体的皮肤（<code>DefaultSpecificSkin</code>和 <code>HeimaSpecificSkin</code>）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002359390.png" alt="image-20230419002359390"></p>
<h3 id="3-2里氏代换原则"><a href="#3-2里氏代换原则" class="headerlink" title="3.2里氏代换原则"></a>3.2里氏代换原则</h3><p>里氏代换原则是面向对象设计的基本原则之一。</p>
<p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能， 但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较 差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>下面看一个里氏替换原则中经典的一个例子：</p>
<p>【例】正方形不是长方形。</p>
<p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何 图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419002543305.png" alt="image-20230419002543305"></p>
<p>代码如下：</p>
<p>长方形类（Rectangle）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正方形（Square）：</p>
<p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle， resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 实现宽度逐渐增长的效果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印长方形的长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        rectangle.setLength(<span class="number">20</span>);</span><br><span class="line">        rectangle.setWidth(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle);</span><br><span class="line">        printLengthAndWidth(rectangle);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        rectangle1.setLength(<span class="number">10</span>);</span><br><span class="line">        resize(rectangle1);</span><br><span class="line">        printLengthAndWidth(rectangle1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度，代码就会停止，这种行为的结果符合我们的预期；</p>
<p>假如我 们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会 一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。 </p>
<p>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则， 它们之间的继承关系不成立，正方形不是长方形。</p>
<p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)， 让Rectangle类和Square类实现Quadrilateral接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419003252612.png" alt="image-20230419003252612"></p>
<h3 id="3-3依赖倒转原则"><a href="#3-3依赖倒转原则" class="headerlink" title="3.3依赖倒转原则"></a>3.3依赖倒转原则</h3><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>下面看一个例子来理解依赖倒转原则：</p>
<p>【例】组装电脑</p>
<p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419003432126.png" alt="image-20230419003432126"></p>
<p>代码如下：</p>
<p>希捷硬盘类（XiJieHardDisk）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;使用希捷硬盘存储数据&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;使用希捷希捷硬盘取数据&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Intel处理器（IntelCpu）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;使用Intel处理器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>金士顿内存条（KingstonMemory）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;使用金士顿作为内存条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>电脑（Computer）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> XiJieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘中获取的数据为：&quot;</span> + data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试类（TestComputer）：</p>
<p>测试类用来组装电脑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.setHardDisk(<span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>());</span><br><span class="line">        computer.setCpu(<span class="keyword">new</span> <span class="title class_">IntelCpu</span>());</span><br><span class="line">        computer.setMemory(<span class="keyword">new</span> <span class="title class_">KingstonMemory</span>());</span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p>
<p>根据依赖倒转原则进行改进：</p>
<p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个 组件具体的实现类。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419003926827.png" alt="image-20230419003926827"></p>
<p>电脑（Computer）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;计算机工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，之前的具体的类要实现这些接口，如类图中所示。</p>
<p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实 现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低 了客户程序与实现细节的耦合度。</p>
<h3 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h3><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>下面看一个例子来理解接口隔离原则、</p>
<p>【例】安全门案例</p>
<p>我们需要创建一个 <code>黑马 </code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防 盗功能提取成一个接口，形成一套规范。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419004210724.png" alt="image-20230419004210724"></p>
<p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们 还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现 SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419004241793.png" alt="image-20230419004241793"></p>
<p>代码如下：</p>
<p>AntiTheft（防盗接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fireproof（防火接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Waterproof（防水接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeiMaSafetyDoor（类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeiMaSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof,Waterproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ItcastSafetyDoor（类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItcastSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h3><p>迪米特法则又叫最少知识原则。</p>
<p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p>
<p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发 该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象 的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>下面看一个例子来理解迪米特法则：</p>
<p>【例】明星与经纪人的关系实例</p>
<p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业 务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419132309588.png" alt="image-20230419132309588"></p>
<p>代码如下：</p>
<p>明星类（Star）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粉丝类（Fans）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fans</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体公司类（Company）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经纪人类（Agent）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star star)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans fans)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.fans = fans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company company)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() + <span class="string">&quot;见面</span></span><br><span class="line"><span class="string">        了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;与明星&quot;</span> + star.getName() +</span><br><span class="line">        <span class="string">&quot;洽淡业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-合成复用法则"><a href="#3-6-合成复用法则" class="headerlink" title="3.6 合成复用法则"></a>3.6 合成复用法则</h3><p>合成复用原则是指：尽量先使用<strong>组合</strong>或者<strong>聚合</strong>等关联关系来实现，其次才考虑使用继承关系来实现。 通常类的复用分为继承复用和合成复用两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<p>（1）继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所 以这种复用又称为“白箱”复用。 </p>
<p>（2） 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</p>
<p>（3）它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<p>（1）它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱” 复用。 </p>
<p>（2）对象间的耦合度低。可以在类的成员位置声明抽象。</p>
<p>（3）复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p>
<p>下面看一个例子来理解合成复用原则</p>
<p>【例】汽车分类管理程序</p>
<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色 汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419133247297.png" alt="image-20230419133247297"></p>
<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话， 就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419133308294.png" alt="image-20230419133308294"></p>
<h2 id="第四章-创建者模式"><a href="#第四章-创建者模式" class="headerlink" title="第四章 创建者模式"></a>第四章 创建者模式</h2><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>
<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>
<p>创建者模式分为：</p>
<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工程模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<h3 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h3><p>单例模式（Singleton Design Pattern）：如果一个类只允许创建一个对象或者实例，那么这个类就是一个单例类，这张设计模式就叫做单例模式。</p>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供 了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<blockquote>
<p>为什么要使用单例模式</p>
</blockquote>
<p>（1）处理资源访问冲突。比如我们自定义的日志打印类，如果不同的方法调用返回不同的实例，那么可能最后我们输出的日志就会产生盖覆盖或者乱序的现象。</p>
<p>（2）表示全局唯一类。比如配置信息，在全局中，只能存在一个。</p>
<blockquote>
<p>单例模式的实现</p>
</blockquote>
<p>单例设计模式分为两种：</p>
<ul>
<li>饿汉式：类加载就会导致该单实例对象被创建</li>
<li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象的时候才会创建</li>
</ul>
<h4 id="1-创建方式"><a href="#1-创建方式" class="headerlink" title="(1)创建方式"></a>(1)创建方式</h4><h5 id="①饿汉式"><a href="#①饿汉式" class="headerlink" title="①饿汉式"></a>①饿汉式</h5><blockquote>
<p>静态常量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singleton</span>(); <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：写法比较简单，在类加载的时候就完成了实例化，避免了线程同步问题。</p>
<p>缺点：在类加载的时候就完成实例化，没有达到懒加载的效果，如果不使用这个实例，就会造成内存的浪费。</p>
<blockquote>
<p>静态代码块</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式的对象的创建是在静态代码块中，也是随着类的加载而创建，所以和静态常量的方式基本一致。</p>
<h5 id="②懒汉式"><a href="#②懒汉式" class="headerlink" title="②懒汉式"></a>②懒汉式</h5><blockquote>
<p>线程不安全</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：这种方式实现了懒加载，当调用getinstance()方法获取Singleton类的对象的时候才会创建Singleton类的对象。</p>
<p>缺点：只能在单线程环境下使用，如果是多线程环境便会出现线程不安全问题。</p>
<blockquote>
<p>线程安全（同步方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：实现了懒加载，保证线程安全</p>
<p>缺点：synchronize执行效率比较低</p>
<blockquote>
<p>线程安全（同步代码块）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">）</span><br></pre></td></tr></table></figure>

<h5 id="③双重检查"><a href="#③双重检查" class="headerlink" title="③双重检查"></a>③双重检查</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">					INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检 测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问 题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p>
<p> 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字，volatile 关键字可以保证可见性和有序性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private static volatile Singleton INSTANCE;</span><br><span class="line">	private Singleton() &#123;&#125;</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if(INSTANCE == null) &#123;</span><br><span class="line">			synchronized (Singleton.class) &#123;</span><br><span class="line">				if(INSTANCE == null) &#123;</span><br><span class="line">					INSTANCE = new singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程 的情况下线程安全也不会有性能问题。</p>
<h5 id="④静态内部类"><a href="#④静态内部类" class="headerlink" title="④静态内部类"></a>④静态内部类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>
<h5 id="⑤枚举-恶汉式"><a href="#⑤枚举-恶汉式" class="headerlink" title="⑤枚举(恶汉式)"></a>⑤枚举(恶汉式)</h5><p>借助JDK1.5提供的枚举类来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单例模式的优缺点</p>
</blockquote>
<p>优点：保证系统内该类只存在一个对象实例，节省了系统的资源。</p>
<p>缺点：要想实例化一个单例对象，必须使用相应的获取对象的方法，不能使用new</p>
<h4 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="(2)存在的问题"></a>(2)存在的问题</h4><h5 id="①-序列化破坏单例模式"><a href="#①-序列化破坏单例模式" class="headerlink" title="① 序列化破坏单例模式"></a>① 序列化破坏单例模式</h5><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p>
<blockquote>
<p>序列化和反序列化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123; <span class="comment">//  静态内部类方式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 往文件中写入对象</span></span><br><span class="line">        <span class="comment">// writeObjectToFile();</span></span><br><span class="line">        <span class="comment">// 从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        System.out.println(s1 == s2);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(Paths.get(<span class="string">&quot;d:\\test.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">// 第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObjectToFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">// 创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;d:\\test.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">// 将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的运行结果是false，说明序列化和反序列化已经破坏了单例设计模式。</p>
<h5 id="②反射破坏单例模式"><a href="#②反射破坏单例模式" class="headerlink" title="②反射破坏单例模式"></a>②反射破坏单例模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zal.design;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Singleton类的字节码对象</span></span><br><span class="line">        Class&lt;Singleton&gt; clazz = Singleton.class;</span><br><span class="line">        <span class="comment">// 获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。</p>
<h4 id="3-问题的解决"><a href="#3-问题的解决" class="headerlink" title="(3)问题的解决"></a>(3)问题的解决</h4><h5 id="①-序列化、反序列化方式破坏单例模式的解决"><a href="#①-序列化、反序列化方式破坏单例模式的解决" class="headerlink" title="① 序列化、反序列化方式破坏单例模式的解决"></a>① 序列化、反序列化方式破坏单例模式的解决</h5><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 定义了这个方法，就返回这个方法的值</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>我们可以查看ObjectInputStream类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">(Class&lt;?&gt; type)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(type, <span class="literal">false</span>); <span class="comment">// 我们再查看readObject0()方法</span></span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(Class&lt;?&gt; type, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">        <span class="keyword">if</span> (type == String.class) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(<span class="string">&quot;Cannot cast an object to java.lang.String&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared)); <span class="comment">// 再点入readOrdinaryObject查看</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// isInstantiable返回true，执行desc.newInstance()通过反射创建新的单例类</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    	<span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">		<span class="comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="②-反射破坏单例模式的解决"><a href="#②-反射破坏单例模式的解决" class="headerlink" title="② 反射破坏单例模式的解决"></a>② 反射破坏单例模式的解决</h5><blockquote>
<p>饿汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;懒汉式单例模式不能被反射破坏！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// 对外提供静态方法获取该对象</span></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p>
<blockquote>
<p>懒汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;懒汉式单例无法阻止反射破坏！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance != <span class="literal">null</span>) <span class="keyword">return</span> instance;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然执行刚才的测试方法，发现仍能得到结果，并没有抛出异常。原因是我们通过<strong>反射创建实例</strong>和**静态调用方法getInstance()**获得实例的位置互换了，所以一开始通过反射创建实例调用构造器，此时构造器中的判断<code>install != null</code>是无用的，所以这种方式不适用懒汉式单例模式来防止被反射破坏的。</p>
<h4 id="4-单例应用-Runtime类"><a href="#4-单例应用-Runtime类" class="headerlink" title="(4)(单例应用)Runtime类"></a>(4)(单例应用)Runtime类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">	<span class="comment">// 提供一个公开的方法，并且接受对象的私有化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p>
<h3 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Java中万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严 重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。</p>
<p>如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象， 直接在工厂里更换该对象即可，达到了与对象解耦的目的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jing99/p/12595494.html">设计模式之工厂模式(3种)详解及代码示例 - kosamino - 博客园 (cnblogs.com)</a></p>
<p>在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过一个共同的接口来指向新创建的对象。</p>
<p>它属于创建型模式，但不属于23种设计模式，使用工厂方法代替new操作的一种模式。</p>
</blockquote>
<p>工厂模式有三种：简单工厂模式、工厂方法模式和抽象工厂方式。</p>
<h4 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="(2)简单工厂模式"></a>(2)简单工厂模式</h4><p>简单工厂模式不是一种设计模式，反而比较像是一种编程习惯。</p>
<p>由一个工厂对象决定创建出哪一种产品类的实例，简单工厂的实质是由一个工厂类根据传入的类型，动态决定应该创建哪一个产品类。</p>
<p>适用场景：工厂类负责创建的对象比较少；客户端（应用层）只需要知道传入工厂类的参数，对于如何创建对象并不关心。</p>
<h5 id="①结构"><a href="#①结构" class="headerlink" title="①结构"></a>①结构</h5><ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特征和功能</li>
<li>具体产品：实现或者继承抽象产品的子类</li>
<li>具体工厂：提供了创建产品的方法，调用者通过该方法获取产品</li>
</ul>
<h5 id="②-实现"><a href="#②-实现" class="headerlink" title="② 实现"></a>② 实现</h5><p>适用场景：调用者只需要知道传入产品的参数，对于创建对象的逻辑并不关心。</p>
<p>【例】咖啡店点餐系统</p>
<p>需求：设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡 【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>使用简单工厂模式对该需求进行改进，类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419212625377.png" alt="image-20230419212625377"></p>
<p>工厂类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    	<span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的 orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和 SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原 则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修 改操作。</p>
<h5 id="③-扩展"><a href="#③-扩展" class="headerlink" title="③ 扩展"></a>③ 扩展</h5><p>在开发中我们还可以将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    	<span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="④优缺点"><a href="#④优缺点" class="headerlink" title="④优缺点"></a>④优缺点</h5><p>优点：封装了创建对象的过程，通过参数直接获取对象，实现了对象创建和业务逻辑的分离；如果要实现新产品直接修改工厂类，扩展性更强。</p>
<p>缺点：工厂类不够灵活，增加新产品还要修改工厂类代码，违背了“开闭原则”。</p>
<h4 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="(3)工厂方法模式"></a>(3)工厂方法模式</h4><p>工厂方法模式完美的解决了简单工厂模式的缺点，完全遵守开闭原则。</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<p>适用场景：</p>
<ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口</li>
<li>客户不关心创建产品的细节，只关心产品的品牌。</li>
</ul>
<h5 id="①结构-1"><a href="#①结构-1" class="headerlink" title="①结构"></a>①结构</h5><ul>
<li>抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂(ConcreteFactory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h5 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h5><p>使用工厂方法对简单工厂进行改进，类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419213303242.png" alt="image-20230419213303242"></p>
<p>代码如下：</p>
<p>【抽象工厂】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CoffeeFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体工厂】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AmericanCoffeeFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LatteCoffeeFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【咖啡店类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CoffeeStore</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffeeFactory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> coffeeFactory.createCoffee();</span><br><span class="line">        coffee.orderCoffee();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了， 这样就解决了简单工厂模式的缺点。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的 优点，而且克服了它的缺点。</p>
<h5 id="③优缺点"><a href="#③优缺点" class="headerlink" title="③优缺点"></a>③优缺点</h5><p>优点：用户只需要关系所需产品对应的工厂，无须关心创建细节；加入新产品符合开闭原则，提高扩展性。</p>
<p>缺点：增加产品类的时候，也要增加相应的工厂类，增加了系统的复杂性。</p>
<h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="(3)抽象工厂模式"></a>(3)抽象工厂模式</h4><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传 智播客只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级 的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生 产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组 产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419213550426.png" alt="image-20230419213550426"></p>
<h5 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h5><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就 能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生 产多个等级的产品。</p>
<p>使用条件：</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起适用。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<h5 id="②结构"><a href="#②结构" class="headerlink" title="②结构"></a>②结构</h5><ul>
<li>抽象工厂(Abstract Factory)：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂(Concrete Factory)：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ul>
<h5 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h5><p>【例】咖啡店业务改变</p>
<p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419213822569.png" alt="image-20230419213822569"></p>
<p>【抽象工厂】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体工厂】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 美式甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dessert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 意大利风味甜点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyDessertFactory</span> <span class="keyword">implements</span>  <span class="title class_">DessertFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dessert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<h5 id="③优缺点-1"><a href="#③优缺点-1" class="headerlink" title="③优缺点"></a>③优缺点</h5><p>优点：当一个产品族中的多个对象被设计成一起工作时，他能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：当产品族需要增加一个新的产品时，所有的工厂类都需要被修改。</p>
<h4 id="5-模式扩展"><a href="#5-模式扩展" class="headerlink" title="(5)模式扩展"></a>(5)模式扩展</h4><h5 id="①-简单工厂-配置文件解除耦合"><a href="#①-简单工厂-配置文件解除耦合" class="headerlink" title="① 简单工厂+配置文件解除耦合"></a>① 简单工厂+配置文件解除耦合</h5><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全 类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>
<p>第一步：定义配置文件。</p>
<p>为了演示方便，我们使用properties配置文件，名称为bean.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span></span><br><span class="line"><span class="attr">latte</span>=<span class="string">com.itheima.pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure>

<p>第二步，改进工厂类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span></span><br><span class="line">        CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">//遍历Properties集合对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="comment">//根据键获取值（全类名）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">                <span class="comment">//获取字节码对象</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">obj</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及 创建对象写在静态代码块中，目的就是只需要执行一次。</p>
<h4 id="6-工厂应用-Collection-iterator方法"><a href="#6-工厂应用-Collection-iterator方法" class="headerlink" title="(6)(工厂应用)Collection.iterator方法"></a>(6)(工厂应用)Collection.iterator方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;令狐冲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;任我行&quot;</span>);</span><br><span class="line">        <span class="comment">//获取迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//使用迭代器遍历</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">ele</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法 就使用到了工厂方法模式。我们看通过类图看看结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419215457886.png" alt="image-20230419215457886"></p>
<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList的Iter内部类是具体的商品类 ，在具体的工厂类中iterator()方法创建具体的商品类的对象。</p>
<blockquote>
<p>另外：</p>
<p>(1) DateFormat类中的getInstance()方法使用的是工厂模式</p>
<p>(2)Calendar类中的getInstance()方法使用的是工厂模式</p>
</blockquote>
<h3 id="4-3-原型模式"><a href="#4-3-原型模式" class="headerlink" title="4.3 原型模式"></a>4.3 原型模式</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<h4 id="2-结构"><a href="#2-结构" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>原型模式包含如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ul>
<p>接口类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419215921734.png" alt="image-20230419215921734"></p>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="(3)实现"></a>(3)实现</h4><p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原 有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ul>
<p>Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽 象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p>
<p>【RealizeType具体原型类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealizeType</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealizeType</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> RealizeType <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (RealizeType) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【PrototypeTest测试访问类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RealizeType</span> <span class="variable">realizeType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealizeType</span>();</span><br><span class="line">        <span class="type">RealizeType</span> <span class="variable">clone</span> <span class="operator">=</span> realizeType.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;原型对象和克隆对象是一个对象 ？ &quot;</span> + (realizeType == clone)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">具体的原型对象创建完毕！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">原型对象和克隆对象是一个对象 ？ <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="4-案例"><a href="#4-案例" class="headerlink" title="(4)案例"></a>(4)案例</h4><p>【例】用原型模式生成“三好学生”奖状</p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学 生”奖状出来，然后在修改奖状上的名字即可。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230419220637506.png" alt="image-20230419220637506"></p>
<p>代码如下：</p>
<p>【奖状类 Citation】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2023学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类CitationTest】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张三同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br><span class="line">李四同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br></pre></td></tr></table></figure>

<h4 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="(5)使用场景"></a>(5)使用场景</h4><ul>
<li>对象的创建非常复杂，可以使用原型模式快速创建对象</li>
<li>性能和安全要求比较高</li>
</ul>
<h4 id="6-扩展-深克隆"><a href="#6-扩展-深克隆" class="headerlink" title="(6)扩展(深克隆)"></a>(6)扩展(深克隆)</h4><p>将上面“三好学生”奖状案例中的Citation类的name属性改为Student类的属性，代码如下：</p>
<p>【奖状类 Citation】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(student.getName() + <span class="string">&quot;同学：在2023学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类CitationTest】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;河南&quot;</span>);</span><br><span class="line">        c1.setStudent(student);</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> c2.getStudent();</span><br><span class="line">        student1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (student == student1));</span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stu和stu1是同一个对象？<span class="literal">true</span></span><br><span class="line">李四同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br><span class="line">李四同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br></pre></td></tr></table></figure>

<p>stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个 Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的 引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。</p>
<p>代码如下：</p>
<p>【测试类CitationTest】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;河南&quot;</span>);</span><br><span class="line">        c1.setStudent(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;d:\\test.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(Files.newInputStream(Paths.get(<span class="string">&quot;d:\\test.txt&quot;</span>)));</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> (Citation) ois.readObject();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> c2.getStudent();</span><br><span class="line">        student1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (student == student1));</span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stu和stu1是同一个对象？<span class="literal">false</span></span><br><span class="line">张三同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br><span class="line">李四同学：在<span class="number">2023</span>学年第一学期中表现优秀，被评为三好学生。特发此状！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Citation类和Student类必须实现Serializable接口，否则会抛 NotSerializableException异常。</p>
</blockquote>
<h3 id="4-4-建造者模式"><a href="#4-4-建造者模式" class="headerlink" title="4.4 建造者模式"></a>4.4 建造者模式</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<ul>
<li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建 器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更 好的复用。</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对 象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
</ul>
<h4 id="2-结构-1"><a href="#2-结构-1" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>建造者（Builder）模式包含如下角色：</p>
<ul>
<li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的 部件对象的创建。</li>
<li>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li>
<li>产品类（Product）：要创建的复杂对象。</li>
<li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li>
</ul>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420013710402.png" alt="image-20230420013710402"></p>
<h4 id="3-实例"><a href="#3-实例" class="headerlink" title="(3)实例"></a>(3)实例</h4><p>【例】创建共享单车</p>
<p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质 的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p>
<p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和 OfoBuilder是具体的建造者；Director是指挥者。类图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420013912849.png" alt="image-20230420013912849"></p>
<p>具体代码如下：</p>
<p>【Bike自行车类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String frame;</span><br><span class="line">	<span class="keyword">private</span> String seat;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Builder抽象建造者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【xxxBuilder具体建造者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">    	mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">    	mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfoBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">    	mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">    	mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Director指挥者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">    	mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">OfoBuilder</span>());</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">MobikeBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBike</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它 用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况 下需要简化系统结构，可以把指挥者类和抽象建造者进行结合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildFrame();</span><br><span class="line">        <span class="built_in">this</span>.BuildSeat();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果 construct() 过于复杂，建议还是封装到 Director 中。</p>
<h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="(4)优缺点"></a>(4)优缺点</h4><p>优点：</p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取 得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得 相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过 程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不 用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li>
</ul>
<p>缺点：</p>
<p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适 合使用建造者模式，因此其使用范围受到一定的限制。</p>
<h4 id="5-使用场景-1"><a href="#5-使用场景-1" class="headerlink" title="(5)使用场景"></a>(5)使用场景</h4><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表 示是独立的。</li>
</ul>
<h4 id="6-模式扩展"><a href="#6-模式扩展" class="headerlink" title="(6) 模式扩展"></a>(6) 模式扩展</h4><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p>
<p>重构前代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String cpu;</span><br><span class="line">	<span class="keyword">private</span> String screen;</span><br><span class="line">	<span class="keyword">private</span> String memory;</span><br><span class="line">	<span class="keyword">private</span> String mainboard;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String cpu, String screen, String memory,String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Main &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;intel&quot;</span>,<span class="string">&quot;三星屏幕&quot;</span>,<span class="string">&quot;金士顿&quot;</span>,<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本 就是比较高。</p>
<p>重构后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="comment">// toString()方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Main &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>().Builder()</span><br><span class="line">            .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">            .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">            .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">            .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p>
<h4 id="7-建造者模式对比"><a href="#7-建造者模式对比" class="headerlink" title="(7)建造者模式对比"></a>(7)建造者模式对比</h4><h5 id="①-工厂方法模式VS建造者模式"><a href="#①-工厂方法模式VS建造者模式" class="headerlink" title="① 工厂方法模式VS建造者模式"></a>① 工厂方法模式VS建造者模式</h5><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一 步地精确构造创建出一个复杂的对象。</p>
<p>举一个简单的例子来说，如果要制造一辆汽车，如果使用工厂方法模式，则直接生产出来的是一辆汽车；如果使用建造者模式，则需要组装发动机、轮胎、车框等部分，最后再显示汽车。</p>
<h5 id="②抽象工厂模式VS建造者模式"><a href="#②抽象工厂模式VS建造者模式" class="headerlink" title="②抽象工厂模式VS建造者模式"></a>②抽象工厂模式VS建造者模式</h5><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p>
<p>建造者模式则是要求按照指定的步骤建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组 装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>
<h2 id="第五章-结构型模式"><a href="#第五章-结构型模式" class="headerlink" title="第五章 结构型模式"></a>第五章 结构型模式</h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式， 前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型 模式具有更大的灵活性。</p>
<p>结构型模式分为以下七种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h3 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接 引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生 成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>
<h4 id="2-结构-2"><a href="#2-结构-2" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>代理(Proxy)模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对 象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访 问、控制或扩展真实主题的功能。</li>
</ul>
<h4 id="3-静态代理"><a href="#3-静态代理" class="headerlink" title="(3)静态代理"></a>(3)静态代理</h4><p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420105221092.png" alt="image-20230420105221092"></p>
<p>【SellTickets卖票接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【TrainStation火车站】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【PoroxyPoint代售点】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client】测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<h4 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="(4)动态代理"></a>(4)动态代理</h4><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类 Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法 （newProxyInstance方法）来获取代理对象。</p>
<p>【SellTickets卖票接口】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface SellTickets &#123;</span><br><span class="line">    void sell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【TrainStation火车站】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【ProxyFactory代理工厂】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 声明目标对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">// ClassLoader loader：类加载器，用于加载代理类。通过目标对象获取类加载器</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt;[] interfaces：代理类实现的接口的字节码对象</span></span><br><span class="line">        <span class="comment">// InvocationHandler h：代理对象的调用处理程序</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * invoke方法的参数说明</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 对接口中的方法进行封装的method对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理)&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client】测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">object</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        object.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：ProxyFactory是代理类吗？</p>
</blockquote>
<p>ProxyFactory不是代理模式中所说的代理类，它是一个代理工厂，工厂中提供的一个方法用于获取代理对象。而代理类是在程序运行过程中的动态的在内存中生成的类。</p>
<p>可以通过上述测试类中的<code>object.getClass()</code>获取动态代理类的全限定类名<code>class com.sun.proxy.$Proxy0</code>。</p>
<p>我们通过Arthas工具<code>jad</code>查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="comment">// 该代码剔除了equals()、hashCode()、toString()的代理代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="comment">// 这里的invocationHandler就是我们通过Proxy创建代理对象传入的InvocationHandler实现类对象</span></span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;zal.design.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// catch 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// equals()、hashCode()、toString()方法省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用的其实就是我们之前自定义的invoke方法</span></span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// catch 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代理类($Proxy0)实现了SellTickets接口，也就是说，使用动态代理时，真实类和代理类实现同样的接口。</li>
<li>代理类($Proxy0)将我们提供的匿名内部类对象传递给了父类。</li>
</ul>
<blockquote>
<p>动态代理的执行流程</p>
</blockquote>
<ul>
<li>在测试类中通过代理对象调用sell()方法</li>
<li>根据多态的特性，执行的是代理类($Proxy0)中的sell()方法</li>
<li>代理类($Proxy0)中的sell()方法中又调用了InvocationHandler接口的自实现类对象的invoke方法</li>
<li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li>
</ul>
<h4 id="5-CGLIB动态代理"><a href="#5-CGLIB动态代理" class="headerlink" title="(5)CGLIB动态代理"></a>(5)CGLIB动态代理</h4><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用 了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提 供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>【TrainStation火车站】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【ProxyFactory代理工厂类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>(); <span class="comment">// 真实的代理对象</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Enhancer对象，类似于JDK动态代理的Proxy类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method  真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects  实际参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy  代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-三种代理的对比"><a href="#6-三种代理的对比" class="headerlink" title="(6)三种代理的对比"></a>(6)三种代理的对比</h4><blockquote>
<p>JDK代理和CGLIB代理</p>
</blockquote>
<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在 JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者 方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代 理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率 低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代 理，如果没有接口使用CGLIB代理。</p>
<blockquote>
<p>动态代理和静态代理</p>
</blockquote>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题。</p>
<h4 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="(7)优缺点"></a>(7)优缺点</h4><p>优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了系统的复杂度；</li>
</ul>
<h4 id="8-使用场景"><a href="#8-使用场景" class="headerlink" title="(8)使用场景"></a>(8)使用场景</h4><ul>
<li><p>远程（Remote）代理</p>
<p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中 可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一 个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p>
</li>
<li><p>防火墙（Firewall）代理</p>
<p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
</li>
<li><p>保护（Protect or Access）代理</p>
<p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p>
</li>
</ul>
<h3 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能 一起工作。</p>
<p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现 有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<h4 id="2-结构-3"><a href="#2-结构-3" class="headerlink" title="(2) 结构"></a>(2) 结构</h4><p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成 目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h4 id="3-类适配器模式"><a href="#3-类适配器模式" class="headerlink" title="(3)类适配器模式"></a>(3)类适配器模式</h4><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡 器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420132257875.png" alt="image-20230420132257875"></p>
<p>代码如下：</p>
<p>【SDCard接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【SDCardImpl实现类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Computer电脑类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【TFCard接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【TFCardImpl实现类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【SDAdapterTF适配器类（SD兼容TF）】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Test测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h4 id="4-对象适配器模式"><a href="#4-对象适配器模式" class="headerlink" title="(4)对象适配器模式"></a>(4)对象适配器模式</h4><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420144137548.png" alt="image-20230420144137548"></p>
<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<p>【SDAdapterTF适配器类对象】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard  = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Test测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p>
<h4 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="(5) 应用场景"></a>(5) 应用场景</h4><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h3 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3 装饰者模式"></a>5.3 装饰者模式</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱， 每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<p>使用继承的方式存在的问题：</p>
<ul>
<li><p>扩展性不好</p>
<p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一 个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p>
</li>
<li><p>产生过多的子类</p>
</li>
</ul>
<p>装饰者模式是指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h4 id="2-结构-4"><a href="#2-结构-4" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>装饰（Decorator）模式中的角色：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h4 id="3-案例"><a href="#3-案例" class="headerlink" title="(3)案例"></a>(3)案例</h4><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420145946049.png" alt="image-20230420145946049"></p>
<p>代码：</p>
<p>【FastFood抽象类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>; <span class="comment">// 计算花费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【FriedRice炒饭类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【FriedNoodles炒面类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Garnish配料类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price, desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Egg配料类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">1</span>, <span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Bacon配料类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">2</span>, <span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>(); <span class="comment">// 点一份炒饭</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1); <span class="comment">// 点一份加鸡蛋的炒饭</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2); <span class="comment">// 点一份加培根的炒面</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">炒饭 <span class="number">10.0</span>元</span><br><span class="line">===============</span><br><span class="line">鸡蛋炒饭 <span class="number">11.0</span>元</span><br><span class="line">===============</span><br><span class="line">培根炒面 <span class="number">14.0</span>元</span><br></pre></td></tr></table></figure>

<h4 id="4-优缺点-1"><a href="#4-优缺点-1" class="headerlink" title="(4)优缺点"></a>(4)优缺点</h4><p>优点：</p>
<ul>
<li>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象 来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭 原则，继承是静态的附加责任，装饰者则是动态的附加责任。</li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以 动态扩展一个实现类的功能。</li>
</ul>
<h4 id="5-使用场景-2"><a href="#5-使用场景-2" class="headerlink" title="(5)使用场景"></a>(5)使用场景</h4><ul>
<li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>不能采用继承的情况主要有两类：</p>
<p>① 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目 呈爆炸性增长；</p>
<p>② 第二类是因为类定义不能继承（如final类）</p>
</li>
<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
</li>
<li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
</li>
</ul>
<h4 id="6-实例"><a href="#6-实例" class="headerlink" title="(6)实例"></a>(6)实例</h4><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream， BufferedReader，BufferedWriter。</p>
<p>以BufferedWrite举例来说明，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建BufferedWriter对象</span></span><br><span class="line"><span class="comment">//创建FileWriter对象</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">bw.write(<span class="string">&quot;hello Buffered&quot;</span>);</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>

<p>BufferedWrite使用装饰者模式对Writer打的子实现类进行了增强，添加了缓冲区，提高了读写效率。</p>
<h4 id="7-代理和装饰的区别"><a href="#7-代理和装饰的区别" class="headerlink" title="(7)代理和装饰的区别"></a>(7)代理和装饰的区别</h4><p>静态代理和装饰者模式的区别：</p>
<ul>
<li>相同点：<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
</li>
<li>不同点：<ul>
<li>目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理 是在代理类内部创建，以此来隐藏目标对象</li>
</ul>
</li>
</ul>
<h3 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4 桥接模式"></a>5.4 桥接模式</h3><h4 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的 方式来设计类的关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420152424721.png" alt="image-20230420152424721"></p>
<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>
<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在 一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥 接模式。</p>
<p>桥接模式将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<h4 id="2-结构-5"><a href="#2-结构-5" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法， 并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<h4 id="3-案例-1"><a href="#3-案例-1" class="headerlink" title="(3)案例"></a>(3)案例</h4><p>【例】视频播放器</p>
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420152700702.png" alt="image-20230420152700702"></p>
<p>代码如下：</p>
<p>【VideoFile接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【AVIFile视频类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【REVBBFile视频类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【OperatingSystemVersion操作系统版本抽象类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Windows具体类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Mac具体类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystemVersion</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avi视频文件战狼<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可， 其他类不需要发生变化。</li>
<li>实现细节对客户透明</li>
</ul>
<h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间 建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h3 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5 外观模式"></a>5.5 外观模式</h3><h4 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>外观模式又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420153757080.png" alt="image-20230420153757080"></p>
<h4 id="2-结构-6"><a href="#2-结构-6" class="headerlink" title="(2) 结构"></a>(2) 结构</h4><p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观(Facade)角色：为多个子系统对外提供一个共同的接口</li>
<li>子系统(Sub Systen)角色：实现系统的部分功能，客户可以通过外观角色访问它</li>
</ul>
<h4 id="3-案例-2"><a href="#3-案例-2" class="headerlink" title="(3)案例"></a>(3)案例</h4><p>【例】智能家电控制</p>
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、 关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这 些智能家电的开启和关闭。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420154102146.png" alt="image-20230420154102146"></p>
<p>代码如下：</p>
<p>【Light灯类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【TV电视类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【AirCondition空调类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【SmartAppliancesFacade智能控制类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请再重复一遍&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h4 id="4-使用场景-1"><a href="#4-使用场景-1" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独 立性和可移植性。</li>
</ul>
<h3 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h3><h4 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>组合模式又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对 象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h4 id="2-结构-7"><a href="#2-结构-7" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>组合模式主要包括三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一 个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h4 id="3-案例-3"><a href="#3-案例-3" class="headerlink" title="(3)案例"></a>(3)案例</h4><p>【例】软件菜单</p>
<p>我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单 项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜 单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420205302634.png" alt="image-20230420205302634"></p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420205328209.png" alt="image-20230420205328209"></p>
<p>代码如下：</p>
<p>【MenuComponent菜单组件类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="comment">// 添加菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取指定的子菜单</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取菜单名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和 MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说， Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不 应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>
<p>【Menu菜单类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent m : menuComponentList) &#123;</span><br><span class="line">            m.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Menu菜单类实现除了getName方法之外的其他所有方法，因为Menu菜单类具有添加菜单项、移除菜单项和获取子菜单的功能。</p>
<p>【MenuItem菜单项】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;学习&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">MenuItem</span> <span class="variable">java</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;java&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">MenuItem</span> <span class="variable">jdk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;jdk&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">MenuItem</span> <span class="variable">jre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;jre&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        menu.add(java);</span><br><span class="line">        menu.add(jdk);</span><br><span class="line">        menu.add(jre);</span><br><span class="line">        menu.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学习</span><br><span class="line">--java</span><br><span class="line">----jdk</span><br><span class="line">----jre</span><br></pre></td></tr></table></figure>

<h4 id="4-分类"><a href="#4-分类" class="headerlink" title="(4)分类"></a>(4)分类</h4><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式 两种形式。</p>
<blockquote>
<p>透明组合模式</p>
</blockquote>
<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add 、 remove 、 getChild 方法，这样做的好处是确保所有的构件 类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能 有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有 意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应 的错误处理代码）</p>
<blockquote>
<p>安全组合模式</p>
</blockquote>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420211052288.png" alt="image-20230420211052288"></p>
<h4 id="5-优点"><a href="#5-优点" class="headerlink" title="(5)优点"></a>(5)优点</h4><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结 构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭 原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归 组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<h4 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="(6)应用场景"></a>(6)应用场景</h4><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显 示，多级目录呈现等树形结构数据的操作。</p>
<h3 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h3><h4 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建 的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h4 id="2-结构-8"><a href="#2-结构-8" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>享元（Flyweight ）模式中存在以下两种状态：</p>
<ul>
<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法 来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元 类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享 元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元 对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在 的话，则创建一个新的享元对象。</li>
</ul>
<h4 id="3-案例-4"><a href="#3-案例-4" class="headerlink" title="(3)案例"></a>(3)案例</h4><p>【例】俄罗斯方块</p>
<p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块 都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420211510517.png" alt="image-20230420211510517"></p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420211528901.png" alt="image-20230420211528901"></p>
<p>代码如下：</p>
<p>【AbstractBox抽象方块类】</p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot;颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体方块类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【方块工厂类】</p>
<p>提供一个方块工厂类，用来管理享元对象(也就是AbstractBox子类对象)，该工厂类对象只需要一个，所以可以使用单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后如果我们想要生产一个具体的方块，比如L形方块，我们就可以直接调用<code>BoxFactory.getInstance()</code>获取工厂，通过工厂获取指定的方块实例，并且多次调用返回的是一个实例。</p>
<h4 id="4-优缺点-2"><a href="#4-优缺点-2" class="headerlink" title="(4)优缺点"></a>(4)优缺点</h4><p>优点：</p>
<ul>
<li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态</li>
</ul>
<p>缺点：</p>
<ul>
<li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</li>
</ul>
<h2 id="第六章-行为型模式"><a href="#第六章-行为型模式" class="headerlink" title="第六章 行为型模式"></a>第六章 行为型模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单 个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚 合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象 行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>职责链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ul>
<p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为模式，其他全部属于对象行为型模式。</p>
<h3 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1 模板方法模式"></a>6.1 模板方法模式</h3><h4 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>模板方法模式定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情 况下重定义该算法的某些特定步骤。</p>
<h4 id="2-结构-9"><a href="#2-结构-9" class="headerlink" title="(2)结构"></a>(2)结构</h4><p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。<ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三 种：<ul>
<li>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</li>
<li>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现， 其子类可以进行覆盖也可以直接继承。</li>
<li>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ul>
</li>
<li>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</li>
</ul>
<h4 id="3-案例-5"><a href="#3-案例-5" class="headerlink" title="(3) 案例"></a>(3) 案例</h4><p>【例】炒菜</p>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230420213555698.png" alt="image-20230420213555698"></p>
<p>代码如下：</p>
<p>【AbstractClass抽象模板类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一步，倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">// 第二步，热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">// 第三步，倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">// 第四步，倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">// 第五步，翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：倒油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【炒菜具体子类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止恶意操作，一般模板方法上都加上final关键字。</p>
<h4 id="4-优缺点-3"><a href="#4-优缺点-3" class="headerlink" title="(4)优缺点"></a>(4)优缺点</h4><p>优点：</p>
<ul>
<li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</li>
<li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽 象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构， 它提高了代码阅读的难度。</li>
</ul>
<h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="(5)适用场景"></a>(5)适用场景</h4><ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分 抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h3 id="6-2-策略模式"><a href="#6-2-策略模式" class="headerlink" title="6.2 策略模式"></a>6.2 策略模式</h3><p>策略模式该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h4 id="1-结构"><a href="#1-结构" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h4 id="2-案例"><a href="#2-案例" class="headerlink" title="(2)案例"></a>(2)案例</h4><p>【例】促销活动</p>
<p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动， 由促销员将促销活动展示给客户。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421090653525.png" alt="image-20230421090653525"></p>
<p>代码如下：</p>
<p>【Strategy共同促销策略接口】所有促销活动的共同接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体策略角色】每个节日具体的促销活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200减50&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【环境角色】用于连接上下文，即把促销活动推销给用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>策略类之间可以相互切换。由于策略类都实现同一个接口，所以使它们之间可以自由切换。</li>
<li>易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则。</li>
<li>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</li>
</ul>
<p>缺点：</p>
<ul>
<li>客户端必须知道所有的策略类，并决定使用哪一个策略类。</li>
<li>策略模式将产生很多的策略类，可以使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="(4)适用场景"></a>(4)适用场景</h4><ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条 件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结 构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<h3 id="6-3-命令模式"><a href="#6-3-命令模式" class="headerlink" title="6.3 命令模式"></a>6.3 命令模式</h3><p>命令模式将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<h4 id="1-结构-1"><a href="#1-结构-1" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调 用接收者的功能来完成命令要执行的操作。</li>
<li>实现者&#x2F;接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者&#x2F;请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很 多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用 命令对象的入口。</li>
</ul>
<h4 id="2-案例实现"><a href="#2-案例实现" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【点餐场景】</p>
<p>顾客把订单交给服务员，服务员拿到订单给厨师下达命令。厨师根据订单准备餐。</p>
<p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<ul>
<li>服务员：调用者角色，发起命令的角色。</li>
<li>厨师：接收者角色，真正执行命令的角色。</li>
<li>订单：命令中包含的订单。</li>
</ul>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421092720445.png" alt="image-20230421092720445"></p>
<p>【Command抽象命令类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>; <span class="comment">// 统一的执行方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【OrderCommand具体命令类】将命令执行者和命令封装到一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SeniorChef seniorChef;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef seniorChef, Order order)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seniorChef = seniorChef;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            seniorChef.makeFood(order.getFoodDic().get(s), s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;出餐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Order具体命令执行类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable; <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 存储餐名 并且 记录份数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【SeniorChef命令执行者】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num, String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Waiter命令传递者】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waiter</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommands</span><span class="params">(Command cmd)</span> &#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单来了~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        o1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        o1.setFoodDic(<span class="string">&quot;西红柿鸡蛋面&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        o2.setDiningTable(<span class="number">2</span>);</span><br><span class="line">        o2.getFoodDic().put(<span class="string">&quot;可乐&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        o2.getFoodDic().put(<span class="string">&quot;炒米&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建命令接收者</span></span><br><span class="line">        <span class="type">SeniorChef</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">// 将订单和接收者封装成对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, o1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, o2);</span><br><span class="line">        <span class="comment">// 创建调用者</span></span><br><span class="line">        <span class="type">Waiter</span> <span class="variable">waiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waiter</span>();</span><br><span class="line">        waiter.setCommands(cmd1);</span><br><span class="line">        waiter.setCommands(cmd2);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        waiter.orderUp();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p>优点：</p>
<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”， 对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更加复杂。</li>
</ul>
<h4 id="4-适用场景-1"><a href="#4-适用场景-1" class="headerlink" title="(4)适用场景"></a>(4)适用场景</h4><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
</ul>
<h4 id="5-Runnable应用"><a href="#5-Runnable应用" class="headerlink" title="(5)Runnable应用"></a>(5)Runnable应用</h4><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就 是其执行方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>会调用一个native方法start0()，调用系统方法，开启一个线程。而接收者是对程序员开放的，可以 自己定义接收者。</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOFF</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行具体方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOffThread</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.turnOFF();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();</span><br><span class="line">        <span class="type">TurnOffThread</span> <span class="variable">turnOffThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOffThread</span>(receiver);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(turnOffThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4 责任链模式"></a>6.4 责任链模式</h3><p>责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对 象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<h4 id="1-结构-2"><a href="#1-结构-2" class="headerlink" title="(1) 结构"></a>(1) 结构</h4><p>职责链模式主要包含以下角色：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请 求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节 和请求的传递过程。</li>
</ul>
<h4 id="2-案例实现-1"><a href="#2-案例实现-1" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需 要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421113050665.png" alt="image-20230421113050665"></p>
<p>代码如下：</p>
<p>【LeaveRequest请假条实例类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num; <span class="comment">// 请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content; <span class="comment">// 请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Handler抽象审批类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.numStart == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (leave.getNum() &gt;= <span class="built_in">this</span>.numStart) &#123;</span><br><span class="line">            <span class="comment">// 如果请假天数达到该领导者的处理要求</span></span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd) &#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体审批类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天，&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天，&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">11</span>, <span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>(); <span class="comment">// 小组长</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(); <span class="comment">// 部门经理</span></span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>(); <span class="comment">// 总经理</span></span><br><span class="line">        groupLeader.setNextHandler(manager); <span class="comment">// 小组长的上级是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager); <span class="comment">// 部门经理的上级是总经理</span></span><br><span class="line">        groupLeader.submit(leave); <span class="comment">// 提交请假申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="(3) 优缺点"></a>(3) 优缺点</h4><p>优点：</p>
<ul>
<li>降低了对象之间的耦合度。该模式降低了请求发送者和接收者的耦合度。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多 的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围， 符合类的单一职责原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理， 该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而 导致系统出错，如可能会造成循环调用。</li>
</ul>
<h3 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一 种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进 行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421160830691.png" alt="image-20230421160830691"></p>
<p>代码如下：</p>
<p>【ILift状态接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILift</span> &#123;</span><br><span class="line">    <span class="comment">// 电梯的四个状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">OPENING_STATE</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 开门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">CLOSING_STATE</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 关门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RUNNING_STATE</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STOPPING_STATE</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 停止状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置电梯的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 电梯的动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Lift电梯实例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lift</span> <span class="keyword">implements</span> <span class="title class_">ILift</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 如果已经是开门状态，就什么也不做</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门已打开&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 运行时电梯无法开门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门打开了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门已关闭&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(CLOSING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 运行时电梯门已经是关闭的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">// 停止时电梯门也是关闭的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 电梯门不能打开着运行</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯可以开始运行了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">// 已经是运行状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                <span class="comment">// 开门的电梯已经是停止的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lift</span> <span class="variable">lift</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lift</span>();</span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);</span><br><span class="line">        lift.open();</span><br><span class="line">        lift.close();</span><br><span class="line">        lift.run();</span><br><span class="line">        lift.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：</p>
<ul>
<li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li>
<li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li>
</ul>
<p>状态模式对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变 时改变其行为。</p>
<h4 id="1-结构-3"><a href="#1-结构-3" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>状态模式包含以下主要角色。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并 将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li>
</ul>
<h4 id="2-案例实现-2"><a href="#2-案例实现-2" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421163807465.png" alt="image-20230421163807465"></p>
<p>代码如下：</p>
<p>【LiftState抽象状态类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个环境角色，也就是封装状态的变化引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 电梯开门动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 电梯关门动动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 电梯运行动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 电梯停止动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体状态类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门开启&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">// 动作委托为CloseState来执行，也就是委托给ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开门状态下不能运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开门状态下电梯已经停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="built_in">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="built_in">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 运行的时候不能打开电梯门</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 运行的时候电梯门已经是关闭的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 停止状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="built_in">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="built_in">super</span>.context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="built_in">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯已经停止运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Context环境角色类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OpenningState</span> <span class="variable">openningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenningState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">CloseingState</span> <span class="variable">closeingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloseingState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">RunningState</span> <span class="variable">runningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunningState</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StoppingState</span> <span class="variable">stoppingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoppingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState; <span class="comment">// 定义一个当前电梯的状态</span></span><br><span class="line">    <span class="keyword">public</span> LiftState <span class="title function_">getLiftState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.liftState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLiftState</span><span class="params">(LiftState liftState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState = liftState; <span class="comment">// 当前环境改变</span></span><br><span class="line">        <span class="built_in">this</span>.liftState.setContext(<span class="built_in">this</span>); <span class="comment">// 把当前的环境通知到各个实现类中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> <span class="title class_">CloseingState</span>());</span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态 即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
</ul>
<p>缺点：</p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好。</li>
</ul>
<h4 id="4-使用场景-2"><a href="#4-使用场景-2" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h3 id="6-6-观察者模式"><a href="#6-6-观察者模式" class="headerlink" title="6.6 观察者模式"></a>6.6 观察者模式</h3><p>观察者模式又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者 对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自 动更新自己。</p>
<h4 id="1-结构-4"><a href="#1-结构-4" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知 时更新自身的状态。</li>
</ul>
<h4 id="2-案例实现-3"><a href="#2-案例实现-3" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【例】微信公众号</p>
<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421170441696.png" alt="image-20230421170441696"></p>
<p>代码如下：</p>
<p>【Observer抽象观察者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WeiXinUser具体观察者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiXinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeiXinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Subject抽象主题类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>; <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>; <span class="comment">// 删除订阅着</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>; <span class="comment">// 通知订阅者更新消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【SubscriptionSubject具体主题类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        userList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        userList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : userList) &#123;</span><br><span class="line">            o.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SubscriptionSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>(); <span class="comment">// 具体主题实例 </span></span><br><span class="line">        <span class="type">WeiXinUser</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">&quot;小红&quot;</span>); <span class="comment">// 具体观察者实例 </span></span><br><span class="line">        <span class="type">WeiXinUser</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="type">WeiXinUser</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeiXinUser</span>(<span class="string">&quot;小军&quot;</span>);</span><br><span class="line">        subject.attach(u1); <span class="comment">// 观察者订阅具体主题</span></span><br><span class="line">        subject.attach(u2); </span><br><span class="line">        subject.attach(u3);</span><br><span class="line"></span><br><span class="line">        subject.notify(<span class="string">&quot;Java专栏更新啦 &quot;</span>); <span class="comment">// 发布通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-4"><a href="#3-优缺点-4" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li>
</ul>
<h4 id="4-使用场景-3"><a href="#4-使用场景-3" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h4 id="5-JDK中提供的实现"><a href="#5-JDK中提供的实现" class="headerlink" title="(5)JDK中提供的实现"></a>(5)JDK中提供的实现</h4><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer </code>接口定义了观察者模 式，只要实现它们的子类就可以编写观察者模式实例。</p>
<blockquote>
<p>Observable类</p>
</blockquote>
<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通 知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ul>
<li><code>void addObserver(Observer o) </code>方法：用于将新的观察者对象添加到集合中。</li>
<li><code> void notifyObservers(Object arg)</code> 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</li>
<li><code>void setChange() </code>方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变 化。当它为true时，notifyObservers() 才会通知观察者。</li>
</ul>
<blockquote>
<p>Observer接口</p>
</blockquote>
<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知， 并调用 update 方法，进行相应的工作。</p>
<p>【例】警察抓小偷</p>
<p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下： </p>
<p>小偷是一个被观察者，所以需要继承Observable类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小偷：偷东西了，&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged(); <span class="comment">// changed = true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers(); <span class="comment">// 通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>警察是一个观察者，所以需要让其实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policemen</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policemen</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief)o).getName() + <span class="string">&quot;, 已经盯着你很久了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thief</span> <span class="variable">thief</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">&quot;小小偷&quot;</span>);</span><br><span class="line">        <span class="type">Policemen</span> <span class="variable">policemen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policemen</span>(<span class="string">&quot;好警察&quot;</span>);</span><br><span class="line">        thief.addObserver(policemen); <span class="comment">// 添加观察者</span></span><br><span class="line">        thief.steal(); <span class="comment">// 偷东西</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-中介模式"><a href="#6-7-中介模式" class="headerlink" title="6.7 中介模式"></a>6.7 中介模式</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复 杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同 事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个 对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变 动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对 象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421173239751.png" alt="image-20230421173239751"></p>
<p>中介模式又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以 独立地改变它们之间的交互。</p>
<h4 id="1-结构-5"><a href="#1-结构-5" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>中介者模式包含以下主要角色：</p>
<ul>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽 象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交 互时，由中介者对象负责后续的交互。</li>
</ul>
<h4 id="2-案例实现-4"><a href="#2-案例实现-4" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【例】租房</p>
<p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421173555709.png" alt="image-20230421173555709"></p>
<p>代码如下：</p>
<p>【Mediator抽象中介者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">// 申明一个联络方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message, Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Person抽象同事类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【HouseOwner具体同事类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 房屋拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与中介联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房主&quot;</span> + name + <span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 房屋租赁者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tenant</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与中介者联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租房者&quot;</span> + name + <span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【MediatorStructure具体中介类】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MediatorStructure extends Mediator&#123;</span><br><span class="line">    private HouseOwner houseOwner;</span><br><span class="line">    private Tenant tenant;</span><br><span class="line">	// getter and setter</span><br><span class="line">    @Override</span><br><span class="line">    public void constact(String message, Person person) &#123;</span><br><span class="line">        if (person == houseOwner) &#123;</span><br><span class="line">            // 如果是房主，则租户获得信息</span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则是房主获得信息</span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Client测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MediatorStructure</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediatorStructure</span>();<span class="comment">// 中介</span></span><br><span class="line">        <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>(<span class="string">&quot;张三&quot;</span>, mediator);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tenant</span>(<span class="string">&quot;李四&quot;</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介要知道 房主和租客</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">&quot;需要租三室一厅的房子&quot;</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">&quot;我这有适合的房源，可以商量一下吗 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-5"><a href="#3-优缺点-5" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>松散耦合。中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦 合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样 “牵一处而动全身”了。</li>
<li>集中控制交互。多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只 需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事 类不需要做修改。</li>
<li>一对多关联转变为一对一的关联。没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
</ul>
<h4 id="4-使用场景-4"><a href="#4-使用场景-4" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h3 id="6-8-迭代器模式"><a href="#6-8-迭代器模式" class="headerlink" title="6.8 迭代器模式"></a>6.8 迭代器模式</h3><p>迭代器模式提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<h4 id="1-结构-6"><a href="#1-结构-6" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>迭代器模式主要包含以下角色：</p>
<ul>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、 next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对 象的遍历，记录遍历的当前位置。</li>
</ul>
<h4 id="2-案例-1"><a href="#2-案例-1" class="headerlink" title="(2)案例"></a>(2)案例</h4><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421183609177.png" alt="image-20230421183609177"></p>
<p>代码如下：</p>
<p>【迭代器接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体的迭代器类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">cur</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【抽象容器类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体容器类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StudentAggregateImpl</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentAggregateImpl</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        aggregate.addStudent(s1);</span><br><span class="line">        aggregate.addStudent(s2);</span><br><span class="line">        aggregate.addStudent(s3);</span><br><span class="line">        <span class="type">StudentIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.getStudentIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-6"><a href="#3-优缺点-6" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模 式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方 法，这样可以简化聚合类的设计。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码， 满足 “开闭原则” 的要求。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li>
</ul>
<h4 id="4-适用场景-2"><a href="#4-适用场景-2" class="headerlink" title="(4)适用场景"></a>(4)适用场景</h4><ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h4 id="5-集合源码应用"><a href="#5-集合源码应用" class="headerlink" title="(5)集合源码应用"></a>(5)集合源码应用</h4><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); </span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以 ArrayList举例来说明</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回的是实现了 Iterator 接口的具体迭代器对象</li>
</ul>
<h3 id="6-9-访问者模式"><a href="#6-9-访问者模式" class="headerlink" title="6.9 访问者模式"></a>6.9 访问者模式</h3><p>访问者模式封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这 些元素的新的操作。</p>
<h4 id="1-结构-7"><a href="#1-结构-7" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>访问者模式包含以下主要角色：</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素 （Element） 访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li>
<li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（ accept ），其意义是指，每一个元素都要可以被访问者访问。</li>
<li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通 常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表 述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素 （ Element ），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<h4 id="2-案例实现-5"><a href="#2-案例实现-5" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【例】给宠物喂食</p>
<p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。 </p>
<ul>
<li>访问者角色：给宠物喂食的人 </li>
<li>具体访问者角色：主人、其他人 </li>
<li>抽象元素角色：动物抽象类 </li>
<li>具体元素角色：宠物狗、宠物猫 </li>
<li>结构对象角色：主人家</li>
</ul>
<p>类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421232019551.png" alt="image-20230421232019551"></p>
<p>代码如下：</p>
<p>【抽象访问者接口】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体访问者实例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【抽象节点】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【具体节点】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好吃，汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好吃，喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【对象结构】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal a : nodeList) &#123;</span><br><span class="line">            a.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-7"><a href="#3-优缺点-7" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>扩展性好。在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</li>
<li>分离无关行为。通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的 功能都比较单一。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对象结构变化很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这 违背了“开闭原则”。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ul>
<h4 id="4-使用场景-5"><a href="#4-使用场景-5" class="headerlink" title="(4)使用场景"></a>(4)使用场景</h4><ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
</ul>
<h4 id="5-扩展"><a href="#5-扩展" class="headerlink" title="(5)扩展"></a>(5)扩展</h4><p>访问者模式用到了一种双分派的技术。</p>
<h5 id="①-分派"><a href="#①-分派" class="headerlink" title="① 分派"></a>① 分派</h5><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的 真实类型又叫做变量的实际类型。比如<code> Map map = new HashMap()</code> ，map变量的静态类型是 Map ，实际类型是 HashMap 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派 (Dispatch)又分为两种，即静态分派和动态分派。</p>
<p>静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来 说并不陌生，方法重载就是静态分派。</p>
<p>动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p>
<h5 id="②-动态分派"><a href="#②-动态分派" class="headerlink" title="② 动态分派"></a>② 动态分派</h5><p>通过方法的重写支持动态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.execute();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写，运行执行的子类中的方法。Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不 知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>
<h5 id="③-静态分派"><a href="#③-静态分派" class="headerlink" title="③ 静态分派"></a>③ 静态分派</h5><p>通过方法重载支持静态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        exe.execute(a);</span><br><span class="line">        exe.execute(a1);</span><br><span class="line">        exe.execute(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果为：</span><br><span class="line">    Animal</span><br><span class="line">    Animal</span><br><span class="line">    Animal</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？因为重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</p>
<h5 id="④-双分派"><a href="#④-双分派" class="headerlink" title="④ 双分派"></a>④ 双分派</h5><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别， 还要根据参数的运行时区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">    	exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">    	exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">    	exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        a.accept(exe);</span><br><span class="line">        d.accept(exe);</span><br><span class="line">        c.accept(exe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也 将自己this作为参 数传递进去，这里就完成了第二次分派，这里的Execute类中有多个重载的方法，而传递进行的是this， 就是具体的实际类型的对象。</p>
<p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定， 我们可以对上面的程序进行修改。</p>
<p>上述案例的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal</span><br><span class="line">dog</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>

<p>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动 态的，所以重载就是动态的了。</p>
<h3 id="6-10-备忘录模式"><a href="#6-10-备忘录模式" class="headerlink" title="6.10 备忘录模式"></a>6.10 备忘录模式</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销 （Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销 当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩 游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p>备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态， 以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<h4 id="1-结构-8"><a href="#1-结构-8" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据 的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备 忘录的内容进行访问与修改。</li>
</ul>
<p>备忘录有两个等效的接口： </p>
<ul>
<li>窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。 </li>
<li>宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
<h4 id="2-案例实现-6"><a href="#2-案例实现-6" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【例】游戏挑战BOSS</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>要实现上述案例，有两种方式：</p>
<ul>
<li>“白箱”备忘录模式</li>
<li>“黑箱”备忘录模式</li>
</ul>
<h5 id="①-白箱备忘录模式"><a href="#①-白箱备忘录模式" class="headerlink" title="① 白箱备忘录模式"></a>① 白箱备忘录模式</h5><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公 开。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230421235332827.png" alt="image-20230421235332827"></p>
<p>【游戏角色类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【游戏状态备忘类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【角色状态管理者类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;------------大战Boss前------------&quot;);</span><br><span class="line">        //大战Boss前</span><br><span class="line">        GameRole gameRole = new GameRole();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        //保存进度</span><br><span class="line">        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line">        System.out.println(&quot;------------大战Boss后------------&quot;);</span><br><span class="line">        //大战Boss时，损耗严重</span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(&quot;------------恢复之前状态------------&quot;);</span><br><span class="line">        //恢复之前状态</span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式 的大部分用意。</p>
<h5 id="②-黑箱备忘录模式"><a href="#②-黑箱备忘录模式" class="headerlink" title="② 黑箱备忘录模式"></a>② 黑箱备忘录模式</h5><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类。</p>
<p>将 RoleStateMemento 设为 GameRole 的内部类，从而将 RoleStateMemento 对象封装在 GameRole 里面；在外面提供一个标识接口 Memento 给 RoleStateCaretaker 及其他对象使用。 这样 GameRole 类看到的是 RoleStateMemento 所有的接口，而 RoleStateCaretaker 及其他对 象看到的仅仅是标识接口 Memento 所暴露出来的接口，从而维护了封装型。类图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230422000506856.png" alt="image-20230422000506856"></p>
<p>代码如下：</p>
<p>【窄接口 Memento】作为一个标识接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memento</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>【发起人类 GameRole】在内部定义备忘录内部类 RoleStateMemento （该内部类设置为私有的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zal.design;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="type">RoleStateMemento</span> <span class="variable">roleStateMemento</span> <span class="operator">=</span> (RoleStateMemento) memento;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// getter and setter</span></span><br><span class="line">   	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title class_">Memento</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getter and setter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【负责人角色类 RoleStateCaretaker】</p>
<p>负责人角色类 RoleStateCaretaker 能够得到的备忘录对象是以 Memento 为接口的，由于这个接 口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">	<span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-8"><a href="#3-优缺点-8" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 </li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 </li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录 中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<h4 id="4-适用场景-3"><a href="#4-适用场景-3" class="headerlink" title="(4)适用场景"></a>(4)适用场景</h4><ul>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。 </li>
<li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ul>
<h3 id="6-11-解释器模式"><a href="#6-11-解释器模式" class="headerlink" title="6.11 解释器模式"></a>6.11 解释器模式</h3><p>【例】设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工 具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于n个整数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Integer ... arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">    	sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。</p>
<p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p>
<blockquote>
<p>文法（语法）规则</p>
</blockquote>
<p>文法是用于描述语言的语法结构的形式规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expression ::= value | plus | minus</span><br><span class="line">plus ::= expression ‘+’ expression</span><br><span class="line">minus ::= expression ‘-’ expression</span><br><span class="line">value ::= integer</span><br></pre></td></tr></table></figure>

<p>注意： 这里的符号“::&#x3D;”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字 符本身，引号外为语法。</p>
<p>上面规则描述为 ：</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构 成，值的类型为整型数。</p>
<blockquote>
<p>抽象语法树</p>
</blockquote>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree）， 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示 源代码中的一种结构。</p>
<p>用树形来表示符合文法规则的句子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230422001805564.png" alt="image-20230422001805564"></p>
<h4 id="1-结构-9"><a href="#1-结构-9" class="headerlink" title="(1)结构"></a>(1)结构</h4><p>解释器模式包含以下主要角色。</p>
<ul>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法 中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有 解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ul>
<h4 id="2-案例实现-7"><a href="#2-案例实现-7" class="headerlink" title="(2)案例实现"></a>(2)案例实现</h4><p>【例】设计实现加减法的软件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230422001936036.png" alt="image-20230422001936036"></p>
<p>代码如下：</p>
<p>【AbstractExpression抽象表达式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Value终结符表达式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Value</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Value</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【plus、Minus非终结符表达式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; + &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minus</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Minus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; - &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Variable终结符表达式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> <span class="keyword">extends</span> <span class="title class_">AbstractExpression</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Variable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.getValue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Context环境类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Variable, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> &#123;</span><br><span class="line">        map.put(<span class="keyword">var</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【测试类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="type">Variable</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//Value v = new Value(1);</span></span><br><span class="line">        context.assign(a, <span class="number">1</span>);</span><br><span class="line">        context.assign(b, <span class="number">2</span>);</span><br><span class="line">        context.assign(c, <span class="number">3</span>);</span><br><span class="line">        context.assign(d, <span class="number">4</span>);</span><br><span class="line">        context.assign(e, <span class="number">5</span>);</span><br><span class="line">        <span class="type">AbstractExpression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Minus</span>(<span class="keyword">new</span> <span class="title class_">Plus</span>(<span class="keyword">new</span> <span class="title class_">Plus</span>(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">Plus</span>(a, b), c), d), e);</span><br><span class="line">        System.out.println(expression + <span class="string">&quot;= &quot;</span> +</span><br><span class="line">                expression.interpret(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印结果：</span><br><span class="line">	((((a + b) + c) + d) - e)= <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-优缺点-9"><a href="#3-优缺点-9" class="headerlink" title="(3)优缺点"></a>(3)优缺点</h4><p>优点：</p>
<ul>
<li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</li>
<li>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</li>
<li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原 有表达式类代码无须修改，符合 “开闭原则”。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个 数将会急剧增加，导致系统难以管理和维护。</li>
<li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而 且代码的调试过程也比较麻烦。</li>
</ul>
<h4 id="4-适用场景-4"><a href="#4-适用场景-4" class="headerlink" title="(4)适用场景"></a>(4)适用场景</h4><ul>
<li>当语言的文法较为简单，且执行效率不是关键问题时。 </li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。 </li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小奥</div><div class="post-copyright__author_desc">浮生若梦 为欢几何</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/')">设计模式</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=设计模式&amp;url=http://example.com/2023/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/&amp;pic=/img/png/12.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小奥</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>设计模式<span class="categoryesPageCount">1</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>设计模式<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/png/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/25/MySQL%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL联合索引最左匹配原则详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">Java、数据库、中间件</b>相关的学习笔记，还有<b style="color:#fff">面试题总结</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小奥</h1><div class="author-info__desc">浮生若梦 为欢几何</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoaozz" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 设计模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-UML%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 UML图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%9B%BE%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 类图概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B1%BB%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 类图的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 类图表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">(1)类的表示方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">(2)类与类之间关系的表示方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0-%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94"><span class="toc-number">1.2.3.2.1.1.</span> <span class="toc-text">① 单向关联</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94"><span class="toc-number">1.2.3.2.1.2.</span> <span class="toc-text">② 双向关联</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2-%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">1.2.3.2.1.3.</span> <span class="toc-text">③ 自关联</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">聚合关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">组合关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.4.</span> <span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.5.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.2.6.</span> <span class="toc-text">实现关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1开闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2里氏代换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3依赖倒转原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 迪米特法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E6%B3%95%E5%88%99"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 合成复用法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 创建者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">(1)创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">①饿汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">②懒汉式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">③双重检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.4.1.1.4.</span> <span class="toc-text">④静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E6%9E%9A%E4%B8%BE-%E6%81%B6%E6%B1%89%E5%BC%8F"><span class="toc-number">1.4.1.1.5.</span> <span class="toc-text">⑤枚举(恶汉式)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">(2)存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">① 序列化破坏单例模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">②反射破坏单例模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">(3)问题的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.1.3.1.</span> <span class="toc-text">① 序列化、反序列化方式破坏单例模式的解决</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">1.4.1.3.2.</span> <span class="toc-text">② 反射破坏单例模式的解决</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E4%BE%8B%E5%BA%94%E7%94%A8-Runtime%E7%B1%BB"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">(4)(单例应用)Runtime类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">(2)简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">①结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">② 实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.2.2.3.</span> <span class="toc-text">③ 扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.2.4.</span> <span class="toc-text">④优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">(3)工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">①结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">②实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.3.3.</span> <span class="toc-text">③优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">(3)抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">①概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">②结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.4.3.</span> <span class="toc-text">③实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.4.2.4.4.</span> <span class="toc-text">③优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">(5)模式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E9%99%A4%E8%80%A6%E5%90%88"><span class="toc-number">1.4.2.5.1.</span> <span class="toc-text">① 简单工厂+配置文件解除耦合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B7%A5%E5%8E%82%E5%BA%94%E7%94%A8-Collection-iterator%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">(6)(工厂应用)Collection.iterator方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">(3)实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">(4)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">(5)使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%89%A9%E5%B1%95-%E6%B7%B1%E5%85%8B%E9%9A%86"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">(6)扩展(深克隆)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">(3)实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">(4)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">(5)使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">(6) 模式扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">(7)建造者模式对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FVS%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.7.1.</span> <span class="toc-text">① 工厂方法模式VS建造者模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FVS%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.7.2.</span> <span class="toc-text">②抽象工厂模式VS建造者模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">第五章 结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-3"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">(3)静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">(4)动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">(5)CGLIB动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">(6)三种代理的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">(7)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.1.8.</span> <span class="toc-text">(8)使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-4"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-3"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">(2) 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">(3)类适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">(4)对象适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">(5) 应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-5"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-4"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">(3)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">(4)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">(5)使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">(6)实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%A3%E7%90%86%E5%92%8C%E8%A3%85%E9%A5%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">(7)代理和装饰的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-6"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-5"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">(3)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">(4)使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-7"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-6"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">(2) 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B-2"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">(3)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">(4)使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-8"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-7"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B-3"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">(3)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">(4)分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">(5)优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">(6)应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-9"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-8"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B-4"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">(3)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">(4)优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">第六章 行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-10"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">(1)概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84-9"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">(2)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B-5"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">(3) 案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">(4)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">(5)适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">(2)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">(4)适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">(3) 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">(4)适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Runnable%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">(5)Runnable应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 责任链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">(1) 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">(3) 优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-3"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">(4)使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-4"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">(4)使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JDK%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">(5)JDK中提供的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7 中介模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-5"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="toc-number">1.6.7.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.6.7.4.</span> <span class="toc-text">(4)使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.8.</span> <span class="toc-text">6.8 迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-6"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">(2)案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.6.8.4.</span> <span class="toc-text">(4)适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.8.5.</span> <span class="toc-text">(5)集合源码应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.9.</span> <span class="toc-text">6.9 访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-7"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-7"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">1.6.9.4.</span> <span class="toc-text">(4)使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%A9%E5%B1%95"><span class="toc-number">1.6.9.5.</span> <span class="toc-text">(5)扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%88%86%E6%B4%BE"><span class="toc-number">1.6.9.5.1.</span> <span class="toc-text">① 分派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE"><span class="toc-number">1.6.9.5.2.</span> <span class="toc-text">② 动态分派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE"><span class="toc-number">1.6.9.5.3.</span> <span class="toc-text">③ 静态分派</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E5%8F%8C%E5%88%86%E6%B4%BE"><span class="toc-number">1.6.9.5.4.</span> <span class="toc-text">④ 双分派</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.10.</span> <span class="toc-text">6.10 备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-8"><span class="toc-number">1.6.10.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">1.6.10.2.</span> <span class="toc-text">(2)案例实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%99%BD%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.10.2.1.</span> <span class="toc-text">① 白箱备忘录模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E9%BB%91%E7%AE%B1%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.10.2.2.</span> <span class="toc-text">② 黑箱备忘录模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-8"><span class="toc-number">1.6.10.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.6.10.4.</span> <span class="toc-text">(4)适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.11.</span> <span class="toc-text">6.11 解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84-9"><span class="toc-number">1.6.11.1.</span> <span class="toc-text">(1)结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">1.6.11.2.</span> <span class="toc-text">(2)案例实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E7%BC%BA%E7%82%B9-9"><span class="toc-number">1.6.11.3.</span> <span class="toc-text">(3)优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.6.11.4.</span> <span class="toc-text">(4)适用场景</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/25/MySQL%E4%B9%8BACID%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="MySQL之ACID实现原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL之ACID实现原理"/></a><div class="content"><a class="title" href="/2024/03/25/MySQL%E4%B9%8BACID%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="MySQL之ACID实现原理">MySQL之ACID实现原理</a><time datetime="2024-03-25T07:52:05.000Z" title="发表于 2024-03-25 15:52:05">2024-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/24/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E7%AF%87/" title="Spring之事务原理篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring之事务原理篇"/></a><div class="content"><a class="title" href="/2024/03/24/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E7%AF%87/" title="Spring之事务原理篇">Spring之事务原理篇</a><time datetime="2024-03-24T09:54:42.000Z" title="发表于 2024-03-24 17:54:42">2024-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/Spring%E4%B9%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%8B%E5%8A%A1/" title="Spring之如何选择事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring之如何选择事务"/></a><div class="content"><a class="title" href="/2024/03/15/Spring%E4%B9%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%8B%E5%8A%A1/" title="Spring之如何选择事务">Spring之如何选择事务</a><time datetime="2024-03-15T11:31:48.000Z" title="发表于 2024-03-15 19:31:48">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/JVM%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%92%8C%E8%A7%A3%E5%86%B3Full-GC/" title="JVM之认识和解决Full GC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/17.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之认识和解决Full GC"/></a><div class="content"><a class="title" href="/2024/03/09/JVM%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%92%8C%E8%A7%A3%E5%86%B3Full-GC/" title="JVM之认识和解决Full GC">JVM之认识和解决Full GC</a><time datetime="2024-03-09T12:33:59.000Z" title="发表于 2024-03-09 20:33:59">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="Java并发之线程池详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之线程池详解"/></a><div class="content"><a class="title" href="/2024/02/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="Java并发之线程池详解">Java并发之线程池详解</a><time datetime="2024-02-28T11:18:05.000Z" title="发表于 2024-02-28 19:18:05">2024-02-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="小奥" target="_blank">小奥</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">13</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 0.88rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 0.88rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 0.88rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 0.88rem;">Feed流<sup>1</sup></a><a href="/tags/Full-GC/" style="font-size: 0.88rem;">Full GC<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 0.88rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 0.88rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 0.88rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 0.88rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 0.88rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 0.88rem;">ReentrantLock<sup>1</sup></a><a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">SQL优化<sup>2</sup></a><a href="/tags/Servlet/" style="font-size: 0.88rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 0.88rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 0.88rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 0.88rem;">synchronized<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>3</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>2</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 0.88rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 0.88rem;">文件上传<sup>1</sup></a><a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 0.88rem;">死锁<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">算法模板<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8956954060&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小奥 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>