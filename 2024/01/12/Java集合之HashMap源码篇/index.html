<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java集合之HashMap源码篇 | 小奥</title><meta name="keywords" content="HashMap"><meta name="author" content="小奥,3189137314@qq.com"><meta name="copyright" content="小奥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java集合之HashMap源码篇"><meta name="application-name" content="Java集合之HashMap源码篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java集合之HashMap源码篇"><meta property="og:url" content="http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/index.html"><meta property="og:site_name" content="小奥"><meta property="og:description" content="☆* o(≧▽≦)o *☆嗨~我是小奥🍹📄📄📄个人博客：小奥的博客📄📄📄CSDN：个人CSDN📙📙📙Github：传送门📅📅📅面经分享（牛客主页）：传送门🍹文章作者技术和水平有限，如果文中出现错误，希望大家多多指正！📜 如果觉得内容还不错，欢迎点赞收藏关注哟！ ❤️"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/png/17.png"><meta property="article:author" content="小奥"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/png/17.png"><meta name="description" content="☆* o(≧▽≦)o *☆嗨~我是小奥🍹📄📄📄个人博客：小奥的博客📄📄📄CSDN：个人CSDN📙📙📙Github：传送门📅📅📅面经分享（牛客主页）：传送门🍹文章作者技术和水平有限，如果文中出现错误，希望大家多多指正！📜 如果觉得内容还不错，欢迎点赞收藏关注哟！ ❤️"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 编程知识爱好者","🔍 分享与热心帮助","🏠 面试总结小能手","🔨 设计开发一条龙","🤝 源码阅读与解析","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小奥","link":"链接: ","source":"来源: 小奥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小奥',
  title: 'Java集合之HashMap源码篇',
  postAI: '',
  pageFillDescription: 'Java集合之HashMap源码详解, 概述, 底层数据结构, 构造函数, 扰动函数(hash), put()方法, get()方法, resize()方法, JDK7的扩容, JDK8的扩容, HashMap面试题总结, 解决Hash冲突的方式有哪些, （1）开放寻址法, （2）链地址法, （3）再哈希法, （4）建立一个公共溢区, HashMap和Hashtable的区别, HashMap和HashSet的区别, HashMap和TreeMap的区别, HashMap的扩容为什么是2倍, HashMap为什么链表长度超过8才转为红黑树, HashMap为什么在数组长度大于64才会进化为红黑树, HashMap为什么加载因子设置为0.75初始化临界值是12, 一般用什么作为HashMap的key, HashMap为什么线程不安全出现的问题, （1）扩容导致循环链表, （2）put导致元素丢失, （3）put和get并发导致空指针, 计算hash值时为什么要让低16bit和高16bit进行异或处理, 什么方法可以解决HashMap不安全, 源码嗨我是小奥个人博客小奥的博客个人传送门面经分享牛客主页传送门文章作者技术和水平有限如果文中出现错误希望大家多多指正如果觉得内容还不错欢迎点赞收藏关注哟集合之源码详解概述主要用来存放键值对它基于哈希表的接口实现的实现是不同步的说明它不是线程安全的它的和都可以为之前的底层实现是数组链表数组是存储元素的主要部分链表则是为了解决哈希冲突即使哈希函数选择的再好也很难实现元素百分百均匀分布当有大量的元素都存放到一个桶中这个桶有一个很长的链表极端情况下就相当于一条链表遍历的时间复杂度是这就完全失去了它的优势之后的底层实现是数组链表红黑树桶中的结构可能是链表也可能是红黑树当链表长度大于阈值或者说是红黑树的阈值默认为并且当前数组的长度大于时此时此索引上的所有元素改为红黑树存储当链表的结点小于时红黑树结构又会转化为链表结构通过计算出值然后通过判断当前元素存放的位置是指数组长度如果当前位置存在元素的话就判断与该元素要存入的元素的值以及是否相同如果相同的话直接覆盖如果不同就通过拉链法解决冲突默认的初始化大小为之后每次扩充容量变为原来的倍并且总是使用的幂作为哈希表的大小底层数据结构目前数组的长度值总是次方的整数每次扩容后会加即整个数组容量会扩充为之前的倍该初始值默认值为负载因子默认为扩容的阈值等于即当数组内达到这么多元素时会触发扩容默认的负载因子是对空间和时间效率的一个平衡选择一般建议不要修改如果内存空间多而又对时间效率要求很高可以降低负载因子的值相反如果内存空间紧张而对时间效率要求不高可以增加负载因子的值这个值可以大于数组中元素的数据结构包含四个属性和存储节点的数组序列号默认的初始容量是最大容量默认的负载因子当桶上的结点数大于等于这个值时会转成红黑树当桶上的结点数小于等于这个值时树转链表桶中结构转化为红黑树对应的的最小容量存储元素的数组总是的幂次倍存放具体元素的集存放元素的个数注意这个不等于数组的长度每次扩容和更改结构的计数器阈值容量负载因子当实际大小超过阈值时会进行扩容负载因子构造函数如果没有指定容量和负载因子大小则容量大小默认为负载因子大小默认为如果指定容量和负载因子大小则首先判断指定的容量是否小于如果小于则抛出如果指定的容量大小大于的容量极限那么容量就等于最大容量如果负载因子小于或者为那么抛出异常如果都没有上面的情况那么就指定容量和负载因子大小构造具有指定初始容量和负载因子的空指定的容量大小不可以小于否则将抛出异常判定指定的容量大小是否大于的容量极限指定的负载因子不可以小于或为若判定成立则抛出异常初始容量暂时放到在中再赋值给进行初始化设置阈值当中存储数据的数量达到时就需要将的容量加倍用于查找到大于给定数值的最近次幂值比如给定就是给定就是用指定的初始值构造一个空的容量和默认负载因子使用默认初始容量和默认负载因子构造一个空的构造一个与指定具有相同映射的新是用默认负载因子创建的初始容量足以在指定的中保存映射扰动函数异或无符号右移空位以补齐总结相比于的方法性能稍微差点但是原理是一样的如果为的时候的值为说明是支持存储值的方法方法是通过方法实现的具体逻辑如下首先获取动态数组对象和长度若动态数组对象为空或者说是长度为则调用扩容方法进行初始化判断动态数组中的这个的值的节点是否为空具体做法是的的高位和低位做异或运算然后根据这个值去计算数组的下标位置具体是如果为空则创建一个新的节点放入和如果不为空分为三种情况如果动态数组的第一个元素是和一样则暂时存储当前的到中方便后续返回如果动态数组的第一个元素是红黑树结构则直接在树中插入键值对如果动态数组是链表结构循环遍历这个链表直到为空才会插入该和在链表尾部插入如果插入之后链表长度大于并且数组长度大于才会进行树化处理在遍历过程中如果发现有的和要插入的相同则直接退出遍历如果的不为空用节点设置新的并返回旧的不再进行后续操作如果是插入节点则继续判断当前集合容量是否达到阈值如果达到阈值则进行扩容处理执行完这些操作然后返回将指定值与此映射中的指定键关联如果映射以前包含键的映射则替换旧值实现了和相关方法未初始化或者长度为则进行扩容确定元素存放在哪个桶中桶为空新生成节点放入桶中此时这个结点是放在数组中桶中已经存在元素处理冲突快速判断第一个节点的是否与插入的一样若相同则直接使用插入的值替换掉旧的值插入的节点是红黑树节点放入树中插入的节点是链表节点在链表的最末端插入节点在尾部掺入新节点如果节点数量达到阈值默认为执行方法根据数组来决定是否转换为红黑树只有当数组长度大于或者等于的情况下才会执行红黑树操作减少搜索次数否则只是对数组扩容如果链表节点的与插入元素的相等跳出循环用于遍历桶中的链表与前面的组合遍历链表在桶中找到值值与插入元素相等的节点记录的为或者为用新值替换旧值访问后回调返回旧值结构性修改如果实际大小大于阈值则扩容插入后回调为什么数组的长度总是的次方为了让的额存取高效尽量避免较少的碰撞即把数据尽量分布均匀的值的范围是到次方只要哈希函数映射的比较松散一般是很难出现碰撞的但是这么大的数组内存肯定放不下所以实际中还要对这个数组的长度进行取模运算但是取模运算对计算机的开销还是比较大的所以使用二进制运算代替取模比取模运算效率更高方法返回指定键映射到的值如果此映射不包含该键的映射则返回更正式地说如果这个映射包含一个从键到值的映射使得则此方法返回否则返回最多只能有一个这样的映射返回值为并不一定表示映射不包含该键的映射也有可能映射显式地将键映射为操作可以用来区分这两种情况实现了相关方法当前的数组当前对应索引位置上的节点遍历过程中临时存储的节点数组的长度如果相等直接返回在树结构中在链表中遍历链表方法什么时候进行扩容初始化后添加元素时创建以后并不是立即就初始化而是在第一次放入元素的时候才会初始化这是节省内存的一种机制而的初始化也是方法实现的达到阈值后才会触发扩容这个阈值是中的的属性就是容量负载因子的扩容的扩容首先判断旧数组的长度是否已经达到了最大值如果达到了那么将数组的最大容量设置为否则创建一个指定容量的新的数组遍历原来的数组重新计算所有元素的索引然后重新赋值如果某个位置发生了哈希冲突使用的是单链表的头插法同一位置的新的元素总是在那个在链表的头部这样与原来集合链表相比扩容之后就是倒序的链表了参数为新数组的大小引用扩容前的数组扩容前的数组大小如果已经达到最大了修改阈值为的最大值这样以后就不会扩容了初始化一个新的数组将数组元素转移到新数组里面修改阈值遍历数组重新计算每个元素在数组中的索引位置标记下一个元素添加是链表头添加将元素放在链上访问下一个链上的元素的扩容扩容的流程大致如下首先对三种情况进行判断情况一若旧表的容量大于首先判断数组长度是否已经达到最大阈值如果已经达到最大阈值则不再进行扩容将最大阈值设置为然后将旧表返回若新表的容量的倍小于数组的最大阈值并且旧表的容量大于容量默认值大小则新表的阈值直接等于旧表阈值的倍阈值是容量负载因子情况二若旧表的阈值大于则将新表容量赋值为该阈值情况三其他情况即的未初始化的时候使用默认值进行初始化完成之后继续执行若新表的阈值为则此时计算新表的阈值并将计算之后的阈值赋值给作为下一次扩容的判断依据通过循环遍历将旧表的数据保存到新表如果当前节点只有一个元素那么通过计算值将其放到新表正确的位置如果当前节点是红黑树类型那么分割树将新表和旧表分割成两个树并判断此处索引处节点的长度是否需要转换成红黑树放入新表存储否则就按照链表的方式插入新的数据通过循环将旧数据和新数据存储到新表的指定位置初始化或加倍表大小如果为空则按照字段阈值中持有的初始容量目标进行分配否则由于我们使用的是的幂展开因此每个桶中的元素必须保持在相同的索引上或者在新表中以的幂偏移量移动原数组如果为空则长度赋值为如果原数组长度大于说明已经初始化过了是一次正常的扩容判断旧的容量是否大于容量最大值如果是则无法扩容那么修改阈值为原数组长度大于等于初始化长度并且原数组长度扩大倍也小于次方扩容为原来的倍初始容量被置于阈值如果旧容量且旧阈值说明是通过构造方法创建的新容量直接等于旧阈值创建对象时初始化容量大小放在中此时只需要将其作为新的数组容量零初始阈值表示使用默认值无参构造函数创建的对象在这里计算容量和阈值数组长度初始化为数组阈值初始化为创建时指定了初始化容量或者负载因子在这里进行阈值初始化或者扩容前旧容量小于在这里计算新的上限更新把每个都移动到新的中当前桶位数据不为空但是不能判断是链表还是红黑树结构如果结点不存在下一个结点说明是单个元素则直接放入新数组的对应位置将红黑树拆分成两棵子树如果子树节点小于等于默认为则将子树转换为链表否则保持子树的树结构否则为链表则对链表进行遍历低位链表存放在扩容之后的数组的下标位置与当前数组下标位置一致低位链表头节点低位链表尾节点高位链表存放扩容之后的数组的下标位置原索引扩容之前数组容量高位链表头节点高位链表尾节点通过运算计算当前结点的值是高位为还是高位为放入低位链表中高位为放入高位链表中原索引放到里将低位链表头结点指向原来的索引位置原索引放到里将高位链表头结点指向新的索引位置面试题总结解决冲突的方式有哪些开放寻址法这种方法也称为再散列法其基本思想是当关键字的哈希地址出现冲突时以为基础产生另外一个哈希地址如果仍然产生冲突再以为基础产生另一个哈希地址直到找出一个不冲突的哈希地址将相应的元素存入其中其中为哈希函数为哈希表长为增量序列开放寻址法对增量有三种取法线性探测法最简单的情况平方探测法也称二次探测再散列等随机探测法是一伪随机数列链地址法把具有相同哈希地址的关键字的值放在同一个链表中若选定的哈希表的长度为则可将哈希表定义为一个由个头指针组成的指针数组凡是哈希地址为的界定均插入到为头结点的单链表中中各分量的初值均应为空再哈希法均是不同的哈希函数即在产生冲突时计算另一个哈希函数地址直到冲突不再发生建立一个公共溢区所有关键字和基本表中的关键字为同义词的记录不管它们由哈希函数得到的哈希地址是什么一旦发生冲突都填入公共溢出表和的区别线程安全是非线程安全的是线程安全的因为内部的方法基本都经过了的修饰如果要保证线程安全的话可以使用效率因为线程安全的问题要比效率高一点另外基本被淘汰对和的支持可以存储的和但作为键只能有一个而可以有多个不允许键和值否则会抛出异常键在计算值的时候直接会抛出空指针异常而值则会直接抛出空指针异常初始容量大小和每次扩容大小的不同创建时如果不指定容量的初始值默认的初始值大小为之后每次扩容容量变为原来的默认的初始化大小为之后每次扩容容量变为原来的倍创建时如果给定了容量的初始值那么会直接使用给定的大小而则会将其扩充为的幂次方大小底层数据结构之后的在解决哈希冲突时有了较大的变化当链表长度大于阈值默认为将链表转换成红黑树之前会判断如果当前数组的长度小于那么会选择先进行数组扩容而不是转换为红黑树时将链表转为为红黑树以减少搜索时间而则没有这样的机制和的区别实现接口实现了接口仅存储对象而实现了接口存储的是键值对底层实现的底层就是基于实现的的值就是的的是一个对象所以不允许出现重复值判断标准也是使用的的判断标准效率的效率在有的时候会比高和在进行存储的时候都需要计算哈希值但是的键的类型通常是一个字符串或者一个简单的数字计算该对象或者的哈希值比整个对象的默认的哈希值计算快的多所以如果的键和的值是同一个对象那么效率不会有太大差异否则的效率比高和的区别是否线程安全两者都不是线程安全的对排序的支持不支持元素排序而支持根据的顺序来排序对的支持允许一个和多个而不允许但是允许性能区别底层是数组实现的所以在添加删除和查找等方法上效率比较高而底层是一个红黑树结构操作的速度比较慢并且产生哈希冲突时红黑树结构还要进行自平衡操作来维持树的平衡效率比较低的扩容为什么是倍计算添加元素的位置时使用的是位运算使用另外的初始容量是的次幂扩容也是以倍的方式扩容是因为容量是的次幂可以使得元素更加均匀部分在的数组上减少碰撞避免形成链表结构使得查询效率降低为什么链表长度超过才转为红黑树虽然转化为红黑树后查找的效率会比链表更高但是树节点占用空间是普通节点的两倍如果链表节点不够多却转换成红黑树会耗费大量的空间资源从平均查找长度来看红黑树的平均查找长度是而链表的平均查找长度是所以阈值为是两种数据结构效率交叉的点比如长度为时红黑树退化成链表是因为两者的平均查找长度相差不大而红黑树节点占用更多的空间理想情况下在随机值下加载因子为的情况下节点的频率服从参数平均为的泊松分布官方做过很多的测试发现链表长度在大于以后再出现碰撞的可能性几乎为红黑树的转化左旋右旋保持平衡还是相对耗时的所以链表长度阈值设置为就是为了尽量减少中出现红黑树从而提高的效率为什么在数组长度大于才会进化为红黑树在数组比较小时如果出现红黑树结构反而会降低效率而红黑树需要进行左旋右旋变色这些操作来保持平衡同时数组长度小于时搜索时间相对要快些总之是为了加快搜索速度提高性能同时官方注释规定最小的树转化阈值应该是链表的最大长度也就是以避免调整大小阈值和树化阈值之间的冲突为什么加载因子设置为初始化临界值是官方注释一般来说默认的加载系数提供了一个很好的选择时间和空间成本的权衡较高的数值会降低空间开销但是会增加查找成本反映在大多数类的操作如等加载因子越大填满的元素更多空间利用率越高但发生冲突的几率变得更大加载因子越小填满的元素越少发生冲突的几率更小但是空间利用率更低而且还会提高扩容的次数而初始临界值是临界值计算公式数组长度默认负载因子默认是衡量数组是否需要扩容的一个标准一般用什么作为的为什么中的必须要实现方法掘金从的语法上来讲一切的对象都可以作为值比如等但是实际上来说我们最好还是使用一些重写了和方法的类来当作的或者说像这样每次操作都会生成新的对象的类天生线程安全的类为什么线程不安全出现的问题扩容导致循环链表容器框架在下的死循环问题初梦学习记录极客文档在多线程下扩容会导致链表成为环形链表中使用头插法插入元素在多线程的环境下扩容的时候可能会导致环形链表的出现这时如果执行操作就会形成死循环因此中使用尾插法插入元素在扩容的时候会保持链表元素的原本顺序不会出现环形链表的问题死循环如何产生的那就是在操作的时候如果那么这时候就会进行操作并发下的会造成元素之间会形成一个循环链表不过后解决了这个问题但是还是不建议在多线程下使用因为多线程下使用还是会存在其他问题比如数据丢失的源码如下传入新的容量引用扩容前的数组扩容前的数组大小如果已经达到最大了修改阈值为的最大值这样以后就不会扩容了初始化一个新的数组将数据转移到新的数组里的属性引用新的数组修改阈值引用了旧的数组遍历旧的数组取得旧数组的每个元素释放旧数组的对象引用循环后旧的数组不再引用任何对象重新计算每个元素在数组中的位置标记将元素放在数组上访问下一个链上的元素具体过程如下正常的过程假设我们的算法就是简单的最上面的时表其中的所以在之后冲突都产生在这里接下来表长度扩容为然后所有的重新并发下的线程执行到此处被调度挂起首先假设我们有两个线程当线程进行时当节点指向节点指向这时线程挂起而线程已经执行完成于是会产生以下场景注意此时线程的节点的指向为而节点指向为在线程进行之后指向了重组之后的链表使用头插法链表的顺序被反转线程被调度回来执行先是执行然后是导致了指向了而下一次循环的导致了指向了导致指向了注意此时的已经指向了环形链表就这样出现了导致元素丢失多线程下的元素可能会导致元素的丢失多线程同时执行操作如果计算出来的索引位置是相同的那么可能会造成前一个被后一个覆盖导致元素的丢失这个问题在和都存在和并发导致空指针在多线程环境下如果线程执行方法时因为元素个数超过阈值而导致扩容线程此时执行方法有可能会获取到值这个问题在和都存在计算值时为什么要让低和高进行异或处理值其实是一个类型的数据二进制为位而的初始容量为在进行运算的时候这时计算的哈希值只能与第四位进行与操作也就是说的高四位其实并没有参与运算这样会导致很多哈希值不同而高四位有区别的数计算出来的索引都是一样的产生较多的哈希冲突为了避免这种情况将高位与第位进行异或操作这样可以保证高位的数据也能参与到值的计算当中以增加索引的散列程序让数据分布的更加均匀什么方法可以解决不安全通过返回一个线程安全的不推荐使用因为底层维护一个锁对象所有的操作都需要通过这个锁对象效率比较低使用是线程安全的集合类但是已经被废弃了使用代替采用分段锁思想灵活保证线程操作的安全效率相对于直接加锁更好源码实现说明这个映射通常作为一个桶哈希表但是当桶变得太大时它们被转换成的桶每个节点的结构与中的相似大多数方法尝试使用正常的桶但在适用的情况下中继到方法只需通过检查节点的的桶可以像其他桶一样遍历和使用但在填充过多时还支持更快的查找然而由于绝大多数正常使用的容器都没有过度填充因此检查树容器是否存在可能会在表方法的过程中被延迟树桶即其元素都是的桶主要由排序但在关联的情况下如果两个元素属于相同的类实现则键入它们的方法用于排序我们通过反射保守地检查泛型类型来验证这一点参见方法当键具有不同的哈希值或可排序时树桶增加的复杂性在提供最坏情况操作方面是值得的因此在意外或恶意使用方法返回分布不佳的值以及许多键共享的情况下只要它们也是可比较的性能就会优雅地下降如果这两项都不适用与不采取预防措施相比我们可能会浪费大约两倍的时间和空间但唯一已知的案例源于糟糕的用户编程实践这些实践已经非常缓慢以至于这几乎没有什么区别因为的大小大约是常规节点的两倍所以我们只在桶包含足够的节点以保证使用时才使用它们参见当它们变得太小由于移除或调整大小时它们被转换回普通的桶在用户分布良好的用法中很少使用树桶理想情况下在随机下箱中节点的频率遵循泊松分布默认调整大小阈值为参数平均约为尽管由于调整大小粒度而存在很大差异忽略方差列表大小的预期出现次数为第一个值是树桶的根通常是它的第一个节点然而有时目前仅在上根可能在其他地方但可以通过父链接方法恢复所有适用的内部方法都接受哈希码作为参数通常由公共方法提供允许它们相互调用而无需重新计算用户哈希码大多数内部方法也接受参数通常是当前表但在调整大小或转换时可能是新表或旧表当列表被树化拆分或非树化时我们将它们保持相同的相对访问遍历顺序即字段以更好地保留局部性并稍微简化调用的拆分和遍历处理当在插入时使用比较器时为了在重新平衡中保持总排序或尽可能接近我们比较类和作为决定因素由于子类的存在普通模式与树模式之间的使用和转换变得复杂请参阅下面定义的在插入删除和访问时调用的钩子方法这些方法允许内部保持独立于这些机制这还需要将映射实例传递给一些可能创建新节点的实用程序方法类似于并发编程的基于的编码风格有助于避免在所有扭曲指针操作中出现混叠错误默认初始容量必须是的幂如果隐式指定了更大的值则使用最大容量由任意一个带参数的构造函数调用必须是的幂在构造函数中未指定时使用的负载因子默认负载因子使用树而不是列表的计数阈值当向至少有这么多节点的桶中添加元素时桶将转换为树该值必须大于并且应该至少为以符合在树木移除中关于收缩后转换回普通桶的假设当桶上的节点数大于等于该值会由链表转换成红黑树在调整大小操作期间取消树化拆分的计数阈值应小于且最多为以便在移除时进行收缩检测当桶上的节点数小于等于该值会由红黑树转换成链表可以对桶进行树化的最小表容量否则如果一个中的节点太多则会调整表的大小应该至少为以避免调整大小和树化阈值之间的冲突桶中结构转换为红黑树对应的的最小容量基本哈希节点用于大多数条目参见下面的子类以及中的子类哈希值存放元素到中时用来与其他元素的值比较键值指向下一个节点计算并将哈希的高位数扩展到低位数因为表使用了的幂掩码所以在当前掩码之上只变化几比特的哈希集总是会发生冲突其中一个已知的例子是在小表格中保存连续整数的键集因此我们应用一个变换将高比特的影响向下扩散比特传播的速度效用和质量之间存在权衡由于许多常见的哈希集已经合理分布因此不会从扩展中受益并且由于我们使用树来处理箱中的大型碰撞集因此我们只是以最便宜的方式对一些移位的位进行异或以减少系统损失并合并最高位的影响否则由于表边界的原因这些位在索引计算中永远不会使用如果的是的形式则返回它的否则返回如果匹配筛选的可比较类则返回否则为返回给定目标容量的次幂大小表在第一次使用时初始化并根据需要调整大小在分配时长度总是的幂我们也允许某些操作的长度为零以允许目前不需要的引导机制存储元素的数组总是的幂次方保存缓存的注意字段用于和存放具体元素的集此映射中包含的键值映射的数量存放元素的个数注意这个不等于数组的长度结构修改是指改变中的映射数量或以其他方式修改其内部结构例如重新散列该字段用于使的集合视图上的迭代器快速失败见每次扩容和更改结构的计数器要调整大小的下一个大小值容量负载因子阈值当实际大小超过阈值时会进行扩容序列化时描述为真另外如果表数组没有被分配字段保存初始数组容量或者零表示哈希表的负载因子构造具有指定初始容量和负载因子的空指定的容量大小不可以小于否则将抛出异常判定指定的容量大小是否大于的容量极限指定的负载因子不可以小于或为若判定成立则抛出异常初始容量暂时放到在中再赋值给进行初始化设置阈值当中存储数据的数量达到时就需要将的容量加倍用于查找到大于给定数值的最近次幂值比如给定就是给定就是用指定的初始值构造一个空的容量和默认负载因子使用默认初始容量和默认负载因子构造一个空的构造一个与指定具有相同映射的新是用默认负载因子创建的初始容量足以在指定的中保存映射实现了和的构造判断是否已经初始化未初始化为的实际元素个数指的是要添加个元素所需的最小容量未初始化实际上存放的是初始化容量如果添加个元素所需的最小容量大于初始化容量则将最小容量扩容为最接近的幂次方大小作为初始化注意这里不是初始化阈值已经初始化并且元素个数大于阈值进行扩容处理将中所有元素添加至中如果未初始化中会调用初始化或者扩容返回此映射中键值映射的个数如果此映射不包含键值映射则返回返回指定键映射到的值如果此映射不包含该键的映射则返回更正式地说如果这个映射包含一个从键到值的映射使得则此方法返回否则返回最多只能有一个这样的映射返回值为并不一定表示映射不包含该键的映射也有可能映射显式地将键映射为操作可以用来区分这两种情况实现了相关方法如果此映射包含指定键的映射则返回将指定值与此映射中的指定键关联如果映射以前包含键的映射则替换旧值实现了和相关方法未初始化或者长度为则进行扩容确定元素存放在哪个桶中桶为空新生成节点放入桶中此时这个结点是放在数组中桶中已经存在元素处理冲突快速判断第一个节点的是否与插入的一样若相同则直接使用插入的值替换掉旧的值插入的节点是红黑树节点放入树中插入的节点是链表节点在链表的最末端插入节点在尾部掺入新节点如果节点数量达到阈值默认为执行方法根据数组来决定是否转换为红黑树只有当数组长度大于或者等于的情况下才会执行红黑树操作减少搜索次数否则只是对数组扩容如果链表节点的与插入元素的相等跳出循环用于遍历桶中的链表与前面的组合遍历链表在桶中找到值值与插入元素相等的节点记录的为或者为用新值替换旧值访问后回调返回旧值结构性修改如果实际大小大于阈值则扩容插入后回调初始化或加倍表大小如果为空则按照字段阈值中持有的初始容量目标进行分配否则由于我们使用的是的幂展开因此每个桶中的元素必须保持在相同的索引上或者在新表中以的幂偏移量移动原数组如果为空则长度赋值为如果原数组长度大于说明已经初始化过了是一次正常的扩容判断旧的容量是否大于容量最大值如果是则无法扩容那么修改阈值为原数组长度大于等于初始化长度并且原数组长度扩大倍也小于次方扩容为原来的倍初始容量被置于阈值如果旧容量且旧阈值说明是通过构造方法创建的新容量直接等于旧阈值创建对象时初始化容量大小放在中此时只需要将其作为新的数组容量零初始阈值表示使用默认值无参构造函数创建的对象在这里计算容量和阈值数组长度初始化为数组阈值初始化为创建时指定了初始化容量或者负载因子在这里进行阈值初始化或者扩容前旧容量小于在这里计算新的上限更新把每个都移动到新的中当前桶位数据不为空但是不能判断是链表还是红黑树结构如果结点不存在下一个结点说明是单个元素则直接放入新数组的对应位置将红黑树拆分成两棵子树如果子树节点小于等于默认为则将子树转换为链表否则保持子树的树结构否则为链表则对链表进行遍历低位链表存放在扩容之后的数组的下标位置与当前数组下标位置一致低位链表头节点低位链表尾节点高位链表存放扩容之后的数组的下标位置原索引扩容之前数组容量高位链表头节点高位链表尾节点通过运算计算当前结点的值是高位为还是高位为放入低位链表中高位为放入高位链表中原索引放到里将低位链表头结点指向原来的索引位置原索引放到里将高位链表头结点指向新的索引位置替换节点中给定哈希索引处的所有链接节点除非表太小在这种情况下调整大小将指定映射中的所有映射复制到此映射这些映射将替换此映射对指定映射中当前任何键的任何映射从此映射中删除指定键的映射如果存在实现和相关方法从该映射中删除所有映射这个调用返回后映射将为空如果此映射将一个或多个键映射到指定值则返回返回此映射中包含的键的视图集合由映射支持因此对映射的更改反映在集合中反之亦然如果在对进行迭代时修改通过迭代器自己的操作除外则迭代的结果是未定义的支持移除元素即通过从中移除对应的映射和操作它不支持或操作返回此映射中包含的值的集合视图集合由映射支持因此对映射的更改将反映在集合中反之亦然如果在对集合进行迭代时修改通过迭代器自己的操作除外则迭代的结果是未定义的该集合支持移除元素即通过从中移除对应的映射和操作它不支持或操作返回此映射中包含的映射的视图集合由映射支持因此对映射的更改反映在集合中反之亦然如果在对进行迭代时修改通过迭代器自己的操作或通过对迭代器返回的项执行操作除外则迭代的结果是未定义的支持移除元素即通过从中移除对应的映射和操作它不支持或操作节点结构延伸结构又扩展因此可以用作常规节点或链接节点的扩展红黑树链接父节点左子树右子树需要在删除后解除链接判断颜色的标识返回包含此节点的树的根确保给定的根是其桶的第一个节点用给定的散列和键查找从根开始的节点参数在第一次使用比较键时缓存对根节点调用当相等且不可比较时用于排序插入的实用程序我们不需要一个总顺序只需要一个一致的插入规则来保持跨再平衡的等价性不必要的断线进一步简化了测试形成从该节点链接的节点的树返回非的列表替换从该节点链接的那些节点的树版本删除在此调用之前必须存在的给定节点这比典型的红黑删除代码更混乱因为我们不能将内部节点的内容与由在遍历期间可独立访问的指针固定的叶继承节点交换所以我们交换树形连杆如果当前树的节点太少则将该二进制文件转换回普通二进制文件测试触发到个节点这取决于树的结构将树仓中的节点拆分为上树仓和下树仓如果太小则拆分为非树仓只能从中调用参见上面关于分割位和索引的讨论红黑树方法全部改编自递归不变检验',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-13 19:47:43',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小奥</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 1.05rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 1.05rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 1.05rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 1.05rem;">Feed流<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 1.05rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 1.05rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 1.05rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 1.05rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 1.05rem;">ReentrantLock<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 1.05rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 1.05rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 1.05rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 1.05rem;">synchronized<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 1.05rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 1.05rem;">文件上传<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">算法模板<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/HashMap/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>HashMap</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java集合之HashMap源码篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-01-12T12:13:56.000Z" title="发表于 2024-01-12 20:13:56">2024-01-12</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-13T11:47:43.813Z" title="更新于 2024-01-13 19:47:43">2024-01-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/png/17.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a><a href="/tags/HashMap/" tabindex="-1" itemprop="url">HashMap</a><h1 id="CrawlerTitle" itemprop="name headline">Java集合之HashMap源码篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小奥</span><time itemprop="dateCreated datePublished" datetime="2024-01-12T12:13:56.000Z" title="发表于 2024-01-12 20:13:56">2024-01-12</time><time itemprop="dateCreated datePublished" datetime="2024-01-13T11:47:43.813Z" title="更新于 2024-01-13 19:47:43">2024-01-13</time></header><blockquote>
<p>☆* o(≧▽≦)o *☆嗨~我是小奥🍹<br>📄📄📄个人博客：<a target="_blank" rel="noopener" href="https://xiaoaozz.github.io/">小奥的博客</a><br>📄📄📄CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52805594">个人CSDN</a><br>📙📙📙Github：<a target="_blank" rel="noopener" href="https://github.com/xiaoaozz">传送门</a><br>📅📅📅面经分享（牛客主页）：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/users/329856854">传送门</a><br>🍹文章作者技术和水平有限，如果文中出现错误，希望大家多多指正！<br>📜 如果觉得内容还不错，欢迎点赞收藏关注哟！ ❤️</p>
</blockquote>
<h1 id="Java集合之HashMap源码详解"><a href="#Java集合之HashMap源码详解" class="headerlink" title="Java集合之HashMap源码详解"></a>Java集合之HashMap源码详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap主要用来存放键值对，它基于哈希表的Map接口实现。HashMap的实现是不同步的，说明它不是线程安全的，它的key和value都可以为null。</p>
<ul>
<li>HashMap JDK1.8之前的底层实现是 <strong>数组 + 链表</strong>，数组是存储元素的主要部分，链表则是为了解决哈希冲突。<ul>
<li>即使哈希函数选择的再好，也很难实现元素百分百均匀分布。当HashMap有大量的元素都存放到一个桶中，这个桶有一个很长的链表，极<strong>端情况下HashMap就相当于一条链表，遍历的时间复杂度是O(n)，这就完全失去了它的优势。</strong></li>
</ul>
</li>
<li>HashMap JDK1.8之后的底层实现是 <strong>数组 + 链表 + 红黑树</strong>，桶中的结构可能是链表也可能是红黑树。<ul>
<li><strong>当链表长度大于阈值（或者说是红黑树的阈值，默认为8）并且当前数组的长度大于64</strong>时，此时此索引上的所有元素改为红黑树存储；当<strong>链表的结点小于6</strong>时，红黑树结构又会转化为链表结构。</li>
</ul>
</li>
</ul>
<p>HashMap通过key计算出hash值，然后通过 <code>(n - 1) &amp; hash</code>判断当前元素存放的位置（n是指数组长度），如果当前位置存在元素的话，就判断与该元素要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，如果不同就通过拉链法解决冲突。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul>
<li><p>**<code>capacity</code>**：目前数组的长度，值总是2^n次方的整数。每次扩容后，n会加1，即整个数组容量会扩充为之前的2倍，该初始值默认值为16。</p>
</li>
<li><p>**<code>loadFactor</code>**：负载因子，默认为0.75。</p>
</li>
<li><p>**<code>threshold</code>*<em>：扩容的阈值，等于capacity</em>loadFactor，即当数组内达到这么多元素时，会触发扩容。</p>
<p><strong>默认的负载因子0.75是对空间和时间效率的一个平衡选择</strong>，一般建议不要修改。如果内存空间多而又对时间效率要求很高，可以降低负载因子的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子的值，这个值可以大于1。</p>
</li>
<li><p>**<code>Node</code>**：数组中元素的数据结构，包含四个属性：hash、key、value和next。</p>
</li>
<li><p>**<code>table</code>**：存储节点的数组。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>如果没有指定容量和负载因子大小，则<strong>容量大小默认为16，负载因子大小默认为0.75</strong>。</li>
<li>如果指定容量和负载因子大小，则<ul>
<li>首先判断<strong>指定的容量是否小于0</strong>，如果小于0，则抛出<code>IllegalArgumentException</code>；</li>
<li>如果<strong>指定的容量大小大于<code>HashMap</code>的容量极限</strong>（<code>1&lt;&lt;30</code>），那么容量就等于最大容量；</li>
<li>如果**负载因子小于<code>0</code>或者为<code>NaN</code>**，那么抛出<code>IllegalArgumentException</code>异常。</li>
<li>如果都没有上面的情况，那么就<strong>指定容量和负载因子大小</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量和负载因子的空HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//指定的容量大小不可以小于0,否则将抛出IllegalArgumentException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//判定指定的容量大小是否大于HashMap的容量极限</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="comment">//指定的负载因子不可以小于0或为NaN，若判定成立则抛出IllegalArgumentException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 初始容量暂时放到threshold，在resize中再赋值给newCap进行table初始化</span></span><br><span class="line">    <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">    <span class="comment">//tableSizeFor用于查找到大于给定数值的最近2次幂值，比如给定18就是32。给定33就是64</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用指定的初始值构造一个空的HashMap容量和默认负载因子(0.75)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始容量(16)和默认负载因子(0.75)构造一个空的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个与指定Map具有相同映射的新HashMap。</span></span><br><span class="line"><span class="comment"> * HashMap是用默认负载因子(0.75)创建的，初始容量足以在指定的Map中保存映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扰动函数-hash"><a href="#扰动函数-hash" class="headerlink" title="扰动函数(hash)"></a>扰动函数(hash)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK1<span class="number">.7</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    	h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">JDK1<span class="number">.8</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// ^ 异或   &gt;&gt;&gt; 无符号右移，空位以0补齐</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：相比于JDK1.8的hash方法，JDK1.7性能稍微差点，但是原理是一样的。如果key为null的时候的hash值为0，说明HashMap是支持存储null值的。</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h2><p>put方法是通过putVal方法实现的，具体逻辑如下：</p>
<ul>
<li>首先<strong>获取动态数组对象和长度</strong>，若动态数组对象为空或者说是长度为0，则调用resize()扩容方法进行初始化。</li>
<li>判断动态数组中的<strong>这个key的hash值的节点是否为空</strong>（具体做法是key的hashCode的高16位和低16位做异或运算，然后根据这个hash值去计算数组的下标位置，具体是<code> (capacity - 1) &amp; hash）</code><ul>
<li>如果为空，则创建一个新的node节点，放入key和value。</li>
<li>如果不为空，分为三种情况：<ul>
<li><strong>如果动态数组的第一个元素是和key一样</strong>，则暂时存储当前的node到e中，方便后续返回oldValue；</li>
<li><strong>如果动态数组的第一个元素是红黑树结构</strong>，则直接在树中插入键值对；</li>
<li><strong>如果动态数组是链表结构</strong>，循环遍历这个链表，直到node.next为空，才会插入该key和value(在链表尾部插入)。如果插入之后链表长度大于8并且数组长度大于64才会进行树化处理。在遍历过程中，如果发现有node的key和要插入的key相同，则直接退出遍历。</li>
</ul>
</li>
<li><strong>如果key的value不为空，用节点e设置新的value，并返回旧的value。</strong>不再进行后续操作。</li>
</ul>
</li>
<li>如果是插入节点，则<strong>继续判断当前集合容量是否达到阈值，如果达到阈值则进行扩容处理</strong>。</li>
<li>执行完这些操作，然后返回null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定值与此映射中的指定键关联。如果映射以前包含键的映射，则替换旧值。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现了Map.put和相关方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         <span class="comment">// table未初始化或者长度为0，则进行扩容</span></span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中</span></span><br><span class="line">         <span class="comment">// 桶为空，新生成节点放入桶中（此时，这个结点是放在数组中）</span></span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 桶中已经存在元素，处理hash冲突</span></span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="comment">// 快速判断第一个节点table[i]的key是否与插入的key一样</span></span><br><span class="line">             <span class="comment">// 若相同则直接使用插入的p值替换掉旧的值e</span></span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             <span class="comment">// 插入的节点是红黑树节点，放入树中</span></span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 插入的节点是链表节点</span></span><br><span class="line">             <span class="comment">// 在链表的最末端插入节点</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 在尾部掺入新节点 </span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         <span class="comment">// 如果节点数量达到阈值（默认为8），执行treeifyBin方法</span></span><br><span class="line">                         <span class="comment">// 根据HashMap数组来决定是否转换为红黑树 </span></span><br><span class="line">                         <span class="comment">// 只有当数组长度大于或者等于64的情况下，才会执行红黑树操作，减少搜索次数</span></span><br><span class="line">                         <span class="comment">// 否则，只是对数组扩容</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="comment">// 如果链表节点的key与插入元素的key相等，跳出循环</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="comment">// 用于遍历桶中的链表，与前面的 e = p.next组合，遍历链表</span></span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             <span class="comment">// 在桶中找到key值、hash值与插入元素相等的节点 </span></span><br><span class="line">             <span class="comment">// 记录e的value</span></span><br><span class="line">             <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                 <span class="comment">// onlyIfAbsent为false或者oldValue为null，用新值替换旧值</span></span><br><span class="line">                 e.value = value;</span><br><span class="line">             <span class="comment">// 访问后回调 </span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="comment">// 返回旧值</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount; <span class="comment">// 结构性修改</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         <span class="comment">// 如果实际大小大于阈值则扩容</span></span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict); <span class="comment">// 插入后回调</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么数组的长度总是2的n次方？</p>
</blockquote>
<p>为了让HashMap的额存取高效，尽量避免较少的碰撞，即把数据尽量分布均匀。Hash的值的范围是<code>-2^31</code> 到 <code>2 ^ 31</code>次方，只要哈希函数映射的比较松散，一般是很难出现碰撞的。但是这么大的数组，内存肯定放不下，所以实际中还要对这个数组的长度进行取模运算。</p>
<p>但是取模运算对计算机的开销还是比较大的，所以使用二进制运算**<code>hash &amp; (n - 1)</code>**代替取模，比取模运算效率更高。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定键映射到的值，如果此映射不包含该键的映射，则返回null。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 更正式地说，如果这个映射包含一个从键k到值v的映射，</span></span><br><span class="line"><span class="comment"> * 使得(key==null ?K ==null: key.equals(K))，则此方法返回v;否则返回null。(最多只能有一个这样的映射。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值为null并不一定表示映射不包含该键的映射;也有可能映射显式地将键映射为null。</span></span><br><span class="line"><span class="comment"> * containsKey操作可以用来区分这两种情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了Map.get相关方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// table：当前map的数组  first：当前hash对应索引位置上的节点 e：遍历过程中临时存储的节点</span></span><br><span class="line">    <span class="comment">// n：table数组的长度</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 如果相等，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 在树结构中get</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 在链表中get，遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h2><blockquote>
<p>什么时候进行扩容？</p>
</blockquote>
<ul>
<li><strong>HashMap初始化后添加元素时</strong>。HashMap创建以后并不是立即就初始化table，而是在第一次放入元素的时候，才会初始化table，这是HashMap节省内存的一种机制。而table的初始化也是resize()方法实现的。</li>
<li><strong>达到阈值后才会触发扩容</strong>。这个阈值，是Hash中的threshold的属性，就是<strong>容量 * 负载因子</strong>。</li>
</ul>
<h3 id="JDK7的扩容"><a href="#JDK7的扩容" class="headerlink" title="JDK7的扩容"></a>JDK7的扩容</h3><p>JDK1.7的扩容首先判断旧数组的长度是否已经达到了最大值（<code>2^30</code>），如果达到了那么将数组的最大容量设置为<code>2^30-1</code>。</p>
<p>否则创建一个指定容量的新的数组，遍历原来的数组重新计算所有元素的索引，然后重新赋值，如果某个位置发生了哈希冲突，使用的是单链表的<strong>头插法</strong>，同一位置的新的元素总是在那个在链表的头部，这样与原来集合链表相比，扩容之后就是倒序的链表了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数 newCapacity 为新数组的大小</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">       Entry[] oldTable = table;<span class="comment">//引用扩容前的 Entry 数组</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">           threshold = Integer.MAX_VALUE;<span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];<span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));<span class="comment">//将数组元素转移到新数组里面</span></span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);<span class="comment">//修改阈值</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历数组</span></span><br><span class="line">           <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">               <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                   e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">//重新计算每个元素在数组中的索引位置</span></span><br><span class="line">               e.next = newTable[i];<span class="comment">//标记下一个元素，添加是链表头添加</span></span><br><span class="line">               newTable[i] = e;<span class="comment">//将元素放在链上</span></span><br><span class="line">               e = next;<span class="comment">//访问下一个 Entry 链上的元素</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="JDK8的扩容"><a href="#JDK8的扩容" class="headerlink" title="JDK8的扩容"></a>JDK8的扩容</h3><p>扩容的流程大致如下：</p>
<p>首先对三种情况进行判断：</p>
<p>1、情况一：若旧表的<strong>容量</strong>大于0：</p>
<ul>
<li>首先<strong>判断数组长度是否已经达到最大阈值（2^30）</strong>，如果已经达到最大阈值，则不再进行扩容，将最大阈值设置为Integer.MAX_VALUE，然后将旧表返回。</li>
<li>若<strong>新表的容量的2倍小于数组的最大阈值（2^30） 并且旧表的容量大于容量默认值大小（16）</strong>，则新表的阈值直接等于旧表阈值的2倍（阈值是threshold &#x3D; 容量 * 负载因子）</li>
</ul>
<p>2、情况二：若旧表的<strong>阈值</strong>大于0，则将新表容量赋值为该阈值。</p>
<p>3、情况三：其他情况（即HashMap的table未初始化的时候），<strong>使用默认值进行初始化</strong>。</p>
<p>完成1、2、3之后，继续执行。</p>
<p>4、<strong>若新表的阈值为0，则此时计算新表的阈值</strong>，并将计算之后的阈值赋值给threshold，作为下一次扩容的判断依据。</p>
<p>5、通过for循环遍历<strong>将旧表的数据保存到新表</strong>：</p>
<ul>
<li><strong>如果当前节点只有一个元素</strong>，那么通过计算hash值将其放到新表正确的位置</li>
<li><strong>如果当前节点是红黑树类型</strong>，那么分割树，将新表和旧表分割成两个树，并判断此处索引处节点的长度是否需要转换成红黑树放入新表存储</li>
<li><strong>否则就按照链表的方式插入新的数据</strong>，通过do-while循环将旧数据和新数据存储到新表的指定位置。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 初始化或加倍表大小。如果为空，则按照字段阈值中持有的初始容量目标进行分配。</span><br><span class="line">  * 否则，由于我们使用的是2的幂展开，因此每个桶中的元素必须保持在相同的索引上，或者在新表中以2的幂偏移量移动。</span><br><span class="line">  */</span><br><span class="line"> final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     int oldCap = (oldTab == null) ? 0 : oldTab.length; // 原数组如果为空，则长度赋值为0</span><br><span class="line">     int oldThr = threshold;</span><br><span class="line">     int newCap, newThr = 0;</span><br><span class="line">     if (oldCap &gt; 0) &#123;</span><br><span class="line">         // 如果原数组长度大于0，说明HashMap已经初始化过了，是一次正常的扩容</span><br><span class="line">         if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             // 判断旧的容量是否大于容量最大值(2^30)，如果是，则无法扩容，那么修改阈值为 Integer.MAX_VALUE</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">             return oldTab;</span><br><span class="line">         &#125;</span><br><span class="line">         else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">             // // 原数组长度大于等于初始化长度16，并且原数组长度扩大1倍也小于 2^30次方，扩容为原来的2倍</span><br><span class="line">             newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">     &#125;</span><br><span class="line">     else if (oldThr &gt; 0) // 初始容量被置于阈值</span><br><span class="line">         // 如果旧容量 = 0 且 旧阈值 &gt; 0，说明是通过构造方法创建的HashMap</span><br><span class="line">     	// 新容量直接等于旧阈值</span><br><span class="line">         // 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br><span class="line">         newCap = oldThr;</span><br><span class="line">     else &#123;               // 零初始阈值表示使用默认值</span><br><span class="line">         // 无参构造函数创建的对象在这里计算容量和阈值</span><br><span class="line">         newCap = DEFAULT_INITIAL_CAPACITY; // 数组长度初始化为16 </span><br><span class="line">         newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 数组阈值初始化为12</span><br><span class="line">     &#125;</span><br><span class="line">     if (newThr == 0) &#123;</span><br><span class="line">         // 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化</span><br><span class="line">         // 或者扩容前旧容量小于16，在这里计算新的resize上限</span><br><span class="line">         float ft = (float)newCap * loadFactor;</span><br><span class="line">         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                   (int)ft : Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     threshold = newThr; // 更新</span><br><span class="line">     @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">     table = newTab;</span><br><span class="line">     if (oldTab != null) &#123;</span><br><span class="line">         // 把每个bucket都移动到新的buckets中</span><br><span class="line">         for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">             Node&lt;K,V&gt; e;</span><br><span class="line">             if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                 // 当前桶位数据不为空，但是不能判断是链表还是红黑树结构</span><br><span class="line">                 oldTab[j] = null;</span><br><span class="line">                 if (e.next == null)</span><br><span class="line">                     // 如果e结点不存在下一个结点，说明e是单个元素，则直接放入新数组的对应位置</span><br><span class="line">                     newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                 else if (e instanceof TreeNode)</span><br><span class="line">                     // 将红黑树拆分成两棵子树，如果子树节点小于等于UNTREEIFY_THRESHOLD（默认为 6），</span><br><span class="line">                     // 则将子树转换为链表，否则保持子树的树结构</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                 else &#123; // preserve order</span><br><span class="line">                     // 否则e为链表，则对链表进行遍历</span><br><span class="line">                     // 低位链表：存放在扩容之后的数组的下标位置，与当前数组下标位置一致</span><br><span class="line">                     // loHead：低位链表头节点</span><br><span class="line">                     // loTail低位链表尾节点</span><br><span class="line">                     Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                     // 高位链表，存放扩容之后的数组的下标位置，=原索引+扩容之前数组容量</span><br><span class="line">                     // hiHead:高位链表头节点</span><br><span class="line">                     // hiTail:高位链表尾节点</span><br><span class="line">                     Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                     Node&lt;K,V&gt; next;</span><br><span class="line">                     do &#123;</span><br><span class="line">                         next = e.next;</span><br><span class="line">                         // 通过 &amp; 运算计算当前结点的hash值是高位为1还是0</span><br><span class="line">                         if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                              // 高位为0，放入低位链表中</span><br><span class="line">                             if (loTail == null)</span><br><span class="line">                                 loHead = e;</span><br><span class="line">                             else</span><br><span class="line">                                 loTail.next = e;</span><br><span class="line">                             loTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                         else &#123;</span><br><span class="line">                             // 高位为1，放入高位链表中</span><br><span class="line">                             if (hiTail == null)</span><br><span class="line">                                 hiHead = e;</span><br><span class="line">                             else</span><br><span class="line">                                 hiTail.next = e;</span><br><span class="line">                             hiTail = e;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; while ((e = next) != null);</span><br><span class="line">                     if (loTail != null) &#123;</span><br><span class="line">                         // 原索引放到bucket里，将低位链表头结点指向原来的索引位置</span><br><span class="line">                         loTail.next = null;</span><br><span class="line">                         newTab[j] = loHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                     if (hiTail != null) &#123;</span><br><span class="line">                         // 原索引+oldCap放到bucket里，将高位链表头结点指向新的索引位置</span><br><span class="line">                         hiTail.next = null;</span><br><span class="line">                         newTab[j + oldCap] = hiHead;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="HashMap面试题总结"><a href="#HashMap面试题总结" class="headerlink" title="HashMap面试题总结"></a>HashMap面试题总结</h2><h3 id="解决Hash冲突的方式有哪些"><a href="#解决Hash冲突的方式有哪些" class="headerlink" title="解决Hash冲突的方式有哪些"></a>解决Hash冲突的方式有哪些</h3><h4 id="（1）开放寻址法"><a href="#（1）开放寻址法" class="headerlink" title="（1）开放寻址法"></a>（1）开放寻址法</h4><p>这种方法也称为再散列法，其基本思想是：当关键字key的哈希地址p&#x3D;H(key)出现冲突时，以p为基础，产生另外一个哈希地址p1，如果p1仍然产生冲突，再以p1为基础，产生另一个哈希地址，直到找出一个不冲突的哈希地址，将相应的元素存入其中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hi = (H(key) + d1) % m</span><br><span class="line">其中i=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>..，s， H(key)为哈希函数，m为哈希表长，di为增量序列</span><br></pre></td></tr></table></figure>

<p>开放寻址法对增量di有三种取法。</p>
<p>（1）线性探测法。di&#x3D;c * i，最简单的情况 c &#x3D; 1</p>
<p>（2）平方探测法，也称二次探测再散列。di &#x3D; 1<sup>2</sup>，-1<sup>2</sup>，2<sup>2</sup>， -2<sup>2</sup>等</p>
<p>（3）随机探测法，di是一伪随机数列</p>
<h4 id="（2）链地址法"><a href="#（2）链地址法" class="headerlink" title="（2）链地址法"></a>（2）链地址法</h4><p>把具有相同哈希地址的关键字的值放在同一个链表中，若选定的哈希表的长度为m，则可将哈希表定义为一个由m个头指针组成的指针数组T，凡是哈希地址为i的界定，均插入到T[i]为头结点的单链表中。T中各分量的初值均应为空。</p>
<h4 id="（3）再哈希法"><a href="#（3）再哈希法" class="headerlink" title="（3）再哈希法"></a>（3）再哈希法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hi = RHi(key) i=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...</span><br></pre></td></tr></table></figure>

<p>RHi均是不同的哈希函数，即在产生冲突时，计算另一个哈希函数地址，直到冲突不再发生。</p>
<h4 id="（4）建立一个公共溢区"><a href="#（4）建立一个公共溢区" class="headerlink" title="（4）建立一个公共溢区"></a>（4）建立一个公共溢区</h4><p>所有关键字和基本表中的关键字为同义词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入公共溢出表。</p>
<h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>（1）<strong>线程安全</strong>：HashMap是非线程安全的，Hashtable是线程安全的。因为Hashtable内部的方法基本都经过了<code>synchronized</code>的修饰。（如果要保证线程安全的话可以使用<code>ConcurrentHashMap</code>）</p>
<p>（2）<strong>效率</strong>：因为线程安全的问题，<code>HashMap</code>要比<code>Hashtable</code>效率高一点，另外，Hashtable基本被淘汰。</p>
<p>（3）<strong>对null key和null value的支持</strong>：HashMap可以存储null的key和value，但null作为键只能有一个，而value可以有多个；Hashtable不允许null键和null值，否则会抛出异常（null 键在计算hash值的时候直接会抛出空指针异常，而null值则会直接抛出空指针异常）。</p>
<p>（4）<strong>初始容量大小和每次扩容大小的不同</strong>：</p>
<ul>
<li>创建时如果不指定容量的初始值，Hashtable默认的初始值大小为11，之后每次扩容，容量变为原来的<code>2n + 1</code>；HashMap默认的初始化大小为16，之后每次扩容，容量变为原来的2倍。</li>
<li>创建时如果给定了容量的初始值，那么Hashtable会直接使用给定的大小，而HashMap则会将其扩充为2的幂次方大小。</li>
</ul>
<p>（5）<strong>底层数据结构</strong>：jdk1.8之后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树之前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转为为红黑树，以减少搜索时间。而Hashtable则没有这样的机制。</p>
<h3 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h3><p>（1）<strong>实现接口</strong>：HashSet实现了Set接口，仅存储对象；而HashMap实现了Map接口，存储的是键值对。</p>
<p>（2）<strong>底层实现</strong>：HashSet的底层就是基于HashMap实现的，HashSet的值就是HashMap的key，HashMap的value是一个Object对象。所以HashSet不允许出现重复值，判断标准也是使用的HashMap的判断标准。</p>
<p>（3）<strong>效率</strong>：HashMap的效率在有的时候会比HashSet高。</p>
<p>HashMap和HashSet在进行存储的时候，都需要计算哈希值，但是HashMap的键的类型，通常是一个字符串或者一个简单的数字。计算该对象（String或者Integer）的哈希值比整个对象的默认的哈希值计算快的多。</p>
<p>所以，如果HashMap的键和HashSet的值是同一个对象，那么效率不会有太大差异，否则HashMap的效率比HashSet高。</p>
<h3 id="HashMap和TreeMap的区别"><a href="#HashMap和TreeMap的区别" class="headerlink" title="HashMap和TreeMap的区别"></a>HashMap和TreeMap的区别</h3><p>（1）<strong>是否线程安全</strong>：两者都不是线程安全的。</p>
<p>（2）<strong>对排序的支持</strong>：HashMap不支持元素排序，而TreeMap支持根据key的顺序来排序。</p>
<p>（3）<strong>对NULL的支持</strong>：HashMap允许一个null key和多个null value，而TreeMap不允许null key，但是允许null value。</p>
<p>（4）<strong>性能区别</strong>：HashMap底层是数组实现的，所以在添加、删除和查找等方法上效率比较高，而TreeMap底层是一个红黑树结构，操作的速度比较慢。并且产生哈希冲突时，红黑树结构还要进行自平衡操作来维持树的平衡，效率比较低。</p>
<h3 id="HashMap的扩容为什么是2倍"><a href="#HashMap的扩容为什么是2倍" class="headerlink" title="HashMap的扩容为什么是2倍"></a>HashMap的扩容为什么是2倍</h3><p>HashMap计算添加元素的位置时，使用的是位运算，使用(n-1)&amp;hash，另外HashMap的初始容量是2的n次幂，扩容也是以2倍的方式扩容，是因为容量是2的n次幂，可以使得元素更加均匀部分在HashMap的数组上，减少hash碰撞，避免形成链表结构，使得查询效率降低。</p>
<h3 id="HashMap为什么链表长度超过8才转为红黑树"><a href="#HashMap为什么链表长度超过8才转为红黑树" class="headerlink" title="HashMap为什么链表长度超过8才转为红黑树"></a>HashMap为什么链表长度超过8才转为红黑树</h3><p>虽然转化为红黑树后，查找的效率会比链表更高，但是树节点占用空间是普通节点的两倍，如果链表节点不够多却转换成红黑树，会耗费大量的空间资源。</p>
<p>从平均查找长度来看，红黑树的平均查找长度是logN，而链表的平均查找长度是n&#x2F;2，所以阈值为8是两种数据结构效率交叉的点。比如长度为6时红黑树退化成链表，是因为两者的平均查找长度相差不大，而红黑树节点占用更多的空间。</p>
<p>理想情况下，在随机hash值下，加载因子为0.75的情况下，节点的频率服从参数平均为0.5的泊松分布，官方做过很多的测试，发现链表长度在大于8以后再出现hash碰撞的可能性几乎为0。</p>
<p>红黑树的转化、左旋右旋保持平衡还是相对耗时的，所以链表长度阈值设置为8就是为了尽量减少HashMap中出现红黑树，从而提高HashMap的效率。</p>
<h3 id="HashMap为什么在数组长度大于64才会进化为红黑树"><a href="#HashMap为什么在数组长度大于64才会进化为红黑树" class="headerlink" title="HashMap为什么在数组长度大于64才会进化为红黑树"></a>HashMap为什么在数组长度大于64才会进化为红黑树</h3><p>在数组比较小时如果出现红黑树结构，反而会降低效率，而红黑树需要进行左旋右旋，变色，这些操作来保持平衡，同时数组长度小于64时，搜索时间相对要快些，总之是为了加快搜索速度，提高性能。</p>
<p>同时官方注释规定，最小的树转化阈值应该是 4 * 链表的最大长度（也就是8），以避免调整大小阈值和树化阈值之间的冲突。</p>
<h3 id="HashMap为什么加载因子设置为0-75，初始化临界值是12"><a href="#HashMap为什么加载因子设置为0-75，初始化临界值是12" class="headerlink" title="HashMap为什么加载因子设置为0.75，初始化临界值是12"></a>HashMap为什么加载因子设置为0.75，初始化临界值是12</h3><p>官方注释：一般来说，默认的加载系数（0.75）提供了一个很好的选择时间和空间成本的权衡。较高的数值会降低空间开销，但是会增加查找成本（反映在大多数hashMap类的操作，如get、put等）。</p>
<p>加载因子越大，填满的元素更多，空间利用率越高，但发生冲突的几率变得更大。加载因子越小，填满的元素越少，发生冲突的几率更小，但是空间利用率更低，而且还会提高扩容rehash的次数。</p>
<p>而初始临界值是<code>threshold(临界值)计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75) </code>，是HashMap衡量数组是否需要扩容的一个标准。</p>
<h3 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key"></a>一般用什么作为HashMap的key</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7183217019343339580">为什么Java中HashMap的key，必须要实现hashCode、equals方法？ - 掘金 (juejin.cn)</a></p>
<p>从HashMap的语法上来讲，一切的对象都可以作为Key值。比如Integer、String、Object等。但是实际上来说，我们最好还是使用一些重写了HashCode()和equals()方法的类来当作HashMap的key，或者说像String这样，每次操作都会生成新的对象的类，天生线程安全的类。</p>
<h3 id="HashMap为什么线程不安全出现的问题"><a href="#HashMap为什么线程不安全出现的问题" class="headerlink" title="HashMap为什么线程不安全出现的问题"></a>HashMap为什么线程不安全出现的问题</h3><h4 id="（1）扩容导致循环链表"><a href="#（1）扩容导致循环链表" class="headerlink" title="（1）扩容导致循环链表"></a>（1）扩容导致循环链表</h4><p><a target="_blank" rel="noopener" href="http://geekdaxue.co/read/chu-meng@01/dylugi">容器框架 - 在JDK1.7下HashMap的死循环问题 - 《初梦 ‘s 学习记录》 - 极客文档 (geekdaxue.co)</a></p>
<p>HashMap在多线程下扩容会导致链表成为环形链表，JDK1.7中HashMap使用头插法插入元素，在多线程的环境下，扩容的时候可能会导致环形链表的出现，这时如果HashMap执行get操作就会形成死循环。因此JDK1.8中使用尾插法插入元素，在扩容的时候会保持链表元素的原本顺序，不会出现环形链表的问题。</p>
<p>死循环如何产生的？</p>
<p>那就是在put操作的时候，如果<code>size&gt;initialCapacity*loadFactor</code>，那么这时候HashMap就会进行rehash操作.并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>
<p>JDK1.7的resize源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>) (newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K, V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过程如下：</p>
<blockquote>
<p>正常rehash的过程：</p>
</blockquote>
<p>假设我们的hash算法就是简单的 key mod size</p>
<p>最上面的时old hash表，其中hash的size &#x3D; 2，所以key &#x3D; 3，5，7，在mod 2 之后冲突都产生在table[1]这里</p>
<p>接下来hash表长度扩容为4，然后所有的key重新rehash</p>
<blockquote>
<p>并发下的rehash</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	Entry&lt;K, V&gt; next = e.next;  <span class="comment">// 线程1执行到此处被调度挂起</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">	e.next = newTable[i];</span><br><span class="line">	newTable[i] = e;</span><br><span class="line">	e = next;</span><br><span class="line">&#125; <span class="keyword">while</span>(e != <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>（1）首先假设我们有两个线程。</p>
<p>当线程1进行rehash时，当节点e指向key3，节点e.next指向key7，这时线程挂起，而线程2已经执行完成，于是会产生以下场景：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://geekdaxue.co/uploads/projects/chu-meng@01/35e4ce1e8047fb777f3351fb9ef52659.png"></p>
<p>注意，此时线程1的节点e的指向为key3，而节点e.next指向为key7，在线程2进行rehash之后，指向了重组之后的链表（使用头插法），链表的顺序被反转。</p>
<p>（2）线程1被调度回来执行，先是执行 newTalbe[i] &#x3D; e， 然后是e &#x3D; next，导致了e指向了key(7)，而下一次循环的next &#x3D; e.next导致了next指向了key(3)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://geekdaxue.co/uploads/projects/chu-meng@01/09eb08a6d0296104ab35d15ebf5226d3.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://geekdaxue.co/uploads/projects/chu-meng@01/f74addb85d735a6031b734905631d5c2.png"></p>
<p>e.next &#x3D; newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://geekdaxue.co/uploads/projects/chu-meng@01/6a403bd72af728e8715093e348f5fcba.png"></p>
<h4 id="（2）put导致元素丢失"><a href="#（2）put导致元素丢失" class="headerlink" title="（2）put导致元素丢失"></a>（2）put导致元素丢失</h4><p>多线程下HashMap的put元素可能会导致元素的丢失。多线程同时执行put操作，如果计算出来的索引位置是相同的，那么可能会造成前一个key被后一个key覆盖，导致元素的丢失。这个问题在JDK1.7和JDK1.8都存在。</p>
<h4 id="（3）put和get并发导致空指针"><a href="#（3）put和get并发导致空指针" class="headerlink" title="（3）put和get并发导致空指针"></a>（3）put和get并发导致空指针</h4><p>在多线程环境下，如果线程1执行put方法时，因为元素个数超过阈值而导致rehash扩容，线程2此时执行get方法，有可能会获取到null值。这个问题在JDK1.7和JDK1.8都存在。</p>
<h3 id="计算hash值时为什么要让低16bit和高16bit进行异或处理"><a href="#计算hash值时为什么要让低16bit和高16bit进行异或处理" class="headerlink" title="计算hash值时为什么要让低16bit和高16bit进行异或处理"></a>计算hash值时为什么要让低16bit和高16bit进行异或处理</h3><p>Hash值其实是一个int类型的数据，二进制为32位。而HashMap的初始容量为16，在进行hash运算的时候，<code>hashCode &amp; 15 ==&gt; hashCode &amp; 1111</code>，这时计算的哈希值只能与第四位进行与操作，也就是说hashCode的高四位其实并没有参与运算，这样会导致很多哈希值不同而高四位有区别的数，计算出来的索引都是一样的，产生较多的哈希冲突。</p>
<p>为了避免这种情况，HashMap将高16位与第16位进行异或操作，这样可以保证高位的数据也能参与到hash值的计算当中，以增加索引的散列程序，让数据分布的更加均匀。</p>
<h3 id="什么方法可以解决HashMap不安全"><a href="#什么方法可以解决HashMap不安全" class="headerlink" title="什么方法可以解决HashMap不安全"></a>什么方法可以解决HashMap不安全</h3><p>（1）<strong>通过<code>Collections.synchronizedMap</code>返回一个线程安全的Map</strong>。不推荐使用，因为底层维护一个锁对象，所有的操作都需要通过这个锁对象，效率比较低。</p>
<p>（2）<strong>使用Hashtable</strong>。Hashtable是线程安全的集合类，但是已经被废弃了。</p>
<p>（3）<strong>使用ConcurrentHashMap代替HashMap</strong>。ConcurrentHashMap采用分段锁思想灵活保证线程操作的安全，效率相对于直接加锁更好。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 实现说明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个映射通常作为一个binned(桶)哈希表，但是当桶变得太大时，</span></span><br><span class="line"><span class="comment">     * 它们被转换成treenode的桶，每个节点的结构与java.util.TreeMap中的相似。</span></span><br><span class="line"><span class="comment">     * 大多数方法尝试使用正常的桶，但在适用的情况下中继到TreeNode方法(只需通过检查节点的instanceof)。</span></span><br><span class="line"><span class="comment">     * TreeNodes的桶可以像其他桶一样遍历和使用，但在填充过多时还支持更快的查找。</span></span><br><span class="line"><span class="comment">     * 然而，由于绝大多数正常使用的容器都没有过度填充，因此检查树容器是否存在可能会在表方法的过程中被延迟。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 树桶(即，其元素都是treenode的桶)主要由hashCode排序，但在关联的情况下，</span></span><br><span class="line"><span class="comment">     * 如果两个元素属于相同的“类C实现Comparable&lt;C&gt;”，则键入它们的compareTo方法用于排序。</span></span><br><span class="line"><span class="comment">     * (我们通过反射保守地检查泛型类型来验证这一点——参见方法comparableClassFor)。</span></span><br><span class="line"><span class="comment">     * 当键具有不同的哈希值或可排序时，树桶增加的复杂性在提供最坏情况O(log n)操作方面是值得的，</span></span><br><span class="line"><span class="comment">     * 因此，在意外或恶意使用hashCode()方法返回分布不佳的值以及许多键共享hashCode的情况下，</span></span><br><span class="line"><span class="comment">     * 只要它们也是可比较的，性能就会优雅地下降。</span></span><br><span class="line"><span class="comment">     * (如果这两项都不适用，与不采取预防措施相比，我们可能会浪费大约两倍的时间和空间。</span></span><br><span class="line"><span class="comment">     * 但唯一已知的案例源于糟糕的用户编程实践，这些实践已经非常缓慢，以至于这几乎没有什么区别。)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为treenode的大小大约是常规节点的两倍，所以我们只在桶包含足够的节点以保证使用时才使用它们</span></span><br><span class="line"><span class="comment">     * (参见TREEIFY_THRESHOLD)。当它们变得太小(由于移除或调整大小)时，它们被转换回普通的桶。</span></span><br><span class="line"><span class="comment">     * 在用户hashCodes分布良好的用法中，很少使用树桶。</span></span><br><span class="line"><span class="comment">     * 理想情况下，在随机hashCodes下，箱中节点的频率遵循</span></span><br><span class="line"><span class="comment">     * 泊松分布(http://en.wikipedia.org/wiki/Poisson_distribution)，</span></span><br><span class="line"><span class="comment">     * 默认调整大小阈值为0.75，参数平均约为0.5，尽管由于调整大小粒度而存在很大差异。</span></span><br><span class="line"><span class="comment">     * 忽略方差，列表大小k的预期出现次数为(exp(-0.5) * pow(0.5, k) / factorial(k))。第一个值是:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:    0.60653066</span></span><br><span class="line"><span class="comment">     * 1:    0.30326533</span></span><br><span class="line"><span class="comment">     * 2:    0.07581633</span></span><br><span class="line"><span class="comment">     * 3:    0.01263606</span></span><br><span class="line"><span class="comment">     * 4:    0.00157952</span></span><br><span class="line"><span class="comment">     * 5:    0.00015795</span></span><br><span class="line"><span class="comment">     * 6:    0.00001316</span></span><br><span class="line"><span class="comment">     * 7:    0.00000094</span></span><br><span class="line"><span class="comment">     * 8:    0.00000006</span></span><br><span class="line"><span class="comment">     * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 树桶的根通常是它的第一个节点。然而，有时(目前仅在Iterator.remove上)，</span></span><br><span class="line"><span class="comment">     * 根可能在其他地方，但可以通过父链接(方法TreeNode.root())恢复。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所有适用的内部方法都接受哈希码作为参数(通常由公共方法提供)，允许它们相互调用而无需重新计算用户哈希码。</span></span><br><span class="line"><span class="comment">     * 大多数内部方法也接受“tab”参数，通常是当前表，但在调整大小或转换时可能是新表或旧表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当bin列表被树化、拆分或非树化时，我们将它们保持相同的相对访问/遍历顺序(即字段Node.next)，</span></span><br><span class="line"><span class="comment">     * 以更好地保留局部性，并稍微简化调用iterator.remove的拆分和遍历处理。</span></span><br><span class="line"><span class="comment">     * 当在插入时使用比较器时，为了在重新平衡中保持总排序(或尽可能接近)，我们比较类和identityHashCodes作为决定因素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 由于子类LinkedHashMap的存在，普通模式与树模式之间的使用和转换变得复杂。</span></span><br><span class="line"><span class="comment">     * 请参阅下面定义的在插入、删除和访问时调用的钩子方法，这些方法允许LinkedHashMap</span></span><br><span class="line"><span class="comment">     * 内部保持独立于这些机制。(这还需要将映射实例传递给一些可能创建新节点的实用程序方法。)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 类似于并发编程的基于ssa的编码风格有助于避免在所有扭曲指针操作中出现混叠错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量-必须是2的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果隐式指定了更大的值，则使用最大容量。</span></span><br><span class="line"><span class="comment">     * 由任意一个带参数的构造函数调用。必须是2的幂&lt;= 1&lt;&lt;30。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在构造函数中未指定时使用的负载因子（默认负载因子）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用树而不是列表的bin计数阈值。当向至少有这么多节点的桶中添加元素时，桶将转换为树。</span></span><br><span class="line"><span class="comment">     * 该值必须大于2，并且应该至少为8，以符合在树木移除中关于收缩后转换回普通桶的假设。</span></span><br><span class="line"><span class="comment">     * （当桶上的节点数大于等于该值会由链表转换成红黑树）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调整大小操作期间取消树化(拆分)bin的bin计数阈值。</span></span><br><span class="line"><span class="comment">     * 应小于TREEIFY_THRESHOLD，且最多为6，以便在移除时进行收缩检测。</span></span><br><span class="line"><span class="comment">     *（当桶上的节点数小于等于该值会由红黑树转换成链表）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以对桶进行树化的最小表容量。(否则，如果一个bin中的节点太多，则会调整表的大小。)</span></span><br><span class="line"><span class="comment">     * 应该至少为4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间的冲突。</span></span><br><span class="line"><span class="comment">     *（桶中结构转换为红黑树对应的table的最小容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本哈希bin节点，用于大多数条目。(参见下面的TreeNode子类，以及LinkedHashMap中的Entry子类。)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// 哈希值，存放元素到hashMap中时用来与其他元素的hash值比较</span></span><br><span class="line">        <span class="keyword">final</span> K key; <span class="comment">// 键</span></span><br><span class="line">        V value; <span class="comment">// 值</span></span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 指向下一个节点 </span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算key.hashCode()并将哈希的高位数扩展到低位数。</span></span><br><span class="line"><span class="comment">     * 因为表使用了2的幂掩码，所以在当前掩码之上只变化几比特的哈希集总是会发生冲突。</span></span><br><span class="line"><span class="comment">     * (其中一个已知的例子是在小表格中保存连续整数的Float键集。)</span></span><br><span class="line"><span class="comment">     * 因此，我们应用一个变换，将高比特的影响向下扩散。比特传播的速度、效用和质量之间存在权衡。</span></span><br><span class="line"><span class="comment">     * 由于许多常见的哈希集已经合理分布(因此不会从扩展中受益)，并且由于我们使用树来处理箱中的大型碰撞集，</span></span><br><span class="line"><span class="comment">     * 因此我们只是以最便宜的方式对一些移位的位进行异或，以减少系统损失，并合并最高位的影响，</span></span><br><span class="line"><span class="comment">     * 否则由于表边界的原因，这些位在索引计算中永远不会使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果x的Class是&quot; Class C implements Comparable&lt;C&gt;&quot;的形式，则返回它的Class，否则返回null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果x匹配kc (k筛选的可比较类)，则返回k. compareto (x)，否则为0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="literal">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回给定目标容量的2次幂大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表，在第一次使用时初始化，并根据需要调整大小。</span></span><br><span class="line"><span class="comment">     * 在分配时，长度总是2的幂。(我们也允许某些操作的长度为零，以允许目前不需要的引导机制。)</span></span><br><span class="line"><span class="comment">     * （存储元素的数组，总是2的幂次方）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存缓存的entrySet()。注意，AbstractMap字段用于keySet()和values()。</span></span><br><span class="line"><span class="comment">     * （存放具体元素的集）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此映射中包含的键值映射的数量。</span></span><br><span class="line"><span class="comment">     *（存放元素的个数，注意，这个不等于数组的长度）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改是指改变HashMap中的映射数量或以其他方式修改其内部结构(例如，重新散列)。</span></span><br><span class="line"><span class="comment">     * 该字段用于使HashMap的集合视图上的迭代器快速失败。(见ConcurrentModificationException)。</span></span><br><span class="line"><span class="comment">     *（每次扩容和更改map结构的计数器）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要调整大小的下一个大小值(容量*负载因子)。</span></span><br><span class="line"><span class="comment">     * （阈值，当实际大小超过阈值时，会进行扩容）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (序列化时javadoc描述为真。</span></span><br><span class="line">    <span class="comment">// 另外，如果表数组没有被分配</span></span><br><span class="line">    <span class="comment">// 字段保存初始数组容量，或者零表示</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY)。</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表的负载因子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造具有指定初始容量和负载因子的空HashMap。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//指定的容量大小不可以小于0,否则将抛出IllegalArgumentException异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//判定指定的容量大小是否大于HashMap的容量极限</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="comment">//指定的负载因子不可以小于0或为NaN，若判定成立则抛出IllegalArgumentException异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 初始容量暂时放到threshold，在resize中再赋值给newCap进行table初始化</span></span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        <span class="comment">//tableSizeFor用于查找到大于给定数值的最近2次幂值，比如给定18就是32。给定33就是64</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的初始值构造一个空的HashMap容量和默认负载因子(0.75)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认初始容量(16)和默认负载因子(0.75)构造一个空的HashMap。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个与指定Map具有相同映射的新HashMap。</span></span><br><span class="line"><span class="comment">     * HashMap是用默认负载因子(0.75)创建的，初始容量足以在指定的Map中保存映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了Map.putAll和Map的构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断map是否已经初始化</span></span><br><span class="line">            <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">                <span class="comment">// ft = s/loadFactor =&gt; s = ft*loadFactor</span></span><br><span class="line">                <span class="comment">// ft指的是要添加s个元素所需的最小容量</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    <span class="comment">// table未初始化，threshold实际上存放的是初始化容量</span></span><br><span class="line">                    <span class="comment">// 如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近2的幂次方大小作为初始化</span></span><br><span class="line">                    <span class="comment">// 注意，这里不是初始化阈值</span></span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                <span class="comment">// 已经初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">                resize();</span><br><span class="line">            <span class="comment">// 将m中所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize()初始化或者扩容</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此映射中键值映射的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此映射不包含键值映射，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定键映射到的值，如果此映射不包含该键的映射，则返回null。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 更正式地说，如果这个映射包含一个从键k到值v的映射，</span></span><br><span class="line"><span class="comment">     * 使得(key==null ?K ==null: key.equals(K))，则此方法返回v;否则返回null。(最多只能有一个这样的映射。)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回值为null并不一定表示映射不包含该键的映射;也有可能映射显式地将键映射为null。</span></span><br><span class="line"><span class="comment">     * containsKey操作可以用来区分这两种情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了Map.get相关方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此映射包含指定键的映射，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定值与此映射中的指定键关联。如果映射以前包含键的映射，则替换旧值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了Map.put和相关方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// table未初始化或者长度为0，则进行扩容</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">			<span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中</span></span><br><span class="line">            <span class="comment">// 桶为空，新生成节点放入桶中（此时，这个结点是放在数组中）</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 桶中已经存在元素，处理hash冲突</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 快速判断第一个节点table[i]的key是否与插入的key一样</span></span><br><span class="line">                <span class="comment">// 若相同则直接使用插入的p值替换掉旧的值e</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 插入的节点是红黑树节点，放入树中</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 插入的节点是链表节点</span></span><br><span class="line">                <span class="comment">// 在链表的最末端插入节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 在尾部掺入新节点 </span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">// 如果节点数量达到阈值（默认为8），执行treeifyBin方法</span></span><br><span class="line">                            <span class="comment">// 根据HashMap数组来决定是否转换为红黑树 </span></span><br><span class="line">                            <span class="comment">// 只有当数组长度大于或者等于64的情况下，才会执行红黑树操作，减少搜索次数</span></span><br><span class="line">                            <span class="comment">// 否则，只是对数组扩容</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="comment">// 如果链表节点的key与插入元素的key相等，跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 用于遍历桶中的链表，与前面的 e = p.next组合，遍历链表</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">// 在桶中找到key值、hash值与插入元素相等的节点 </span></span><br><span class="line">                <span class="comment">// 记录e的value</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// onlyIfAbsent为false或者oldValue为null，用新值替换旧值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 访问后回调 </span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">// 返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount; <span class="comment">// 结构性修改</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">// 如果实际大小大于阈值则扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict); <span class="comment">// 插入后回调</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化或加倍表大小。如果为空，则按照字段阈值中持有的初始容量目标进行分配。</span></span><br><span class="line"><span class="comment">     * 否则，由于我们使用的是2的幂展开，因此每个桶中的元素必须保持在相同的索引上，或者在新表中以2的幂偏移量移动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 原数组如果为空，则长度赋值为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果原数组长度大于0，说明HashMap已经初始化过了，是一次正常的扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 判断旧的容量是否大于容量最大值(2^30)，如果是，则无法扩容，那么修改阈值为 Integer.MAX_VALUE</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// // 原数组长度大于等于初始化长度16，并且原数组长度扩大1倍也小于 2^30次方，扩容为原来的2倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量被置于阈值</span></span><br><span class="line">            <span class="comment">// 如果旧容量 = 0 且 旧阈值 &gt; 0，说明是通过构造方法创建的HashMap</span></span><br><span class="line">        	<span class="comment">// 新容量直接等于旧阈值</span></span><br><span class="line">            <span class="comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 零初始阈值表示使用默认值</span></span><br><span class="line">            <span class="comment">// 无参构造函数创建的对象在这里计算容量和阈值</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">// 数组长度初始化为16 </span></span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 数组阈值初始化为12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化</span></span><br><span class="line">            <span class="comment">// 或者扩容前旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr; <span class="comment">// 更新</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前桶位数据不为空，但是不能判断是链表还是红黑树结构</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">// 如果e结点不存在下一个结点，说明e是单个元素，则直接放入新数组的对应位置</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// 将红黑树拆分成两棵子树，如果子树节点小于等于UNTREEIFY_THRESHOLD（默认为 6），</span></span><br><span class="line">                        <span class="comment">// 则将子树转换为链表，否则保持子树的树结构</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 否则e为链表，则对链表进行遍历</span></span><br><span class="line">                        <span class="comment">// 低位链表：存放在扩容之后的数组的下标位置，与当前数组下标位置一致</span></span><br><span class="line">                        <span class="comment">// loHead：低位链表头节点</span></span><br><span class="line">                        <span class="comment">// loTail低位链表尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 高位链表，存放扩容之后的数组的下标位置，=原索引+扩容之前数组容量</span></span><br><span class="line">                        <span class="comment">// hiHead:高位链表头节点</span></span><br><span class="line">                        <span class="comment">// hiTail:高位链表尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 通过 &amp; 运算计算当前结点的hash值是高位为1还是0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                 <span class="comment">// 高位为0，放入低位链表中</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 高位为1，放入高位链表中</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引放到bucket里，将低位链表头结点指向原来的索引位置</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引+oldCap放到bucket里，将高位链表头结点指向新的索引位置</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换节点中给定哈希索引处的所有链接节点，除非表太小，在这种情况下调整大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定映射中的所有映射复制到此映射。这些映射将替换此映射对指定映射中当前任何键的任何映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此映射中删除指定键的映射(如果存在)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现Map.remove和相关方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从该映射中删除所有映射。这个调用返回后，映射将为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此映射将一个或多个键映射到指定值，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此映射中包含的键的Set视图。集合由映射支持，因此对映射的更改反映在集合中，反之亦然。</span></span><br><span class="line"><span class="comment">     * 如果在对set进行迭代时修改map(通过迭代器自己的remove操作除外)，则迭代的结果是未定义的。</span></span><br><span class="line"><span class="comment">     * set支持移除元素，即通过Iterator从map中移除对应的映射。remove,Set.remove, removeAll, retainAll和clear操作。</span></span><br><span class="line"><span class="comment">     * 它不支持add或addAll操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此映射中包含的值的集合视图。集合由映射支持，因此对映射的更改将反映在集合中，反之亦然。</span></span><br><span class="line"><span class="comment">     * 如果在对集合进行迭代时修改map(通过迭代器自己的remove操作除外)，则迭代的结果是未定义的。</span></span><br><span class="line"><span class="comment">     * 该集合支持移除元素，即通过Iterator从map中移除对应的映射。Iterator.remove,Collection.remove,removeAll, retainAll和clear操作。</span></span><br><span class="line"><span class="comment">     * 它不支持add或addAll操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">            vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Values</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueIterator</span>(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueSpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此映射中包含的映射的Set视图。集合由映射支持，因此对映射的更改反映在集合中，反之亦然。</span></span><br><span class="line"><span class="comment">     * 如果在对set进行迭代时修改map(通过迭代器自己的remove操作或通过对迭代器返回的map项执行setValue操作除外)，</span></span><br><span class="line"><span class="comment">     * 则迭代的结果是未定义的。set支持移除元素，即通过Iterator从map中移除对应的映射。Iterator.remove, Set.remove, removeAll, retainAll和clear操作。</span></span><br><span class="line"><span class="comment">     * 它不支持add或addAll操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntryIterator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="literal">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                             Function&lt;? <span class="built_in">super</span> K, ? extends V&gt; mappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="literal">null</span> &amp;&amp; (oldValue = old.value) != <span class="literal">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                              BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(K key,</span></span><br><span class="line"><span class="params">                     BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> (old == <span class="literal">null</span>) ? <span class="literal">null</span> : old.value;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">                   BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="literal">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="literal">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; function)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="title function_">loadFactor</span><span class="params">()</span> &#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="literal">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buckets</span> <span class="operator">=</span> capacity();</span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes this map from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException if the class of a serialized object</span></span><br><span class="line"><span class="comment">     *         could not be found</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException if an I/O error occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">fields</span> <span class="operator">=</span> s.readFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read loadFactor (ignore threshold)</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> fields.get(<span class="string">&quot;loadFactor&quot;</span>, <span class="number">0.75f</span>);</span><br><span class="line">        <span class="keyword">if</span> (lf &lt;= <span class="number">0</span> || Float.isNaN(lf))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + lf);</span><br><span class="line"></span><br><span class="line">        lf = Math.min(Math.max(<span class="number">0.25f</span>, lf), <span class="number">4.0f</span>);</span><br><span class="line">        HashMap.UnsafeHolder.putLoadFactor(<span class="built_in">this</span>, lf);</span><br><span class="line"></span><br><span class="line">        reinitialize();</span><br><span class="line"></span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> + mappings);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// use defaults</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">            <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support for resetting final field during deserializing</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UnsafeHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">UnsafeHolder</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.<span class="type">Unsafe</span> <span class="variable">unsafe</span></span><br><span class="line">                <span class="operator">=</span> sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> LF_OFFSET;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LF_OFFSET = unsafe.objectFieldOffset(HashMap.class.getDeclaredField(<span class="string">&quot;loadFactor&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putLoadFactor</span><span class="params">(HashMap&lt;?, ?&gt; map, <span class="type">float</span> lf)</span> &#123;</span><br><span class="line">            unsafe.putFloat(map, LF_OFFSET, lf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HashIterator</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="type">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="type">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="literal">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">nextNode</span><span class="params">()</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="literal">null</span> &amp;&amp; (t = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            current = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;K&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ValueIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;V&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntryIterator</span> <span class="keyword">extends</span> <span class="title class_">HashIterator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.Entry&lt;K,V&gt; <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// spliterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">        <span class="type">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="type">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">        <span class="type">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">        <span class="type">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="type">int</span> origin,</span><br><span class="line">                           <span class="type">int</span> fence, <span class="type">int</span> est,</span><br><span class="line">                           <span class="type">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="built_in">this</span>.map = m;</span><br><span class="line">            <span class="built_in">this</span>.index = origin;</span><br><span class="line">            <span class="built_in">this</span>.fence = fence;</span><br><span class="line">            <span class="built_in">this</span>.est = est;</span><br><span class="line">            <span class="built_in">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getFence</span><span class="params">()</span> &#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">            <span class="type">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == <span class="literal">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span> &#123;</span><br><span class="line">            getFence(); <span class="comment">// force init</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;K&gt; &#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="type">int</span> origin, <span class="type">int</span> fence, <span class="type">int</span> est,</span><br><span class="line">                       <span class="type">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="built_in">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="literal">null</span>) ? <span class="literal">null</span> :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="literal">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="literal">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="literal">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="literal">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ValueSpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;V&gt; &#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="type">int</span> origin, <span class="type">int</span> fence, <span class="type">int</span> est,</span><br><span class="line">                         <span class="type">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="built_in">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="literal">null</span>) ? <span class="literal">null</span> :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ValueSpliterator</span>&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="literal">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="literal">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="literal">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="literal">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">HashMapSpliterator</span>&lt;K,V&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="type">int</span> origin, <span class="type">int</span> fence, <span class="type">int</span> est,</span><br><span class="line">                         <span class="type">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="built_in">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="literal">null</span>) ? <span class="literal">null</span> :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="literal">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="literal">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="literal">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">            <span class="type">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="literal">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="literal">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following package-protected methods are designed to be</span></span><br><span class="line"><span class="comment">     * overridden by LinkedHashMap, but not by any other subclass.</span></span><br><span class="line"><span class="comment">     * Nearly all other internal methods are also package-protected</span></span><br><span class="line"><span class="comment">     * but are declared final, so can be used by LinkedHashMap, view</span></span><br><span class="line"><span class="comment">     * classes, and HashSet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reinitialize</span><span class="params">()</span> &#123;</span><br><span class="line">        table = <span class="literal">null</span>;</span><br><span class="line">        entrySet = <span class="literal">null</span>;</span><br><span class="line">        keySet = <span class="literal">null</span>;</span><br><span class="line">        values = <span class="literal">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tree节点结构。LinkedHashMap延伸。结构(又扩展Node)，因此可以用作常规节点或链接节点的扩展。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 红黑树链接，父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left; <span class="comment">// 左子树 </span></span><br><span class="line">        TreeNode&lt;K,V&gt; right; <span class="comment">// 右子树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 需要在删除后解除链接</span></span><br><span class="line">        <span class="type">boolean</span> red; <span class="comment">// 判断颜色的标识</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回包含此节点的树的根。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 确保给定的根是其桶的第一个节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用给定的散列和键查找从根p开始的节点。</span></span><br><span class="line"><span class="comment">         * kc参数在第一次使用比较键时缓存comparableClassFor(key)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对根节点调用find</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当hashCodes相等且不可比较时，用于排序插入的Tie-breaking实用程序。</span></span><br><span class="line"><span class="comment">         * 我们不需要一个总顺序，只需要一个一致的插入规则来保持跨再平衡的等价性。不必要的断线进一步简化了测试。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 形成从该节点链接的节点的树</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="literal">null</span>;</span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="type">int</span> dir, ph;</span><br><span class="line">                        <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回非treenode的列表，替换从该节点链接的那些节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * putVal的树版本</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除在此调用之前必须存在的给定节点。</span></span><br><span class="line"><span class="comment">         * 这比典型的红黑删除代码更混乱，因为我们不能将内部节点的内容与由在遍历期间可独立访问的“next”指针固定的叶继承节点交换。</span></span><br><span class="line"><span class="comment">         * 所以我们交换树形连杆。如果当前树的节点太少，则将该二进制文件转换回普通二进制文件。</span></span><br><span class="line"><span class="comment">         * (测试触发2到6个节点，这取决于树的结构)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                  <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="literal">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">null</span></span><br><span class="line">                || (movable</span><br><span class="line">                    &amp;&amp; (root.right == <span class="literal">null</span></span><br><span class="line">                        || (rl = root.left) == <span class="literal">null</span></span><br><span class="line">                        || rl.left == <span class="literal">null</span>))) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将树仓中的节点拆分为上树仓和下树仓，如果太小则拆分为非树仓。</span></span><br><span class="line"><span class="comment">         * 只能从resize中调用;参见上面关于分割位和索引的讨论。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// 红黑树方法，全部改编自CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">                    (root = r).red = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">                    (root = l).red = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">            x.red = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="literal">false</span>;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="literal">false</span>;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="literal">null</span> || x == root)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = <span class="literal">false</span>;</span><br><span class="line">                        xp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="literal">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = <span class="literal">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="literal">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="literal">null</span>)</span><br><span class="line">                                    sl.red = <span class="literal">false</span>;</span><br><span class="line">                                xpr.red = <span class="literal">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                                    <span class="literal">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">                                    sr.red = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="literal">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="literal">false</span>;</span><br><span class="line">                        xp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="literal">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="literal">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">                                    sr.red = <span class="literal">false</span>;</span><br><span class="line">                                xpl.red = <span class="literal">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                                    <span class="literal">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">                                    sl.red = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="literal">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递归不变检验</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="literal">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="literal">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="literal">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="literal">null</span> &amp;&amp; tr.red)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小奥</div><div class="post-copyright__author_desc">浮生若梦 为欢几何</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/')">Java集合之HashMap源码篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java集合之HashMap源码篇&amp;url=http://example.com/2024/01/12/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E7%AF%87/&amp;pic=/img/png/17.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小奥</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">13</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/HashMap/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>HashMap<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/png/8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/12/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E3%80%81%E7%A7%92%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大文件分片、秒传、断点续传</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/13/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedList%E6%BA%90%E7%A0%81%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/13.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java集合之LinkedList源码篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">Java、数据库、中间件</b>相关的学习笔记，还有<b style="color:#fff">面试题总结</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小奥</h1><div class="author-info__desc">浮生若梦 为欢几何</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoaozz" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Java集合之HashMap源码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">底层数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0-hash"><span class="toc-number">1.4.</span> <span class="toc-text">扰动函数(hash)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">put()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">get()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#resize-%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">resize()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK7%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.7.1.</span> <span class="toc-text">JDK7的扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">JDK8的扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">HashMap面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.8.1.</span> <span class="toc-text">解决Hash冲突的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">（1）开放寻址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">（2）链地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">（3）再哈希法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E6%BA%A2%E5%8C%BA"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">（4）建立一个公共溢区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.2.</span> <span class="toc-text">HashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.3.</span> <span class="toc-text">HashMap和HashSet的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.4.</span> <span class="toc-text">HashMap和TreeMap的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E5%80%8D"><span class="toc-number">1.8.5.</span> <span class="toc-text">HashMap的扩容为什么是2倍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E8%B6%85%E8%BF%878%E6%89%8D%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.8.6.</span> <span class="toc-text">HashMap为什么链表长度超过8才转为红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E64%E6%89%8D%E4%BC%9A%E8%BF%9B%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.8.7.</span> <span class="toc-text">HashMap为什么在数组长度大于64才会进化为红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%AE%BE%E7%BD%AE%E4%B8%BA0-75%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%B4%E7%95%8C%E5%80%BC%E6%98%AF12"><span class="toc-number">1.8.8.</span> <span class="toc-text">HashMap为什么加载因子设置为0.75，初始化临界值是12</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84key"><span class="toc-number">1.8.9.</span> <span class="toc-text">一般用什么作为HashMap的key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.10.</span> <span class="toc-text">HashMap为什么线程不安全出现的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%89%A9%E5%AE%B9%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.8.10.1.</span> <span class="toc-text">（1）扩容导致循环链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89put%E5%AF%BC%E8%87%B4%E5%85%83%E7%B4%A0%E4%B8%A2%E5%A4%B1"><span class="toc-number">1.8.10.2.</span> <span class="toc-text">（2）put导致元素丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89put%E5%92%8Cget%E5%B9%B6%E5%8F%91%E5%AF%BC%E8%87%B4%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.8.10.3.</span> <span class="toc-text">（3）put和get并发导致空指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97hash%E5%80%BC%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A9%E4%BD%8E16bit%E5%92%8C%E9%AB%9816bit%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%88%96%E5%A4%84%E7%90%86"><span class="toc-number">1.8.11.</span> <span class="toc-text">计算hash值时为什么要让低16bit和高16bit进行异或处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3HashMap%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.8.12.</span> <span class="toc-text">什么方法可以解决HashMap不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.9.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/04/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/" title="Java并发之synchronized详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之synchronized详解"/></a><div class="content"><a class="title" href="/2024/02/04/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/" title="Java并发之synchronized详解">Java并发之synchronized详解</a><time datetime="2024-02-04T12:26:07.000Z" title="发表于 2024-02-04 20:26:07">2024-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之AQS源码篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之AQS源码篇"/></a><div class="content"><a class="title" href="/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之AQS源码篇">Java并发之AQS源码篇</a><time datetime="2024-01-29T12:26:17.000Z" title="发表于 2024-01-29 20:26:17">2024-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之ReentrantLock源码篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/22.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之ReentrantLock源码篇"/></a><div class="content"><a class="title" href="/2024/01/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之ReentrantLock源码篇">Java并发之ReentrantLock源码篇</a><time datetime="2024-01-28T12:08:06.000Z" title="发表于 2024-01-28 20:08:06">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3OOM/" title="带你学习如何排查和解决OOM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="带你学习如何排查和解决OOM"/></a><div class="content"><a class="title" href="/2024/01/25/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3OOM/" title="带你学习如何排查和解决OOM">带你学习如何排查和解决OOM</a><time datetime="2024-01-25T12:18:47.000Z" title="发表于 2024-01-25 20:18:47">2024-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/22/Java%E4%B9%8BBigDecimal%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Java之BigDecimal使用正确姿势"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/22.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java之BigDecimal使用正确姿势"/></a><div class="content"><a class="title" href="/2024/01/22/Java%E4%B9%8BBigDecimal%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Java之BigDecimal使用正确姿势">Java之BigDecimal使用正确姿势</a><time datetime="2024-01-22T13:51:24.000Z" title="发表于 2024-01-22 21:51:24">2024-01-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="小奥" target="_blank">小奥</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">12</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 0.88rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 0.88rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 0.88rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 0.88rem;">Feed流<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 0.88rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 0.88rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 0.88rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 0.88rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 0.88rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 0.88rem;">ReentrantLock<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 0.88rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 0.88rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 0.88rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 0.88rem;">synchronized<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 0.88rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 0.88rem;">文件上传<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">算法模板<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8956954060&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小奥 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>