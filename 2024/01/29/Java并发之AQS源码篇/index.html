<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java并发之AQS源码篇 | 小奥</title><meta name="keywords" content="AQS"><meta name="author" content="小奥,3189137314@qq.com"><meta name="copyright" content="小奥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java并发之AQS源码篇"><meta name="application-name" content="Java并发之AQS源码篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java并发之AQS源码篇"><meta property="og:url" content="http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/index.html"><meta property="og:site_name" content="小奥"><meta property="og:description" content="Java并发之AQS源码篇二、完整源码以下源码版本为JDK8。 package java.util.concurrent.locks;import java.util.concurrent.TimeUnit;import java.util.ArrayList;import java.util.Co"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/png/3.png"><meta property="article:author" content="小奥"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/png/3.png"><meta name="description" content="Java并发之AQS源码篇二、完整源码以下源码版本为JDK8。 package java.util.concurrent.locks;import java.util.concurrent.TimeUnit;import java.util.ArrayList;import java.util.Co"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 编程知识爱好者","🔍 分享与热心帮助","🏠 面试总结小能手","🔨 设计开发一条龙","🤝 源码阅读与解析","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小奥","link":"链接: ","source":"来源: 小奥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小奥',
  title: 'Java并发之AQS源码篇',
  postAI: '',
  pageFillDescription: 'Java并发之AQS源码篇, 二、完整源码并发之源码篇二完整源码以下源码版本为为实现依赖先进先出等待队列的阻塞锁和相关同步器信号量事件等提供了一个框架该类被设计为大多数类型的同步器的有用基础这些同步器依赖于单个原子值来表示状态子类必须定义改变这种状态的受保护方法这些方法定义了该对象被获取或释放时该状态的含义考虑到这些这个类中的其他方法执行所有排队和阻塞机制子类可以维护其他状态字段但是只有使用和方法操纵的自动更新的值才会跟踪同步子类应该定义为非公共的内部助手类用于实现其外围类的同步属性类不实现任何同步接口相反它定义了诸如之类的方法具体锁和相关同步器可以在适当的时候调用这些方法来实现它们的公共方法该类支持默认独占模式和共享模式当以独占模式获取时其他线程的尝试获取无法成功多线程获取共享模式可能但不需要成功这个类不理解这些差异除非从机械意义上说当共享模式获取成功时下一个等待线程如果存在也必须确定它是否也可以获取在不同模式下等待的线程共享同一个队列通常实现子类只支持这些模式中的一种但这两种模式都可以发挥作用例如在中仅支持独占模式或仅支持共享模式的子类不需要定义支持未使用模式的方法这个类定义了一个嵌套的类它可以被支持独占模式的子类用作实现在这种模式下方法报告是否对当前线程独占保持同步使用当前值调用的方法完全释放该对象并且在给定此保存的状态值的情况下获取最终将该对象恢复到其先前获取的状态方法不会创建这样的条件所以如果不能满足此约束就不要使用它的行为当然取决于其同步器实现的语义该类为内部队列提供了检查检测和监视方法也为条件对象提供了类似的方法可以根据需要使用为其同步机制将这些导出到类中该类的序列化仅存储维护状态的底层原子整数因此反序列化的对象具有空线程队列需要可序列化性的典型子类将定义一个方法在反序列化时将其恢复到已知的初始状态要使用这个类作为同步器的基础通过使用和或检查和或修改同步状态重新定义以下方法默认情况下这些方法都会抛出这些方法的实现必须是内部线程安全的通常应该是简短的而不是阻塞的定义这些方法是唯一支持的使用该类的方法所有其他方法都被声明为因为它们不能独立变化您可能还会发现从继承的方法对于跟踪拥有独占同步器的线程非常有用我们鼓励您使用它们这使得监视和诊断工具能够帮助用户确定哪些线程持有锁尽管这个类是基于内部队列的但它不会自动执行获取策略排他同步的核心是如果线程尚未排队则进入队列可能阻塞当前线程解除第一个排队线程的阻塞共享模式类似但可能涉及级联信号因为获取中的检查是在排队之前调用的所以新获取的线程可能会抢在其他被阻塞和排队的线程前面但是如果需要您可以定义和或通过内部调用一个或多个检查方法来禁用闯入从而提供公平的获取顺序特别是大多数公平同步器可以将定义为在前一个专门为公平同步器使用的方法返回时返回其他变化也是可能的吞吐量和可伸缩性对于默认的驳船也称为贪心放弃和护航回避策略通常是最高的虽然这不能保证公平或无饥饿但允许较早排队的线程在较晚排队的线程之前重新争用并且每次重新争用对传入线程都有一个无偏的成功机会此外虽然不会像通常意义上那样旋转但它们可能会在阻塞之前执行与其他计算穿插的的多次调用当独占同步只是短暂地保持时这提供了自旋的大部分好处而在不保持独占同步时则没有大部分缺点如果需要您可以通过在调用之前使用快速路径检查来获取方法来增加这一点可能会预先检查和或以便仅在同步器可能不会被争用时才这样做这个类为同步提供了一个高效和可扩展的基础部分是通过将其使用范围专化到可以依赖于状态获取和释放参数的同步器以及一个内部等待队列如果这还不够您可以使用原子类您自己的自定义类和阻塞支持从较低级别构建同步器使用示例下面是一个不可重入互斥锁类它使用值表示未锁定状态表示锁定状态虽然不可重入锁并不严格要求记录当前所有者线程但这个类还是这样做了以便更容易监控使用情况它还支持条件并公开了一种检测方法这是一个类似的闩锁类不同之处在于它只需要一个信号就可以触发因为锁存是非排他性的所以它使用共享的获取和释放方法创建一个初始同步状态为的新实例等待队列节点类等待队列是和锁定队列的一种变体锁通常用于自旋锁相反我们将它们用于阻塞同步器但使用相同的基本策略即在其节点的前身中保存有关线程的一些控制信息每个节点中的状态字段跟踪线程是否应该阻塞当一个节点的前身释放时它会收到信号队列的每个节点充当特定通知样式的监视器持有单个等待线程状态字段并不控制线程是否被授予锁等如果线程位于队列的第一个则可以尝试获取但做第一并不能保证成功它只赋予人们争辩的权利因此当前释放的竞争者线程可能需要重新等待要排队进入锁需要自动地将其拼接为新尾要脱队只需设置字段插入到队列只需要对尾部进行单个原子操作因此存在从未排队到排队的简单原子分界点类似地脱离队列只涉及更新头部然而节点需要做更多的工作来确定谁是它们的后继者部分原因是为了处理由于超时和中断而可能取消的情况链接在原来的锁中没有使用主要用于处理取消如果一个节点被取消它的后继节点通常被重新链接到一个未取消的前继节点有关自旋锁的类似力学解释请参阅和在上发表的论文我们还使用链接来执行阻塞机制每个节点的线程都保存在自己的节点中因此前导节点通过遍历下一个链接来确定它是哪个线程从而通知要唤醒的下一个节点后继者的确定必须避免与新排队的节点竞争以设置其前继者的字段当节点的后继节点为空时可以通过从自动更新的尾部向后检查来解决这个问题或者换句话说下一个链接是一种优化因此我们通常不需要向后扫描消去为基本算法引入了一定的保守性由于我们必须轮询其他节点的取消因此我们可能无法注意到被取消的节点是在我们前面还是后面解决这个问题的办法是在继任者被取消时总是取消他们的停车位让他们在一个新的前任上稳定下来除非我们能找到一个未被取消的前任来承担这项责任队列需要一个虚拟头节点才能启动但我们不会在构建时创建它们因为如果没有争用那将是浪费精力相反将构造节点并在第一次争用时设置头和尾指针等待条件的线程使用相同的节点但使用额外的链接条件只需要在简单非并发链接队列中链接节点因为它们只有在独占状态下才会被访问等待时将节点插入条件队列收到信号后节点被转移到主队列状态字段的特殊值用于标记节点所在的队列标记指示节点在共享模式下等待标记指示节点在独占模式下等待值表示线程已被取消值指示后继线程需要取消停放值表示线程正在等待某个条件值指示下一个获得的应该无条件传播状态字段只接受值该节点的后继节点被或将很快阻塞通过因此当前节点必须在其释放或取消后继节点时解除其为了避免竞争获取方法必须首先表明它们需要一个信号然后重试原子获取然后在失败时阻塞由于超时或中断该节点被取消节点永远不会离开此状态特别是具有取消节点的线程再也不会阻塞该节点当前位于条件队列中在传输之前它不会被用作同步队列节点此时状态将设置为这里使用这个值与该字段的其他用法无关但可以简化机制共享应该传播到其他节点这是在中设置的仅针对头节点以确保传播继续进行即使其他操作已经介入以上皆非这些值以数字形式排列以简化使用非负值意味着节点不需要发出信号因此大多数代码不需要检查特定的值只需要检查符号对于普通同步节点该字段初始化为对于条件节点该字段初始化为可以使用或者在可能的情况下使用无条件的写修改它链接到当前节点线程检查所依赖的前身节点在排队期间分配仅在离开队列时为空为了此外在取消前一个节点时我们会在找到一个未取消的节点时短路因为头部节点从未被取消因此始终存在节点仅作为获取成功的结果才成为头部节点被取消的线程永远不会成功获取并且线程只会取消自己而不会取消任何其他节点链接到当前节点线程在释放时解除锁定的后继节点在排队期间分配在绕过取消的前辈时进行调整在退出队列时为空为了操作直到附加之后才会分配前一个节点的字段因此看到一个空的字段并不一定意味着节点位于队列的末尾但是如果字段显示为空我们可以从尾部扫描进行双重检查取消节点的下一个字段被设置为指向节点本身而不是以使更容易使该节点排队的线程构造时初始化使用后无效链接到下一个等待条件的节点或特殊值因为条件队列只有在以独占模式保持时才会被访问所以我们只需要一个简单的链接队列来保持等待条件的节点然后将它们转移到队列中重新获取由于条件只能是排他性的所以我们通过使用特殊值来表示共享模式来保存字段如果节点处于共享模式等待则返回返回前一个节点如果为空则抛出当前导不能为空时使用空检查可以被省略但存在是为了帮助用于建立初始头或共享标记由使用按条件使用等待队列的头部惰性初始化除了初始化之外它只能通过方法进行修改注意如果存在它的保证不会被取消等待队列的尾部惰性初始化仅通过方法修改以添加新的等待节点同步状态返回同步状态的当前值该操作具有易失读的内存语义设置同步状态的值该操作具有易失性写的内存语义如果当前状态值等于期望值则自动将同步状态设置为给定的更新值该操作具有易失性读写的内存语义旋转比计时停车快的纳秒数粗略的估计足以在非常短的超时时间内提高响应性将节点插入队列必要时进行初始化见上图为当前线程和给定模式创建和排队节点将队列的头部设置为从而脱离队列只能由方法调用为了和抑制不必要的信号和遍历还将未使用的字段清空唤醒节点的后继者如果存在如果状态为负即可能需要信号尝试在预期信号时清除如果此操作失败或状态被等待线程更改则没有问题要解除停放的线程保存在后继节点中后继节点通常是下一个节点但如果被取消或明显为则从尾部向后遍历以找到实际未被取消的后继者共享模式的释放动作信号后继并确保传播注对于独占模式如果需要信号释放就相当于调用的确保一个发布传播即使有其他正在进行的获取发布这以通常的方式进行如果需要信号则尝试但如果没有则将设置为以确保在发布时继续传播此外如果在执行此操作时添加了新节点则必须进行循环此外与的其他用途不同我们需要知道重置状态是否失败如果失败则需要重新检查循环以重新检查案例失败循环如果头部改变则循环设置队列头并检查后继队列是否在共享模式下等待如果是则传播或状态设置记录旧头以备下面核对尝试向下一个排队节点发出信号传播由调用者指示或者被之前的操作记录在之前或之后作为注意这使用的签名检查因为状态可能会转换到并且下一个节点正在以共享模式等待或者我们不知道因为它看起来是空的这两种检查的保守性可能会导致不必要的唤醒但只有在有多个竞速获取释放时所以大多数人现在或很快就需要信号用于各种版本的工具取消正在进行的获取尝试如果节点不存在则忽略跳过取消的前任是要取消拼接的明显节点如果没有下面的情况将失败在这种情况下我们输掉了与另一个取消或信号的比赛所以不需要进一步的操作这里可以使用无条件写入而不是在这个原子步骤之后其他节点可以跳过我们之前我们不受其他线程的干扰如果我们是尾巴那就把自己挪开如果后继者需要信号试着设置的下一个链接这样它就会得到信号否则唤醒它来传播帮助检查并更新获取失败节点的状态如果线程阻塞返回这是所有采集环路中的主要信号控制要求这个节点已经设置了一个状态请求释放给它发出信号这样它就可以安全地停放了前任被取消跳过前一项并指示重试必须为或说我们需要信号但先别调用方需要重试以确保在停车前无法获取方便的方法来中断当前线程方便方法然后检查是否中断各种各样的获取方式包括独占共享和控制模式每一种都大同小异但又有令人恼火的不同由于异常机制包括确保在抛出异常时取消和其他控制的相互作用只有一点点的分解是可能的至少不会对性能造成太大的损害为已经在队列中的线程以独占不可中断模式获取用于条件等待方法和获取方法帮助以独占可中断模式获取帮助在独占定时模式下获得帮助以共享不间断模式获取帮助以共享可中断模式获取帮助在共享定时模式下获取帮助主要导出方法尝试以独占模式获取该方法应该查询对象的状态是否允许以独占模式获取它如果允许则获取它此方法总是由执行的线程调用如果此方法报告失败则方法可能会将线程如果尚未排队放入队列直到其他线程发出释放信号为止这可以用来实现方法默认实现抛出尝试将状态设置为在独占模式下反映释放此方法总是由执行释放的线程调用默认实现抛出在共享模式下尝试获取该方法应该查询对象的状态是否允许以共享模式获取它如果允许则获取它此方法总是由执行的线程调用如果此方法报告失败则方法可能会将线程如果尚未排队放入队列直到其他线程发出释放信号为止默认实现抛出尝试将状态设置为反映共享模式下的释放此方法总是由执行释放的线程调用默认实现抛出如果对当前调用线程独占保持同步则返回此方法在每次调用非等待的方法等待方法调用释放默认实现抛出此方法仅在内部调用如果不使用条件则不需要定义方法以独占模式获取忽略中断通过调用至少一次实现成功时返回否则线程将被排队可能会反复阻塞和解除阻塞调用直到成功这个方法可以用来实现方法以独占模式获取如果中断则中止首先检查中断状态然后调用至少一次成功时返回否则线程将被排队可能会反复阻塞和解除阻塞调用直到成功或线程被中断此方法可用于实现方法尝试在独占模式下获取如果中断则中止如果给定的超时过期则失败首先检查中断状态然后调用至少一次成功时返回否则线程将被排队可能会反复阻塞和解阻塞调用直到成功或线程被中断或超时结束此方法可用于实现方法以独占模式释放通过在返回时解除一个或多个线程的阻塞实现这个方法可以用来实现方法在共享模式下获取忽略中断通过首先调用至少一次实现成功时返回否则线程将被排队可能会反复阻塞和解阻塞调用直到成功在共享模式下获取中断时中止通过首先检查中断状态实现然后至少调用一次成功返回否则线程将被排队可能会反复阻塞和解除阻塞调用直到成功或线程被中断尝试在共享模式下获取如果中断则中止如果给定的超时过期则失败通过首先检查中断状态实现然后至少调用一次成功返回否则线程将被排队可能会反复阻塞和解阻塞调用直到成功或线程被中断或超时以共享方式释放通过在返回时解除一个或多个线程的阻塞来实现队列检查方法查询是否有线程正在等待获取请注意由于中断和超时导致的取消可能随时发生因此真正的返回并不能保证任何其他线程都会获得查询是否有线程争用这个同步器也就是说如果一个获取方法曾经阻塞过在这个实现中这个操作在常量时间内返回返回队列中第一个等待时间最长的线程如果当前没有线程排队则返回在此实现中此操作通常在常量时间内返回但如果其他线程并发地修改队列则可能在争用时迭代失败时调用的的版本第一个节点通常是尝试获取它的字段确保读取的一致性如果字段被清空或者不再是那么其他线程会在我们的一些读取之间并发地执行在使用遍历之前我们尝试了两次的下一个字段可能尚未设置或者可能在之后未设置所以我们必须检查是否真的是第一个节点如果没有我们继续从尾部安全地穿越到头部以找到第一个保证终止如果给定线程当前正在排队则返回这个实现遍历队列以确定给定线程是否存在如果第一个排队的线程如果存在以排他模式等待则返回如果此方法返回并且当前线程正在尝试以共享模式获取即从调用此方法则可以保证当前线程不是第一个排队的线程仅在中用作启发式查询是否有线程等待获取的时间比当前线程长此方法的调用相当于但可能比请注意由于中断和超时导致的取消可能随时发生因此真正的返回并不能保证其他线程会在当前线程之前获得同样在此方法返回后由于队列为空另一个线程也可能赢得进入队列的竞争这种方法被设计为由公平同步器使用以避免碰撞这样的同步器的方法应该返回如果这个方法返回那么它的方法应该返回一个负值除非这是一个可重入的获取例如公平可重入独占模式同步器的方法可能如下所示可重入获取增量保持计数试着正常获取它的正确性取决于在之前初始化也取决于如果当前线程是队列中的第一个则是准确的以相反的初始化顺序读取字段仪器仪表和监测方法返回等待获取的线程数的估计值该值只是一个估计值因为当此方法遍历内部数据结构时线程的数量可能会动态变化这种方法设计用于监测系统状态而不是用于同步控制返回一个包含可能正在等待获取的线程的集合由于在构造此结果时实际的线程集可能会动态变化因此返回的集合只是尽力而为的估计值返回集合的元素没有特定的顺序该方法旨在促进子类的构建从而提供更广泛的监视功能返回一个集合其中包含可能正在等待以独占模式获取的线程这与具有相同的属性除了它只返回那些由于独占获取而等待的线程返回一个集合其中包含可能正在等待以共享模式获取的线程这与具有相同的属性除了它只返回那些由于共享获取而等待的线程返回标识此同步器及其状态的字符串括号中的状态包括字符串后面跟着的当前值以及取决于队列是否为空的非空或空条件的内部支持方法如果节点总是初始放置在条件队列中的节点现在正在等待同步队列上重新获取则返回如果有继任者它必须在队列中可以是非空的但还不能在队列上因为将它放在队列上的可能会失败所以我们必须从尾巴开始遍历以确保它确实做到了在调用此方法时它将始终位于尾部附近除非失败这是不太可能的否则它将在那里因此我们几乎不会遍历太多如果从尾部向后搜索节点在同步队列上则返回只在需要时调用将节点从条件队列传输到同步队列如果成功返回如果不能更改则节点已被取消拼接到队列上并尝试设置前一个线程的以表明线程可能正在等待如果取消或尝试设置失败则唤醒以重新同步在这种情况下可能是暂时且无害的错误如果需要在取消等待后将节点传输到同步队列如果线程在收到信号之前被取消则返回如果我们丢失了那么我们不能继续直到它完成它的在不完全转移期间取消既罕见又短暂所以只需旋转使用当前状态值调用释放返回保存状态取消节点并在失败时抛出异常条件测量方法查询给定的是否使用此同步器作为其锁查询是否有线程正在等待与此同步器关联的给定条件请注意由于超时和中断可能随时发生因此真正的返回并不能保证将来的信号将唤醒任何线程这种方法主要是为监视系统状态而设计的返回与此同步器关联的等待给定条件的线程数的估计值请注意由于超时和中断可能随时发生因此估计仅作为实际等待者数量的上界这种方法设计用于监视系统状态而不是用于同步控制返回一个集合其中包含可能正在等待与此同步器关联的给定条件的线程由于在构造此结果时实际的线程集可能会动态变化因此返回的集合只是尽力而为的估计值返回集合的元素没有特定的顺序作为实现基础的的条件实现该类的方法文档从锁定和条件用户的角度描述了机制而不是行为规范这个类的导出版本通常需要附带描述依赖于相关的条件语义的文档这个类是可序列化的但所有字段都是临时的因此反序列化的条件没有等待者条件队列的第一个节点条件队列的最后一个节点创建一个新的实例内部方法在等待队列中添加一个新的等待者如果最后一个等待者被取消请清理出去移除并转移节点直到命中未取消的节点或为空从信号中分离出来部分是为了鼓励编译器内联没有等待者的情况移除并传输所有节点从条件队列中解除已取消的服务员节点的链接只在持有锁时调用当条件等待期间发生取消时以及当被取消时插入新侍者时调用该函数在没有信号的情况下需要使用此方法来避免垃圾保留因此尽管它可能需要一次完整的遍历但只有在没有信号的情况下发生超时或取消时它才会发挥作用它遍历所有节点而不是在一个特定的目标上停止以解除指向垃圾节点的所有指针的链接而不需要在取消风暴期间进行多次重新遍历公共方法将等待时间最长的线程如果存在从此条件的等待队列移动到拥有锁的等待队列将此条件的所有线程从等待队列移动到拥有锁的等待队列实现不间断条件等待保存返回的锁状态以保存的状态作为参数调用如果失败则抛出等待信号通过以保存状态作为参数调用的特殊版本来重新获取对于可中断的等待我们需要跟踪是否抛出如果在阻塞条件下中断而不是重新中断当前线程如果在阻塞等待重新获取时中断模式意思是从等待退出时重新中断模式意味着在退出等待时抛出检查中断如果在发出信号之前中断返回如果在发出信号之后返回如果没有中断返回抛出重新中断当前线程或者什么都不做具体取决于模式实现可中断条件等待如果当前线程被中断抛出保存返回的锁状态以保存的状态作为参数调用如果失败则抛出阻塞直到发出信号或中断通过以保存状态作为参数调用的特殊版本来重新获取如果在第步阻塞时中断则抛出取消后清理实现定时条件等待如果当前线程被中断抛出保存返回的锁状态以保存的状态作为参数调用如果失败则抛出阻塞直到发出信号中断或超时为止通过以保存状态作为参数调用的特殊版本来重新获取如果在第步阻塞时中断则抛出实现绝对定时条件等待如果当前线程被中断抛出保存返回的锁状态以保存的状态作为参数调用如果失败则抛出阻塞直到发出信号中断或超时为止通过以保存状态作为参数调用的特殊版本来重新获取如果在第步阻塞时中断则抛出如果在第步阻塞时超时则返回否则返回实现定时条件等待如果当前线程被中断抛出保存返回的锁状态以保存的状态作为参数调用如果失败则抛出阻塞直到发出信号中断或超时为止通过以保存状态作为参数调用的特殊版本来重新获取如果在第步阻塞时中断则抛出如果在第步阻塞时超时则返回否则返回对仪表的支持如果此条件是由给定的同步对象创建的则返回查询是否有线程正在等待此条件实现返回等待此条件的线程数的估计值实现返回一个集合其中包含可能正在等待此条件的线程实现安装以支持我们需要在这里本地实现它为了允许将来的增强我们不能显式地继承否则这将是有效和有用的因此作为最小的缺点我们使用热点固有来本地实现同时我们对其他字段也做同样的事情否则可以使用原子字段更新器完成字段仅供使用字段仅供使用节点的字段节点下一个字段',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-04 20:17:51',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小奥</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 1.05rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 1.05rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 1.05rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 1.05rem;">Feed流<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 1.05rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 1.05rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 1.05rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 1.05rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 1.05rem;">ReentrantLock<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 1.05rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 1.05rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 1.05rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 1.05rem;">synchronized<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 1.05rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 1.05rem;">文件上传<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">算法模板<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/AQS/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>AQS</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java并发之AQS源码篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-01-29T12:26:17.000Z" title="发表于 2024-01-29 20:26:17">2024-01-29</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-02-04T12:17:51.282Z" title="更新于 2024-02-04 20:17:51">2024-02-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/png/3.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a><a href="/tags/AQS/" tabindex="-1" itemprop="url">AQS</a><h1 id="CrawlerTitle" itemprop="name headline">Java并发之AQS源码篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小奥</span><time itemprop="dateCreated datePublished" datetime="2024-01-29T12:26:17.000Z" title="发表于 2024-01-29 20:26:17">2024-01-29</time><time itemprop="dateCreated datePublished" datetime="2024-02-04T12:17:51.282Z" title="更新于 2024-02-04 20:17:51">2024-02-04</time></header><h1 id="Java并发之AQS源码篇"><a href="#Java并发之AQS源码篇" class="headerlink" title="Java并发之AQS源码篇"></a>Java并发之AQS源码篇</h1><h1 id="二、完整源码"><a href="#二、完整源码" class="headerlink" title="二、完整源码"></a>二、完整源码</h1><p>以下源码版本为JDK8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为实现依赖先进先出(FIFO)等待队列的阻塞锁和相关同步器(信号量、事件等)提供了一个框架。</span></span><br><span class="line"><span class="comment"> * 该类被设计为大多数类型的同步器的有用基础，这些同步器依赖于单个原子int值来表示状态。</span></span><br><span class="line"><span class="comment"> * 子类必须定义改变这种状态的受保护方法，这些方法定义了该对象被获取或释放时该状态的含义。</span></span><br><span class="line"><span class="comment"> * 考虑到这些，这个类中的其他方法执行所有排队和阻塞机制。</span></span><br><span class="line"><span class="comment"> * 子类可以维护其他状态字段，但是只有使用getState、setState和compareAndSetState方法操纵的自动更新的int值才会跟踪同步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类应该定义为非公共的内部助手类，用于实现其外围类的同步属性。</span></span><br><span class="line"><span class="comment"> * 类AbstractQueuedSynchronizer不实现任何同步接口。</span></span><br><span class="line"><span class="comment"> * 相反，它定义了诸如acquireInterruptibly之类的方法，具体锁和相关同步器可以在适当的时候调用这些方法来实现它们的公共方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类支持默认独占模式和共享模式。当以独占模式获取时，其他线程的尝试获取无法成功。</span></span><br><span class="line"><span class="comment"> * 多线程获取共享模式可能(但不需要)成功。这个类不“理解”这些差异，除非从机械意义上说，</span></span><br><span class="line"><span class="comment"> * 当共享模式获取成功时，下一个等待线程(如果存在)也必须确定它是否也可以获取。在不同模式下等待的线程共享同一个FIFO队列。</span></span><br><span class="line"><span class="comment"> * 通常，实现子类只支持这些模式中的一种，但这两种模式都可以发挥作用，例如在ReadWriteLock中。</span></span><br><span class="line"><span class="comment"> * 仅支持独占模式或仅支持共享模式的子类不需要定义支持未使用模式的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个类定义了一个嵌套的AbstractQueuedSynchronizer.ConditionObject类，</span></span><br><span class="line"><span class="comment"> * 它可以被支持独占模式的子类用作Condition实现，在这种模式下，isheldexexclusive方法报告是否对当前线程独占保持同步，</span></span><br><span class="line"><span class="comment"> * 使用当前getState值调用的方法release完全释放该对象，并且在给定此保存的状态值的情况下，</span></span><br><span class="line"><span class="comment"> * 获取最终将该对象恢复到其先前获取的状态。AbstractQueuedSynchronizer方法不会创建这样的条件，</span></span><br><span class="line"><span class="comment"> * 所以如果不能满足此约束，就不要使用它。AbstractQueuedSynchronizer的行为。</span></span><br><span class="line"><span class="comment"> * 当然，ConditionObject取决于其同步器实现的语义。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类为内部队列提供了检查、检测和监视方法，也为条件对象提供了类似的方法。</span></span><br><span class="line"><span class="comment"> * 可以根据需要使用AbstractQueuedSynchronizer为其同步机制将这些导出到类中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类的序列化仅存储维护状态的底层原子整数，因此反序列化的对象具有空线程队列。</span></span><br><span class="line"><span class="comment"> * 需要可序列化性的典型子类将定义一个readObject方法，在反序列化时将其恢复到已知的初始状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要使用这个类作为同步器的基础，通过使用getState、setState和/或compareAndSetState检查和/或修改同步状态，</span></span><br><span class="line"><span class="comment"> * 重新定义以下方法:</span></span><br><span class="line"><span class="comment"> * - tryAcquire</span></span><br><span class="line"><span class="comment"> * - tryRelease</span></span><br><span class="line"><span class="comment"> * - tryAcquireShared</span></span><br><span class="line"><span class="comment"> * - tryReleaseShared</span></span><br><span class="line"><span class="comment"> * - isHeldExclusively</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认情况下，这些方法都会抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment"> * 这些方法的实现必须是内部线程安全的，通常应该是简短的，而不是阻塞的。</span></span><br><span class="line"><span class="comment"> * 定义这些方法是唯一支持的使用该类的方法。所有其他方法都被声明为final，因为它们不能独立变化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 您可能还会发现从AbstractOwnableSynchronizer继承的方法对于跟踪拥有独占同步器的线程非常有用。</span></span><br><span class="line"><span class="comment"> * 我们鼓励您使用它们——这使得监视和诊断工具能够帮助用户确定哪些线程持有锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尽管这个类是基于内部FIFO队列的，但它不会自动执行FIFO获取策略。排他同步的核心是:</span></span><br><span class="line"><span class="comment"> * Acquire:</span></span><br><span class="line"><span class="comment"> *     while (!tryAcquire(arg)) &#123;</span></span><br><span class="line"><span class="comment"> *        // 如果线程尚未排队，则进入队列;</span></span><br><span class="line"><span class="comment"> * 		  // 可能阻塞当前线程;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release:</span></span><br><span class="line"><span class="comment"> *     if (tryRelease(arg))</span></span><br><span class="line"><span class="comment"> *        // 解除第一个排队线程的阻塞</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (共享模式类似，但可能涉及级联信号。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为获取中的检查是在排队之前调用的，所以新获取的线程可能会抢在其他被阻塞和排队的线程前面。</span></span><br><span class="line"><span class="comment"> * 但是，如果需要，您可以定义tryAcquire和/或tryacquirered，通过内部调用一个或多个检查方法来禁用闯入，</span></span><br><span class="line"><span class="comment"> * 从而提供公平的FIFO获取顺序。特别是，大多数公平同步器可以将tryAcquire定义为在hasqueued前</span></span><br><span class="line"><span class="comment"> * (一个专门为公平同步器使用的方法)返回true时返回false。其他变化也是可能的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 吞吐量和可伸缩性对于默认的驳船(也称为贪心、放弃和护航回避)策略通常是最高的。</span></span><br><span class="line"><span class="comment"> * 虽然这不能保证公平或无饥饿，但允许较早排队的线程在较晚排队的线程之前重新争用，并且每次重新争用对传入线程都有一个无偏的成功机会。</span></span><br><span class="line"><span class="comment"> * 此外，虽然acquire不会像通常意义上那样“旋转”，但它们可能会在阻塞之前执行与其他计算穿插的tryAcquire的多次调用。</span></span><br><span class="line"><span class="comment"> * 当独占同步只是短暂地保持时，这提供了自旋的大部分好处，而在不保持独占同步时则没有大部分缺点。</span></span><br><span class="line"><span class="comment"> * 如果需要，您可以通过在调用之前使用“快速路径”检查来获取方法来增加这一点，可能会预先检查hasContended和/或hasQueuedThreads，以便仅在同步器可能不会被争用时才这样做。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个类为同步提供了一个高效和可扩展的基础，部分是通过将其使用范围专化到可以依赖于int状态、获取和释放参数的同步器，</span></span><br><span class="line"><span class="comment"> * 以及一个内部FIFO等待队列。如果这还不够，您可以使用原子类、您自己的自定义java.util.Queue类和LockSupport阻塞</span></span><br><span class="line"><span class="comment"> * 支持从较低级别构建同步器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下面是一个不可重入互斥锁类，它使用值0表示未锁定状态，1表示锁定状态。</span></span><br><span class="line"><span class="comment"> * 虽然不可重入锁并不严格要求记录当前所有者线程，但这个类还是这样做了，以便更容易监控使用情况。</span></span><br><span class="line"><span class="comment"> * 它还支持条件，并公开了一种检测方法:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * class Mutex implements Lock, java.io.Serializable &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // Our internal helper class</span></span><br><span class="line"><span class="comment"> *   private static class Sync extends AbstractQueuedSynchronizer &#123;</span></span><br><span class="line"><span class="comment"> *     // Reports whether in locked state</span></span><br><span class="line"><span class="comment"> *     protected boolean isHeldExclusively() &#123;</span></span><br><span class="line"><span class="comment"> *       return getState() == 1;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Acquires the lock if state is zero</span></span><br><span class="line"><span class="comment"> *     public boolean tryAcquire(int acquires) &#123;</span></span><br><span class="line"><span class="comment"> *       assert acquires == 1; // Otherwise unused</span></span><br><span class="line"><span class="comment"> *       if (compareAndSetState(0, 1)) &#123;</span></span><br><span class="line"><span class="comment"> *         setExclusiveOwnerThread(Thread.currentThread());</span></span><br><span class="line"><span class="comment"> *         return true;</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *       return false;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Releases the lock by setting state to zero</span></span><br><span class="line"><span class="comment"> *     protected boolean tryRelease(int releases) &#123;</span></span><br><span class="line"><span class="comment"> *       assert releases == 1; // Otherwise unused</span></span><br><span class="line"><span class="comment"> *       if (getState() == 0) throw new IllegalMonitorStateException();</span></span><br><span class="line"><span class="comment"> *       setExclusiveOwnerThread(null);</span></span><br><span class="line"><span class="comment"> *       setState(0);</span></span><br><span class="line"><span class="comment"> *       return true;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Provides a Condition</span></span><br><span class="line"><span class="comment"> *     Condition newCondition() &#123; return new ConditionObject(); &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Deserializes properly</span></span><br><span class="line"><span class="comment"> *     private void readObject(ObjectInputStream s)</span></span><br><span class="line"><span class="comment"> *         throws IOException, ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment"> *       s.defaultReadObject();</span></span><br><span class="line"><span class="comment"> *       setState(0); // reset to unlocked state</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // The sync object does all the hard work. We just forward to it.</span></span><br><span class="line"><span class="comment"> *   private final Sync sync = new Sync();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   public void lock()                &#123; sync.acquire(1); &#125;</span></span><br><span class="line"><span class="comment"> *   public boolean tryLock()          &#123; return sync.tryAcquire(1); &#125;</span></span><br><span class="line"><span class="comment"> *   public void unlock()              &#123; sync.release(1); &#125;</span></span><br><span class="line"><span class="comment"> *   public Condition newCondition()   &#123; return sync.newCondition(); &#125;</span></span><br><span class="line"><span class="comment"> *   public boolean isLocked()         &#123; return sync.isHeldExclusively(); &#125;</span></span><br><span class="line"><span class="comment"> *   public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125;</span></span><br><span class="line"><span class="comment"> *   public void lockInterruptibly() throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment"> *     sync.acquireInterruptibly(1);</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   public boolean tryLock(long timeout, TimeUnit unit)</span></span><br><span class="line"><span class="comment"> *       throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment"> *     return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个类似CountDownLatch的闩锁类，不同之处在于它只需要一个信号就可以触发。</span></span><br><span class="line"><span class="comment"> * 因为锁存是非排他性的，所以它使用共享的获取和释放方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * class BooleanLatch &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   private static class Sync extends AbstractQueuedSynchronizer &#123;</span></span><br><span class="line"><span class="comment"> *     boolean isSignalled() &#123; return getState() != 0; &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     protected int tryAcquireShared(int ignore) &#123;</span></span><br><span class="line"><span class="comment"> *       return isSignalled() ? 1 : -1;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     protected boolean tryReleaseShared(int ignore) &#123;</span></span><br><span class="line"><span class="comment"> *       setState(1);</span></span><br><span class="line"><span class="comment"> *       return true;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   private final Sync sync = new Sync();</span></span><br><span class="line"><span class="comment"> *   public boolean isSignalled() &#123; return sync.isSignalled(); &#125;</span></span><br><span class="line"><span class="comment"> *   public void signal()         &#123; sync.releaseShared(1); &#125;</span></span><br><span class="line"><span class="comment"> *   public void await() throws InterruptedException &#123;</span></span><br><span class="line"><span class="comment"> *     sync.acquireSharedInterruptibly(1);</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个初始同步状态为0的新AbstractQueuedSynchronizer实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列节点类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等待队列是“CLH”(Craig、Landin和Hagersten)锁定队列的一种变体。CLH锁通常用于自旋锁。</span></span><br><span class="line"><span class="comment">     * 相反，我们将它们用于阻塞同步器，但使用相同的基本策略，即在其节点的前身中保存有关线程的一些控制信息。</span></span><br><span class="line"><span class="comment">     * 每个节点中的“状态”字段跟踪线程是否应该阻塞。当一个节点的前身释放时，它会收到信号。</span></span><br><span class="line"><span class="comment">     * 队列的每个节点充当特定通知样式的监视器，持有单个等待线程。状态字段并不控制线程是否被授予锁等。</span></span><br><span class="line"><span class="comment">     * 如果线程位于队列的第一个，则可以尝试获取。但做第一并不能保证成功；它只赋予人们争辩的权利。</span></span><br><span class="line"><span class="comment">     * 因此，当前释放的竞争者线程可能需要重新等待。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要排队进入CLH锁，需要自动地将其拼接为新尾。要脱队，只需设置head字段。</span></span><br><span class="line"><span class="comment">     *      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 插入到CLH队列只需要对“尾部”进行单个原子操作，因此存在从未排队到排队的简单原子分界点。</span></span><br><span class="line"><span class="comment">     * 类似地，脱离队列只涉及更新“头部”。然而，节点需要做更多的工作来确定谁是它们的后继者，</span></span><br><span class="line"><span class="comment">     * 部分原因是为了处理由于超时和中断而可能取消的情况。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * “prev”链接(在原来的CLH锁中没有使用)主要用于处理取消。</span></span><br><span class="line"><span class="comment">     * 如果一个节点被取消，它的后继节点(通常)被重新链接到一个未取消的前继节点。</span></span><br><span class="line"><span class="comment">     * 有关自旋锁的类似力学解释，请参阅Scott和Scherer在http://www.cs.rochester.edu/u/scott/synchronization/上发表的论文</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们还使用“next”链接来执行阻塞机制。</span></span><br><span class="line"><span class="comment">     * 每个节点的线程id都保存在自己的节点中，因此前导节点通过遍历下一个链接来确定它是哪个线程，从而通知要唤醒的下一个节点。</span></span><br><span class="line"><span class="comment">     * 后继者的确定必须避免与新排队的节点竞争，以设置其前继者的“next”字段。</span></span><br><span class="line"><span class="comment">     * 当节点的后继节点为空时，可以通过从自动更新的“尾部”向后检查来解决这个问题。</span></span><br><span class="line"><span class="comment">     * (或者换句话说，下一个链接是一种优化，因此我们通常不需要向后扫描。)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 消去为基本算法引入了一定的保守性。</span></span><br><span class="line"><span class="comment">     * 由于我们必须轮询其他节点的取消，因此我们可能无法注意到被取消的节点是在我们前面还是后面。</span></span><br><span class="line"><span class="comment">     * 解决这个问题的办法是，在继任者被取消时，总是取消他们的停车位，让他们在一个新的前任上稳定下来，</span></span><br><span class="line"><span class="comment">     * 除非我们能找到一个未被取消的前任来承担这项责任。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CLH队列需要一个虚拟头节点才能启动。但我们不会在构建时创建它们，因为如果没有争用，那将是浪费精力。</span></span><br><span class="line"><span class="comment">     * 相反，将构造节点，并在第一次争用时设置头和尾指针。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 等待条件的线程使用相同的节点，但使用额外的链接。</span></span><br><span class="line"><span class="comment">     * 条件只需要在简单(非并发)链接队列中链接节点，因为它们只有在独占状态下才会被访问。</span></span><br><span class="line"><span class="comment">     * 等待时，将节点插入条件队列。收到信号后，节点被转移到主队列。状态字段的特殊值用于标记节点所在的队列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** 标记，指示节点在共享模式下等待 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** 标记，指示节点在独占模式下等待 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus值表示线程已被取消 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus值，指示后继线程需要取消停放 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus值表示线程正在等待某个条件 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus值，指示下一个获得的应该无条件传播</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 状态字段，只接受值:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     该节点的后继节点被(或将很快)阻塞(通过park)，因此当前节点必须在其释放或取消后继节点时解除其park。</span></span><br><span class="line"><span class="comment">         * 				 为了避免竞争，获取方法必须首先表明它们需要一个信号，然后重试原子获取，然后在失败时阻塞。</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  由于超时或中断，该节点被取消。节点永远不会离开此状态。特别是，具有取消节点的线程再也不会阻塞。</span></span><br><span class="line"><span class="comment">         *   CONDITION:  该节点当前位于条件队列中。在传输之前，它不会被用作同步队列节点，此时状态将设置为0。</span></span><br><span class="line"><span class="comment">         * 				 (这里使用这个值与该字段的其他用法无关，但可以简化机制。)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  release共享应该传播到其他节点。</span></span><br><span class="line"><span class="comment">         *				 这是在doreleaseshare中设置的(仅针对头节点)，以确保传播继续进行，即使其他操作已经介入。</span></span><br><span class="line"><span class="comment">         *   0:          以上皆非</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这些值以数字形式排列以简化使用。非负值意味着节点不需要发出信号。</span></span><br><span class="line"><span class="comment">         * 因此，大多数代码不需要检查特定的值，只需要检查符号。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 对于普通同步节点，该字段初始化为0，对于条件节点，该字段初始化为CONDITION。</span></span><br><span class="line"><span class="comment">         * 可以使用CAS(或者在可能的情况下，使用无条件的volatile写)修改它。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 链接到当前节点/线程检查waitStatus所依赖的前身节点。</span></span><br><span class="line"><span class="comment">         * 在排队期间分配，仅在离开队列时为空(为了GC)。</span></span><br><span class="line"><span class="comment">         * 此外，在取消前一个节点时，我们会在找到一个未取消的节点时短路，因为头部节点从未被取消，因此始终存在：</span></span><br><span class="line"><span class="comment">         * 节点仅作为获取成功的结果才成为头部节点。被取消的线程永远不会成功获取，并且线程只会取消自己，而不会取消任何其他节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 链接到当前节点/线程在释放时解除锁定的后继节点。</span></span><br><span class="line"><span class="comment">         * 在排队期间分配，在绕过取消的前辈时进行调整，在退出队列时为空(为了GC)。</span></span><br><span class="line"><span class="comment">         * enq操作直到附加之后才会分配前一个节点的next字段，因此看到一个空的next字段并不一定意味着节点位于队列的末尾。</span></span><br><span class="line"><span class="comment">         * 但是，如果next字段显示为空，我们可以从尾部扫描prev进行双重检查。</span></span><br><span class="line"><span class="comment">         * 取消节点的下一个字段被设置为指向节点本身，而不是null，以使isOnSyncQueue更容易。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使该节点排队的线程。构造时初始化，使用后无效。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 链接到下一个等待条件的节点，或特殊值SHARED。</span></span><br><span class="line"><span class="comment">         * 因为条件队列只有在以独占模式保持时才会被访问，所以我们只需要一个简单的链接队列来保持等待条件的节点。</span></span><br><span class="line"><span class="comment">         * 然后将它们转移到队列中重新获取。由于条件只能是排他性的，所以我们通过使用特殊值来表示共享模式来保存字段。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果节点处于共享模式等待，则返回true。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回前一个节点，如果为空则抛出NullPointerException。</span></span><br><span class="line"><span class="comment">         * 当前导不能为空时使用。空检查可以被省略，但存在是为了帮助VM。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// 用于建立初始头或共享标记</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// 由addWaiter使用</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// 按条件使用</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的头部，惰性初始化。除了初始化之外，它只能通过sehead方法进行修改。</span></span><br><span class="line"><span class="comment">     * 注意：如果head存在，它的waitStatus保证不会被取消。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列的尾部，惰性初始化。仅通过方法enq修改以添加新的等待节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回同步状态的当前值。该操作具有易失读的内存语义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置同步状态的值。该操作具有易失性写的内存语义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前状态值等于期望值，则自动将同步状态设置为给定的更新值。该操作具有易失性读写的内存语义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queuing utilities</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转比计时停车快的纳秒数。粗略的估计足以在非常短的超时时间内提高响应性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入队列，必要时进行初始化。见上图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为当前线程和给定模式创建和排队节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将队列的头部设置为node，从而脱离队列。只能由acquire方法调用。</span></span><br><span class="line"><span class="comment">     * 为了GC和抑制不必要的信号和遍历，还将未使用的字段清空。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line">        node.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒节点的后继者(如果存在)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果状态为负(即，可能需要信号)，尝试在预期信号时清除。如果此操作失败或状态被等待线程更改，则没有问题。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 要解除停放的线程保存在后继节点中，后继节点通常是下一个节点。</span></span><br><span class="line"><span class="comment">         * 但如果被取消或明显为null，则从尾部向后遍历以找到实际未被取消的后继者。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享模式的释放动作——信号后继并确保传播。(注：对于独占模式，如果需要信号，释放就相当于调用head的unparkSuccessor。)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 确保一个发布传播，即使有其他正在进行的获取/发布。</span></span><br><span class="line"><span class="comment">         * 这以通常的方式进行，如果需要信号，则尝试unparkSuccessor of head。</span></span><br><span class="line"><span class="comment">         * 但如果没有，则将status设置为PROPAGATE，以确保在发布时继续传播。</span></span><br><span class="line"><span class="comment">         * 此外，如果在执行此操作时添加了新节点，则必须进行循环。</span></span><br><span class="line"><span class="comment">         * 此外，与unparkSuccessor的其他用途不同，我们需要知道CAS重置状态是否失败，如果失败，则需要重新检查。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// 循环以重新检查案例</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// CAS失败循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// 如果头部改变，则循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置队列头，并检查后继队列是否在共享模式下等待，如果是，则传播propagate &gt; 0或propagate状态设置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 记录旧头以备下面核对</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 尝试向下一个排队节点发出信号：</span></span><br><span class="line"><span class="comment">         *   传播由调用者指示,</span></span><br><span class="line"><span class="comment">         *     或者被之前的操作记录(在sehead之前或之后作为h.waitStatus)</span></span><br><span class="line"><span class="comment">         * 	   (注意:这使用waitStatus的签名检查，因为PROPAGATE状态可能会转换到SIGNAL)。</span></span><br><span class="line"><span class="comment">         * 并且</span></span><br><span class="line"><span class="comment">         *   下一个节点正在以共享模式等待,</span></span><br><span class="line"><span class="comment">         *     或者我们不知道，因为它看起来是空的。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这两种检查的保守性可能会导致不必要的唤醒，但只有在有多个竞速获取/释放时，所以大多数人现在或很快就需要信号。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于各种版本的工具</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消正在进行的获取尝试。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点不存在，则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过取消的前任</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext是要取消拼接的明显节点。如果没有，下面的情况将失败，</span></span><br><span class="line">        <span class="comment">// 在这种情况下，我们输掉了与另一个取消或信号的比赛，所以不需要进一步的操作。</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以使用无条件写入而不是CAS。在这个原子步骤之后，其他节点可以跳过我们。</span></span><br><span class="line">        <span class="comment">// 之前，我们不受其他线程的干扰。</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们是尾巴，那就把自己挪开。</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果后继者需要信号，试着设置pred的下一个链接，这样它就会得到信号。否则唤醒它来传播。</span></span><br><span class="line">            <span class="type">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// 帮助GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查并更新获取失败节点的状态。如果线程阻塞，返回true。</span></span><br><span class="line"><span class="comment">     * 这是所有采集环路中的主要信号控制。要求pred == node.prev。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这个节点已经设置了一个状态，请求释放给它发出信号，这样它就可以安全地停放了。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 前任被取消。跳过前一项并指示重试。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus必须为0或PROPAGATE。说我们需要信号，但先别park。</span></span><br><span class="line"><span class="comment">             * 调用方需要重试以确保在停车前无法获取。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方便的方法来中断当前线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方便方法park，然后检查是否中断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 各种各样的获取方式，包括独占/共享和控制模式。每一种都大同小异，但又有令人恼火的不同。</span></span><br><span class="line"><span class="comment">     * 由于异常机制(包括确保在tryAcquire抛出异常时取消)和其他控制的相互作用，</span></span><br><span class="line"><span class="comment">     * 只有一点点的分解是可能的，至少不会对性能造成太大的损害。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为已经在队列中的线程以独占不可中断模式获取。用于条件等待方法和获取方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以独占可中断模式获取。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在独占定时模式下获得。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以共享不间断模式获取。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以共享可中断模式获取。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在共享定时模式下获取。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// 帮助GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要导出方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试以独占模式获取。该方法应该查询对象的状态是否允许以独占模式获取它，如果允许则获取它。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 此方法总是由执行acquire的线程调用。如果此方法报告失败，则acquire方法可能会将线程(如果尚未排队)放入队列，</span></span><br><span class="line"><span class="comment">     * 直到其他线程发出释放信号为止。这可以用来实现方法Lock.tryLock()。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 默认实现抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试将状态设置为在独占模式下反映释放。</span></span><br><span class="line"><span class="comment">     * 此方法总是由执行释放的线程调用。</span></span><br><span class="line"><span class="comment">     * 默认实现抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在共享模式下尝试获取。该方法应该查询对象的状态是否允许以共享模式获取它，如果允许则获取它。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法总是由执行acquire的线程调用。如果此方法报告失败，则acquire方法可能会将线程(如果尚未排队)放入队列，、</span></span><br><span class="line"><span class="comment">     * 直到其他线程发出释放信号为止。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 默认实现抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试将状态设置为反映共享模式下的释放。</span></span><br><span class="line"><span class="comment">     * 此方法总是由执行释放的线程调用。</span></span><br><span class="line"><span class="comment">     * 默认实现抛出UnsupportedOperationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果对当前(调用)线程独占保持同步，则返回true。此方法在每次调用非等待的AbstractQueuedSynchronizer.ConditionObject方法。(等待方法调用释放。)</span></span><br><span class="line"><span class="comment">     * 默认实现抛出UnsupportedOperationException。此方法仅在AbstractQueuedSynchronizer内部调用。</span></span><br><span class="line"><span class="comment">     * 如果不使用条件，则不需要定义ConditionObject方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以独占模式获取，忽略中断。通过调用至少一次tryAcquire实现，成功时返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解除阻塞，调用tryAcquire直到成功。这个方法可以用来实现方法Lock.lock。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以独占模式获取，如果中断则中止。首先检查中断状态，然后调用至少一次tryAcquire，成功时返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解除阻塞，调用tryAcquire，直到成功或线程被中断。</span></span><br><span class="line"><span class="comment">     * 此方法可用于实现方法Lock.lockInterruptibly。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试在独占模式下获取，如果中断则中止，如果给定的超时过期则失败。首先检查中断状态，然后调用至少一次tryAcquire，成功时返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解阻塞，调用tryAcquire，直到成功或线程被中断或超时结束。</span></span><br><span class="line"><span class="comment">     * 此方法可用于实现方法Lock.tryLock(long, TimeUnit)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以独占模式释放。通过在tryRelease返回true时解除一个或多个线程的阻塞实现。</span></span><br><span class="line"><span class="comment">     * 这个方法可以用来实现方法Lock.unlock。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在共享模式下获取，忽略中断。通过首先调用至少一次tryacquirered实现，成功时返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解阻塞，调用tryacquirered直到成功。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在共享模式下获取，中断时中止。通过首先检查中断状态实现，然后至少调用一次tryacquirered，成功返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解除阻塞，调用tryacquirered，直到成功或线程被中断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试在共享模式下获取，如果中断则中止，如果给定的超时过期则失败。通过首先检查中断状态实现，然后至少调用一次tryacquirered，成功返回。</span></span><br><span class="line"><span class="comment">     * 否则，线程将被排队，可能会反复阻塞和解阻塞，调用tryacquirered，直到成功或线程被中断或超时。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以共享方式释放。通过在tryreleaseshare返回true时解除一个或多个线程的阻塞来实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列检查方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询是否有线程正在等待获取。请注意，由于中断和超时导致的取消可能随时发生，因此真正的返回并不能保证任何其他线程都会获得。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head != tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询是否有线程争用这个同步器；也就是说，如果一个获取方法曾经阻塞过。</span></span><br><span class="line"><span class="comment">     * 在这个实现中，这个操作在常量时间内返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasContended</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列中第一个(等待时间最长的)线程，如果当前没有线程排队，则返回null。</span></span><br><span class="line"><span class="comment">     * 在此实现中，此操作通常在常量时间内返回，但如果其他线程并发地修改队列，则可能在争用时迭代。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title function_">getFirstQueuedThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// handle only fast path, else relay</span></span><br><span class="line">        <span class="keyword">return</span> (head == tail) ? <span class="literal">null</span> : fullGetFirstQueuedThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fastpath失败时调用的getFirstQueuedThread的版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread <span class="title function_">fullGetFirstQueuedThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 第一个节点通常是head.next。尝试获取它的thread字段，确保读取的一致性：</span></span><br><span class="line"><span class="comment">         * 如果thread字段被清空，或者s.prev不再是head，那么其他线程会在我们的一些</span></span><br><span class="line"><span class="comment">         * 读取之间并发地执行sehead。在使用遍历之前，我们尝试了两次。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node h, s;</span><br><span class="line">        Thread st;</span><br><span class="line">        <span class="keyword">if</span> (((h = head) != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             s.prev == head &amp;&amp; (st = s.thread) != <span class="literal">null</span>) ||</span><br><span class="line">            ((h = head) != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             s.prev == head &amp;&amp; (st = s.thread) != <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Head的下一个字段可能尚未设置，或者可能在sehead之后未设置。</span></span><br><span class="line"><span class="comment">         * 所以我们必须检查tail是否真的是第一个节点。如果没有，我们继续，从尾部安全地穿越到头部以找到第一个，保证终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">firstThread</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="literal">null</span> &amp;&amp; t != head) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">tt</span> <span class="operator">=</span> t.thread;</span><br><span class="line">            <span class="keyword">if</span> (tt != <span class="literal">null</span>)</span><br><span class="line">                firstThread = tt;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果给定线程当前正在排队，则返回true。</span></span><br><span class="line"><span class="comment">     * 这个实现遍历队列以确定给定线程是否存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isQueued</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.thread == thread)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果第一个排队的线程(如果存在)以排他模式等待，则返回true。</span></span><br><span class="line"><span class="comment">     * 如果此方法返回true，并且当前线程正在尝试以共享模式获取(即，从tryacquirered调用此方法)，</span></span><br><span class="line"><span class="comment">     * 则可以保证当前线程不是第一个排队的线程。仅在ReentrantReadWriteLock中用作启发式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询是否有线程等待获取的时间比当前线程长。</span></span><br><span class="line"><span class="comment">     * 此方法的调用相当于(但可能比):</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 请注意，由于中断和超时导致的取消可能随时发生，因此真正的返回并不能保证其他线程会在当前线程之前获得。</span></span><br><span class="line"><span class="comment">     * 同样，在此方法返回false后，由于队列为空，另一个线程也可能赢得进入队列的竞争。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这种方法被设计为由公平同步器使用，以避免碰撞。这样的同步器的tryAcquire方法应该返回false，如果这个方法返回true，</span></span><br><span class="line"><span class="comment">     * 那么它的tryacquirered方法应该返回一个负值(除非这是一个可重入的获取)。</span></span><br><span class="line"><span class="comment">     * 例如，公平、可重入、独占模式同步器的tryAcquire方法可能如下所示:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">     *   if (isHeldExclusively()) &#123;</span></span><br><span class="line"><span class="comment">     *     // 可重入获取；增量保持计数</span></span><br><span class="line"><span class="comment">     *     return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else if (hasQueuedPredecessors()) &#123;</span></span><br><span class="line"><span class="comment">     *     return false;</span></span><br><span class="line"><span class="comment">     *   &#125; else &#123;</span></span><br><span class="line"><span class="comment">     *     // 试着正常获取</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 它的正确性取决于head在tail之前初始化，也取决于head。如果当前线程是队列中的第一个，则Next是准确的。</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// 以相反的初始化顺序读取字段</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仪器仪表和监测方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回等待获取的线程数的估计值。该值只是一个估计值，因为当此方法遍历内部数据结构时，线程的数量可能会动态变化。</span></span><br><span class="line"><span class="comment">     * 这种方法设计用于监测系统状态，而不是用于同步控制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.thread != <span class="literal">null</span>)</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个包含可能正在等待获取的线程的集合。由于在构造此结果时，实际的线程集可能会动态变化，</span></span><br><span class="line"><span class="comment">     * 因此返回的集合只是尽力而为的估计值。返回集合的元素没有特定的顺序。</span></span><br><span class="line"><span class="comment">     * 该方法旨在促进子类的构建，从而提供更广泛的监视功能。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> p.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个集合，其中包含可能正在等待以独占模式获取的线程。</span></span><br><span class="line"><span class="comment">     * 这与getQueuedThreads具有相同的属性，除了它只返回那些由于独占获取而等待的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getExclusiveQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.isShared()) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> p.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个集合，其中包含可能正在等待以共享模式获取的线程。</span></span><br><span class="line"><span class="comment">     * 这与getQueuedThreads具有相同的属性，除了它只返回那些由于共享获取而等待的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getSharedQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> tail; p != <span class="literal">null</span>; p = p.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.isShared()) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> p.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回标识此同步器及其状态的字符串。括号中的状态包括字符串“state =”，</span></span><br><span class="line"><span class="comment">     * 后面跟着getState的当前值，以及取决于队列是否为空的“非空”或“空”。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">String</span> <span class="variable">q</span>  <span class="operator">=</span> hasQueuedThreads() ? <span class="string">&quot;non&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() +</span><br><span class="line">            <span class="string">&quot;[State = &quot;</span> + s + <span class="string">&quot;, &quot;</span> + q + <span class="string">&quot;empty queue]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件的内部支持方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果节点(总是初始放置在条件队列中的节点)现在正在等待同步队列上重新获取，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// 如果有继任者，它必须在队列中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev可以是非空的，但还不能在队列上，因为将它放在队列上的CAS可能会失败。</span></span><br><span class="line"><span class="comment">         * 所以我们必须从尾巴开始遍历，以确保它确实做到了。在调用此方法时，它将始终位于尾部附近，</span></span><br><span class="line"><span class="comment">         * 除非CAS失败(这是不太可能的)，否则它将在那里，因此我们几乎不会遍历太多。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果从尾部向后搜索节点在同步队列上，则返回true。只在isOnSyncQueue需要时调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点从条件队列传输到同步队列。如果成功返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果不能更改waitStatus，则节点已被取消。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 拼接到队列上，并尝试设置前一个线程的waitStatus，以表明线程(可能)正在等待。</span></span><br><span class="line"><span class="comment">         * 如果取消或尝试设置waitStatus失败，则唤醒以重新同步(在这种情况下，waitStatus可能是暂时且无害的错误)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要，在取消等待后将节点传输到同步队列。如果线程在收到信号之前被取消，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果我们丢失了 signal(),，那么我们不能继续，直到它完成它的enq()。在不完全转移期间取消既罕见又短暂，所以只需旋转。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用当前状态值调用释放；返回保存状态。取消节点并在失败时抛出异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件测量方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询给定的ConditionObject是否使用此同步器作为其锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">owns</span><span class="params">(ConditionObject condition)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> condition.isOwnedBy(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询是否有线程正在等待与此同步器关联的给定条件。请注意，由于超时和中断可能随时发生，</span></span><br><span class="line"><span class="comment">     * 因此真正的返回并不能保证将来的信号将唤醒任何线程。这种方法主要是为监视系统状态而设计的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasWaiters</span><span class="params">(ConditionObject condition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.hasWaiters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与此同步器关联的等待给定条件的线程数的估计值。请注意，由于超时和中断可能随时发生，</span></span><br><span class="line"><span class="comment">     * 因此估计仅作为实际等待者数量的上界。这种方法设计用于监视系统状态，而不是用于同步控制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getWaitQueueLength</span><span class="params">(ConditionObject condition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.getWaitQueueLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个集合，其中包含可能正在等待与此同步器关联的给定条件的线程。</span></span><br><span class="line"><span class="comment">     * 由于在构造此结果时，实际的线程集可能会动态变化，因此返回的集合只是尽力而为的估计值。返回集合的元素没有特定的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getWaitingThreads</span><span class="params">(ConditionObject condition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!owns(condition))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Not owner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> condition.getWaitingThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作为Lock实现基础的AbstractQueuedSynchronizer的条件实现。</span></span><br><span class="line"><span class="comment">     * 该类的方法文档从锁定和条件用户的角度描述了机制，而不是行为规范。</span></span><br><span class="line"><span class="comment">     * 这个类的导出版本通常需要附带描述依赖于相关AbstractQueuedSynchronizer的条件语义的文档。</span></span><br><span class="line"><span class="comment">     * 这个类是可序列化的，但所有字段都是临时的，因此反序列化的条件没有等待者。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** 条件队列的第一个节点。 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** 条件队列的最后一个节点。 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的ConditionObject实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在等待队列中添加一个新的等待者。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">            <span class="comment">// 如果最后一个等待者被取消，请清理出去。</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 移除并转移节点，直到命中未取消的节点或为空。从信号中分离出来部分是为了鼓励编译器内联没有等待者的情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = <span class="literal">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 移除并传输所有节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从条件队列中解除已取消的服务员节点的链接。只在持有锁时调用。</span></span><br><span class="line"><span class="comment">         * 当条件等待期间发生取消时，以及当lastWaiter被取消时插入新侍者时，调用该函数。</span></span><br><span class="line"><span class="comment">         * 在没有信号的情况下，需要使用此方法来避免垃圾保留。因此，尽管它可能需要一次完整的遍历，但只有在没有信号的情况下发生超时或取消时，它才会发挥作用。</span></span><br><span class="line"><span class="comment">         * 它遍历所有节点，而不是在一个特定的目标上停止，以解除指向垃圾节点的所有指针的链接，而不需要在取消风暴期间进行多次重新遍历。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 公共方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将等待时间最长的线程(如果存在)从此条件的等待队列移动到拥有锁的等待队列。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将此条件的所有线程从等待队列移动到拥有锁的等待队列。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现不间断条件等待。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 1. 保存getState返回的锁状态。</span></span><br><span class="line"><span class="comment">         * 2. 以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span></span><br><span class="line"><span class="comment">         * 3. 等待信号。</span></span><br><span class="line"><span class="comment">         * 4. 通过以保存状态作为参数调用acquire的特殊版本来重新获取。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于可中断的等待，我们需要跟踪是否抛出InterruptedException，</span></span><br><span class="line"><span class="comment">         * 如果在阻塞条件下中断，而不是重新中断当前线程，如果在阻塞等待重新获取时中断。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 模式，意思是从等待退出时重新中断 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** 模式意味着在退出等待时抛出InterruptedException */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查中断，如果在发出信号之前中断返回THROW_IE，如果在发出信号之后返回REINTERRUPT，如果没有中断返回0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 抛出InterruptedException，重新中断当前线程，或者什么都不做，具体取决于模式。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现可中断条件等待。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. 如果当前线程被中断，抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 2. 保存getState返回的锁状态。</span></span><br><span class="line"><span class="comment">         * 3. 以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span></span><br><span class="line"><span class="comment">         * 4. 阻塞直到发出信号或中断。</span></span><br><span class="line"><span class="comment">         * 5. 通过以保存状态作为参数调用acquire的特殊版本来重新获取。</span></span><br><span class="line"><span class="comment">         * 6. 如果在第4步阻塞时中断，则抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// 取消后清理</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现定时条件等待。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 1. 如果当前线程被中断，抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 2. 保存getState返回的锁状态。</span></span><br><span class="line"><span class="comment">         * 3. 以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span></span><br><span class="line"><span class="comment">         * 4. 阻塞直到发出信号、中断或超时为止。</span></span><br><span class="line"><span class="comment">         * 5. 通过以保存状态作为参数调用acquire的特殊版本来重新获取。</span></span><br><span class="line"><span class="comment">         * 6. 如果在第4步阻塞时中断，则抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span></span><br><span class="line">                <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现绝对定时条件等待。</span></span><br><span class="line"><span class="comment">         * 1. 如果当前线程被中断，抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 2. 保存getState返回的锁状态。</span></span><br><span class="line"><span class="comment">         * 3. 以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span></span><br><span class="line"><span class="comment">         * 4. 阻塞直到发出信号、中断或超时为止。</span></span><br><span class="line"><span class="comment">         * 5. 通过以保存状态作为参数调用acquire的特殊版本来重新获取。</span></span><br><span class="line"><span class="comment">         * 6. 如果在第4步阻塞时中断，则抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 7. 如果在第4步阻塞时超时，则返回false，否则返回true。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span></span><br><span class="line">                <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">abstime</span> <span class="operator">=</span> deadline.getTime();</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timedout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkUntil(<span class="built_in">this</span>, abstime);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实现定时条件等待。</span></span><br><span class="line"><span class="comment">         * 1. 如果当前线程被中断，抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 2. 保存getState返回的锁状态。</span></span><br><span class="line"><span class="comment">         * 3. 以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span></span><br><span class="line"><span class="comment">         * 4. 阻塞直到发出信号、中断或超时为止。</span></span><br><span class="line"><span class="comment">         * 5. 通过以保存状态作为参数调用acquire的特殊版本来重新获取。</span></span><br><span class="line"><span class="comment">         * 6. 如果在第4步阻塞时中断，则抛出InterruptedException。</span></span><br><span class="line"><span class="comment">         * 7. 如果在第4步阻塞时超时，则返回false，否则返回true。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line">                <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanosTimeout</span> <span class="operator">=</span> unit.toNanos(time);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timedout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    timedout = transferAfterCancelledWait(node);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">            <span class="keyword">return</span> !timedout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  对仪表的支持</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果此条件是由给定的同步对象创建的，则返回true。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查询是否有线程正在等待此条件。实现hasWaiters (AbstractQueuedSynchronizer.ConditionObject)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回等待此条件的线程数的估计值。实现getWaitQueueLength (AbstractQueuedSynchronizer.ConditionObject)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getWaitQueueLength</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                    ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个集合，其中包含可能正在等待此条件的线程。实现getWaitingThreads (AbstractQueuedSynchronizer.ConditionObject)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title function_">getWaitingThreads</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">w</span> <span class="operator">=</span> firstWaiter; w != <span class="literal">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                        list.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 安装以支持compareAndSet。我们需要在这里本地实现它:为了允许将来的增强，我们不能显式地继承AtomicInteger，</span></span><br><span class="line"><span class="comment">     * 否则这将是有效和有用的。因此，作为最小的缺点，我们使用热点固有API来本地实现。同时，我们对其他CASable字段</span></span><br><span class="line"><span class="comment">     * 也做同样的事情(否则可以使用原子字段更新器完成)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;state&quot;</span>));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;head&quot;</span>));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">&quot;tail&quot;</span>));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;waitStatus&quot;</span>));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(<span class="string">&quot;next&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS head字段。仅供enq使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS tail字段。仅供enq使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的CAS waitStatus字段。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetWaitStatus</span><span class="params">(Node node,</span></span><br><span class="line"><span class="params">                                                         <span class="type">int</span> expect,</span></span><br><span class="line"><span class="params">                                                         <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                                        expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CAS节点下一个字段。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetNext</span><span class="params">(Node node,</span></span><br><span class="line"><span class="params">                                                   Node expect,</span></span><br><span class="line"><span class="params">                                                   Node update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小奥</div><div class="post-copyright__author_desc">浮生若梦 为欢几何</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/')">Java并发之AQS源码篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java并发之AQS源码篇&amp;url=http://example.com/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/&amp;pic=/img/png/3.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小奥</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">13</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/AQS/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>AQS<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/png/8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E7%AF%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/22.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发之ReentrantLock源码篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java并发之synchronized详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">Java、数据库、中间件</b>相关的学习笔记，还有<b style="color:#fff">面试题总结</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小奥</h1><div class="author-info__desc">浮生若梦 为欢几何</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoaozz" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">Java并发之AQS源码篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">二、完整源码</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/04/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/" title="Java并发之synchronized详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之synchronized详解"/></a><div class="content"><a class="title" href="/2024/02/04/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized%E8%AF%A6%E8%A7%A3/" title="Java并发之synchronized详解">Java并发之synchronized详解</a><time datetime="2024-02-04T12:26:07.000Z" title="发表于 2024-02-04 20:26:07">2024-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之AQS源码篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之AQS源码篇"/></a><div class="content"><a class="title" href="/2024/01/29/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之AQS源码篇">Java并发之AQS源码篇</a><time datetime="2024-01-29T12:26:17.000Z" title="发表于 2024-01-29 20:26:17">2024-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之ReentrantLock源码篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/22.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之ReentrantLock源码篇"/></a><div class="content"><a class="title" href="/2024/01/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8BReentrantLock%E6%BA%90%E7%A0%81%E7%AF%87/" title="Java并发之ReentrantLock源码篇">Java并发之ReentrantLock源码篇</a><time datetime="2024-01-28T12:08:06.000Z" title="发表于 2024-01-28 20:08:06">2024-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3OOM/" title="带你学习如何排查和解决OOM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="带你学习如何排查和解决OOM"/></a><div class="content"><a class="title" href="/2024/01/25/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3OOM/" title="带你学习如何排查和解决OOM">带你学习如何排查和解决OOM</a><time datetime="2024-01-25T12:18:47.000Z" title="发表于 2024-01-25 20:18:47">2024-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/22/Java%E4%B9%8BBigDecimal%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Java之BigDecimal使用正确姿势"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/22.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java之BigDecimal使用正确姿势"/></a><div class="content"><a class="title" href="/2024/01/22/Java%E4%B9%8BBigDecimal%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Java之BigDecimal使用正确姿势">Java之BigDecimal使用正确姿势</a><time datetime="2024-01-22T13:51:24.000Z" title="发表于 2024-01-22 21:51:24">2024-01-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="小奥" target="_blank">小奥</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">12</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 0.88rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 0.88rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 0.88rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 0.88rem;">Feed流<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 0.88rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 0.88rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 0.88rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 0.88rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 0.88rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 0.88rem;">ReentrantLock<sup>1</sup></a><a href="/tags/Servlet/" style="font-size: 0.88rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 0.88rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 0.88rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 0.88rem;">synchronized<sup>1</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 0.88rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 0.88rem;">文件上传<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">算法模板<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8956954060&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小奥 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>