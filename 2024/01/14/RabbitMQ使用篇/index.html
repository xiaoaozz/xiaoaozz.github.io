<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>RabbitMQ使用篇 | 小奥</title><meta name="keywords" content="RabbitMQ"><meta name="author" content="小奥,3189137314@qq.com"><meta name="copyright" content="小奥"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="RabbitMQ使用篇"><meta name="application-name" content="RabbitMQ使用篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ使用篇"><meta property="og:url" content="http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/index.html"><meta property="og:site_name" content="小奥"><meta property="og:description" content="RabbitMQ使用篇一、消息队列概述1.1 同步通讯和异步通讯微服务间通讯有同步和异步两种方式：  同步通讯 异步通讯   同步通讯  微服务之间的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：  耦合度高：每次加入新的需求，都要修改原来的代码 性能下降：调用者需要等待"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/png/10.png"><meta property="article:author" content="小奥"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/png/10.png"><meta name="description" content="RabbitMQ使用篇一、消息队列概述1.1 同步通讯和异步通讯微服务间通讯有同步和异步两种方式：  同步通讯 异步通讯   同步通讯  微服务之间的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：  耦合度高：每次加入新的需求，都要修改原来的代码 性能下降：调用者需要等待"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 编程知识爱好者","🔍 分享与热心帮助","🏠 面试总结小能手","🔨 设计开发一条龙","🤝 源码阅读与解析","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 小奥","link":"链接: ","source":"来源: 小奥","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小奥',
  title: 'RabbitMQ使用篇',
  postAI: '',
  pageFillDescription: 'RabbitMQ使用篇, 一、消息队列概述, 1.1 同步通讯和异步通讯, 1.2 MQ对比, 二、 RabbitMQ, 2.1 消息模型, 2.2 入门案例, (1) publisher实现, (2) consumer实现, 三、SpringAMQP, 3.1 Basic Queue 基本消息队列, (1) 消息发送, (2) 消息接收, (3) 测试, 3.2 WorkQueue工作消息队列, (1) 消息发送, (2) 消息接收, (3) 测试, (4) 按需获取消息, 3.3 发布x2F订阅模型, 3.4 Fanout广播消息队列, (1) Spring原生声明交换机和队列, (2) 消息发送, (3) 消息接收, 3.5 Direct定向消息队列, (1) 基于注解声明交换机和队列, (2) 消息发送, 3.6 Topic通配消息队列, (1) 消息发送, (2) 消息接收, 3.7 消息转换器, (1) 配置JSON序列化, 四、消息可靠性, 4.1 生产者消息确认, (1) 修改配置, (2) 定义Return回调, (3) 定义ConfirmCallback, 4.2 消息持久化, (1) 交换机持久化, (2) 队列持久化, (3) 消息持久化, 4.3 消费者确认, (1) none模式, (2) auto模式, 4.4 消费者失败重试机制, (1) 本地重试, (2) 失败策略, 五、死信交换机, 5.1 死信交换机, 利用死信交换机接收死信, 5.2 TTL, (1) 接收超时死信的死信交换机, (2) 声明队列并设置TTL, (3) 发送消息设定TTL, 5.3 延迟队列, (1) DelayExchange原理, (2) 使用DelayExchange, ① 声明DelayExchange, ② 发送消息, 六、惰性队列, 6.1 消息堆积问题, 6.2 惰性队列, (1) 基于命令行设置lazy-queue, (2) 基于Bean声明lazy-queue, (3) 基于@RabbitListener声明lazy-queue, 七、MQ集群, 7.1 集群分类, 7.2 普通集群, (1) 集群结构和特征, (2) 部署, 7.3 镜像集群, (1) 集群结构和特征, (2) 部署, 7.4 仲裁队列, (1) 集群特征, (2) 部署, (3) 创建仲裁队列使用篇一消息队列概述同步通讯和异步通讯微服务间通讯有同步和异步两种方式同步通讯异步通讯同步通讯微服务之间的调用就属于同步方式虽然调用可以实时得到结果但存在下面的问题耦合度高每次加入新的需求都要修改原来的代码性能下降调用者需要等待服务提供者响应如果调用链过长则响应时间等于每次调用的时间之和资源浪费调用链中的每个服务在等待响应过程中不能释放占用的资源高并发场景下会极度浪费系统资源级联失败如果服务调用者出现问题所有调用方都会跟着出问题迅速会导致微服务群故障异步通讯异步调用则可以避免上述问题我们以购买商品为例用户支付后需要调用订单服务完成订单状态修改调用物流服务从仓库分配响应的库存并准备发货在事件模式中支付服务是事件发布者在支付完成后只需要发布一个支付成功的事件事件中带上订单订单服务和物流服务是事件订阅者订阅支付成功的事件监听到事件后完成自己业务即可为了解除事件发布者与订阅者之间的耦合两者并不是直接通信而是有一个中间人发布者发布事件到不关心谁来订阅事件订阅者从订阅事件不关心谁发来的消息是一个像数据总线一样的东西所有的服务要接收数据和发送数据都发到这个总线上这个总线就像协议一样让服务间的通讯变得标准和可控好处吞吐量提升无需等待订阅者处理完成响应更快速故障隔离服务没有直接调用不存在级联失败问题调用间没有阻塞不会造成无效的资源占用耦合度极低每个服务都可以灵活插拔可替换流量削峰不管发布事件的流量波动多大都由接收订阅者可以按照自己的速度去处理事件缺点架构复杂了业务没有明显的流程线不好管理需要依赖于的可靠安全性能对比中文是消息队列字面来看就是存放消息的队列也就是事件驱动架构中的比较常见的实现几种常见的对比公司社区阿里开发语言协议支持自定义协议自定义协议可用性高一般高高单机吞吐量一般差高非常高消息延迟微秒级毫秒级毫秒级毫秒以内消息可靠性高一般高一般追求可用性追求可靠性追求吞吐能力追求消息低延迟二中的一些角色生产者消费者交换机负责消息路由队列存储消息虚拟主机隔离不同租户的消息的隔离消息模型官方提供了个不同的示例对应了不同的消息模型入门案例简单队列模式的模型图官方的是基于最基础的消息队列模型来实现的只包括三个角色消息发布者将消息发送到队列消息队列负责接受并缓存消息订阅队列处理队列中的消息实现思路建立连接创建声明队列发送消息关闭连接和代码实现建立连接设置连接参数分别是主机名端口号用户名密码建立连接创建通道创建队列发送消息发送消息成功关闭通道和连接实现代码思路建立连接创建声明队列订阅消息代码实现建立连接设置连接参数分别是主机名端口号用户名密码建立连接创建通道创建队列订阅消息处理消息接收到消息等待接收消息总结基本消息队列的消息发送流程建立创建利用声明队列利用向队列发送消息基本消息队列的消息接收流程建立创建利用声明队列定义的消费行为利用将消费者与队列绑定三是基于封装的一套模板并且还利用对其实现了自动装配使用起来非常方便的官方地址提供了三个功能自动声明队列交换机及其绑定关系基于注解的监听器模式异步接收消息封装了工具用于发送消息在使用之前我们首先需要在项目中引入依赖依赖包含下面我们就通过实现这五种不同的模型来进行学习基本消息队列消息发送首先配置地址在服务的中添加配置主机名端口虚拟主机用户名密码然后在服务中编写测试类并利用实现消息发送队列名称消息发送消息消息接收首先配置地址在服务的中添加配置主机名端口虚拟主机用户名密码然后在服务的包中新建一个类代码如下消费者接收到消息测试启动服务然后在服务中运行测试代码发送消息工作消息队列也被称为任务模型简单来说就是让多个消费者绑定到一个队列共同消费队列中的消息当消息处理比较耗时的时候可能生产消息的速度会远远大于消息的消费速度长此以往消息就会堆积越来越多无法及时处理此时就可以使用模型多个消费者共同处理消息处理速度就能大大提高了消息发送这次我们循环发送模拟大量消息堆积现象在服务中的类中添加一个测试方法向队列中不停发送消息模拟消息堆积队列名称消息发送消息消息接收要模拟多个消费者绑定同一个队列我们在服务的中添加个新的方法消费者接收到消息消费者接收到消息注意到这个消费者了用来模拟任务耗时测试启动后在执行服务中刚刚编写的发送测试方法可以看到消费者很快完成了自己的条消息消费者却在缓慢的处理自己的条消息也就是说消息是平均分配给每个消费者并没有考虑到消费者的处理能力这样显然是有问题的按需获取消息在中有一个简单的配置可以解决这个问题我们修改服务的文件添加配置每次只能获取一条消息处理完成才能获取下一个消息发布订阅模型发布订阅的模型如图可以看到在订阅模型中多了一个角色而且过程略有变化生产者也就是要发送消息的程序但是不再发送到队列中而是发给交换机一方面接收生产者发送的消息另一方面知道如何处理消息例如递交给某个特别队列递交给所有队列或是将消息丢弃到底如何操作取决于的类型有以下种类型广播将消息交给所有绑定到交换机的队列定向把消息交给符合指定的队列通配符把消息交给符合路由模式的队列消费者与以前一样订阅队列没有变化消息队列也与以前一样接收消息缓存消息交换机只负责转发消息不具备存储消息的能力因此如果没有任何队列与绑定或者没有符合路由规则的队列那么消息会丢失广播消息队列在广播模式下消息发送流程是这样的可以有多个队列每个队列都要绑定到交换机生产者发送的消息只能发送到交换机交换机来决定要发给哪个队列生产者无法决定交换机把消息发送给绑定过的所有队列订阅队列的消费者都能拿到消息在实际应用中是这样的创建一个交换机类型是创建两个队列和绑定到交换机原生声明交换机和队列提供了一个接口来表示所有不同类型的交换机在中创建一个类声明队列和交换机声明交换机类型交换机第个队列绑定队列和交换机第个队列绑定队列和交换机消息发送在服务的类中添加测试方法队列名称消息消息接收在服务的中添加两个方法作为消费者消费者接收到消息消费者接收到消息定向消息队列在模式中一条消息会被所有订阅的队列都消费但是在某些场景下我们希望不同的消息被不同的队列消费这时就要用到类型的在模型下队列与交换机的绑定不能是任意绑定了而是要指定一个路由消息的发送方在向发送消息时也必须指定消息的不再把消息交给每一个绑定的队列而是根据消息的进行判断只有队列的与消息的完全一致才会接收到消息基于注解声明交换机和队列基于的方式声明队列和交换机比较麻烦还提供了基于注解方式来声明在的中添加两个消费者同时基于注解来声明队列和交换机消费者接收到的消息消费者接收到的消息消息发送在服务的类中添加测试方法交换机名称消息红色警报日本乱排核废水导致海洋生物变异惊现哥斯拉发送消息通配消息队列类型的与相比都是可以根据把消息路由到不同的队列只不过类型可以让队列在绑定的时候使用通配符一般都是有一个或多个单词组成多个单词之间以分割例如通配符规则匹配一个或多个词匹配不多不少恰好个词举例能够匹配或者只能匹配解释绑定的是因此凡是以开头的都会被匹配到包括和绑定的是因此凡是以结尾的都会被匹配包括和消息发送在服务的类中添加测试方法交换机名称消息喜报孙悟空大战哥斯拉胜发送消息消息接收在服务的中添加方法消费者接收到的消息消费者接收到的消息消息转换器会把你发送的消息序列化为字节发送给接收消息的时候还会把字节反序列化为对象只不过默认情况下采用的序列化方式是序列化众所周知序列化存在下列问题数据体积过大有安全漏洞可读性差配置序列化显然序列化方式并不合适我们希望消息体的体积更小可读性更高因此可以使用方式来做序列化和反序列化在和两个服务中都引入依赖配置消息转换器在启动类中添加一个即可这样我们就可以在控制台看到我们的消息的数据了而不是以字节的方式显示四消息可靠性消息从发送到消费者接收会经理多个过程其中的每一步都可能导致消息丢失常见的丢失原因包括发送时丢失生产者发送的消息未送达消息到达后未到达宕机将消息丢失接收到消息后未消费就宕机针对这些问题分别给出了解决方案生产者确认机制持久化消费者确认机制失败重试机制生产者消息确认提供了机制来避免消息发送到过程中丢失这种机制必须给每个消息指定一个唯一消息发送到以后会返回一个结果给发送者表示消息是否处理成功返回结果有两种方式发送者确认消息成功投递到交换机返回消息未投递到交换机返回发送者回执消息投递到交换机了但是没有路由到队列返回及路由失败原因注意确定机制发送消息时需要给每个消息设置一个全局唯一以区分不同消息避免冲突修改配置首先修改服务中的文件添加下面的内容异步回调消息路由失败策略回调说明开启这里支持两种类型同步等待结果直到超时异步回调定义返回结果时会回调这个开启功能同样是基于机制不过是定义定义消息路由失败时的策略则调用则直接丢弃消息定义回调每个只能配置一个因此需要在项目加载时配置修改服务添加一个获取设置投递失败记录日志消息发送失败应答码原因交换机路由键消息如果有业务需要可以重发消息定义可以在发送消息时指定因为每个业务处理成功或失败的逻辑不一定相同在服务中定义一个单元测试方法消息体全局唯一的消息需要封装到中添加消息成功消息发送成功消息失败消息发送失败原因消息发送异常原因发送消息休眠一会儿等待回执消息持久化生产者确认可以确保消息投递到的队列中但是消息发送到以后如果突然宕机也可能导致消息丢失要想确保消息在中安全保存必须开启消息持久化机制交换机持久化队列持久化消息持久化交换机持久化中交换机默认是非持久化的重启后就丢失中可以通过代码指定交换机持久化三个参数交换机名称是否持久化当没有与其绑定时是否自动删除事实上默认情况下由声明的交换机都是持久化的可以在控制台看到持久化的交换机都会带上的标示队列持久化中队列默认是非持久化的重启后就丢失中可以通过代码指定交换机持久化使用构建队列就是持久化的事实上默认情况下由声明的队列都是持久化的可以在控制台看到持久化的队列都会带上的标示消息持久化利用发送消息时可以设置消息的属性指定非持久化持久化用代码指定准备消息持久化发送消息默认情况下发出的任何消息都是持久化的不用特意指定消费者确认是阅后即焚机制确认消息被消费者消费后会立刻删除而是通过消费者回执来确认消费者是否成功处理消息的消费者获取消息后应该向发送回执表明自己已经处理消息设想这样的场景投递消息给消费者消费者获取消息后返回给删除消息消费者宕机消息尚未处理这样消息就丢失了因此消费者返回的时机非常重要而则允许配置三种确认模式手动需要在业务代码结束后调用发送自动由监测代码是否出现异常没有异常则返回抛出异常则返回关闭假定消费者获取消息后会成功处理因此消息投递后立即被删除由此可知模式下消息投递是不可靠的可能丢失模式类似事务机制出现异常时返回消息回滚到没有异常返回自己根据业务情况判断什么时候该一般我们都是使用默认的即可模式修改服务的文件添加下面内容关闭修改服务的类中的方法模拟一个消息处理异常消费者接收到的消息模拟异常消息处理完成测试可以发现当消息处理抛异常时消息依然被删除了模式再次把确认机制修改为关闭在异常位置打断点再次发送消息程序卡在断点时可以发现此时消息状态为未确定状态抛出异常后因为会自动返回所以消息恢复至状态并且没有被删除消费者失败重试机制当消费者出现异常后消息会不断重入队到队列再重新发送给消费者然后再次异常再次无限循环导致的消息处理飙升带来不必要的压力本地重试我们可以利用的机制在消费者出现异常时利用本地重试而不是无限制的到队列修改服务的文件添加内容开启消费者失败重试初识的失败等待时长为秒失败的等待时长倍数下次等待时长最大重试次数无状态有状态如果业务中包含事务这里改为重启服务重复之前的测试可以发现在重试次后会抛出异常说明本地重试触发了查看控制台发现消息被删除了说明最后返回的是删除消息了结论开启本地重试时消息处理过程中抛出异常不会到队列而是在消费者本地重试重试达到最大次数后会返回消息会被丢弃失败策略在之前的测试中达到最大重试次数后消息会被丢弃这是由内部机制决定的在开启重试模式后重试次数耗尽如果消息依然失败则需要有接口来处理它包含三种不同的实现重试次数耗尽后直接丢弃消息默认就是这种方式重试次数耗尽后返回消息重新入队重试次数耗尽后将失败消息投递到指定的交换机比较优雅的一种处理方案是失败后将消息投递到一个指定的专门存放异常消息的队列后续由人工集中处理在服务中定义处理失败消息的交换机和队列定义一个关联队列和交换机总结如何保证的消息可靠性开启生产者确认机制确保生产者的消息能到达队列开启消息持久化功能确保消息未消费前在队列中不会丢失开启消费者确认机制为由确认消息处理成功后完成开启消费者失败重试机制并设置多次重试失败后将消息投递到异常交换机交由人工处理五死信交换机死信交换机什么是死信当一个队列中的消息满足下列情况之一时可以成为死信消费者使用或声明消费失败并且消息的参数设置为消息是一个过期消息超时无人消费要投递的队列消息满了无法投递如果这个包含死信的队列配置了属性指定了一个交换机那么队列中的死信就会投递到这个交换机中而这个交换机称为死信交换机简称如图一个消息被消费者拒绝了变成了死信因为绑定了死信交换机因此死信会投递给这个交换机如果这个死信交换机也绑定了一个队列则消息最终会进入这个存放死信的队列另外队列将死信投递给死信交换机时必须知道两个信息死信交换机名称死信交换机与死信队列绑定的这样才能确保投递的消息能到达死信交换机并且正确的路由到死信队列利用死信交换机接收死信在失败重试策略中默认的会在本地重试次数耗尽后发送给消息变成死信被丢弃我们可以给添加一个死信交换机给死信交换机绑定一个队列这样消息变成死信后也不会丢弃而是最终投递到死信交换机路由到与死信交换机绑定的队列我们在服务中定义一组死信交换机死信队列声明普通的队列并且为其指定死信交换机指定队列名称并持久化指定死信交换机声明死信交换机声明存储死信的队列将死信队列与死信交换机绑定一个队列中的消息如果超时未消费则会变为死信超时分为两种情况消息所在的队列设置了超时时间消息本身设置了超时时间接收超时死信的死信交换机在服务的中定义一个新的消费者并且声明死信交换机死信队列接收到的延迟消息声明队列并设置要给队列设置超时时间需要在声明队列时配置属性指定队列名称并持久化设置队列的超时时间秒指定死信交换机注意这个队列设定了死信交换机为声明交换机将与交换机绑定发送消息但是不要指定创建消息消息需要封装到中发送消息记录日志发送消息成功因为队列的值是也就是秒可以通过日志查看消息发送与接收之间的时差刚好是秒发送消息设定在发送消息时也可以指定创建消息消息需要封装到中发送消息发送消息成功另外需要注意当队列消息都设置了时任意一个到期该消息就会成为死信延迟队列利用结合死信交换机我们实现了消息发出后消费者延迟收到消息的效果这种消息模式就称为延迟队列模式延迟队列的使用场景包括延迟发送短信用户下单如果用户在分钟内未支付则自动取消预约工作会议分钟后自动通知所有参会人员因为延迟队列的需求非常多所以的官方也推出了一个插件原生支持延迟队列效果这个插件就是插件参考的插件列表页面使用方式可以参考官网地址原理需要将一个交换机声明为类型当我们发送消息到时流程如下接收消息判断消息是否具备属性如果有属性说明是延迟消息持久化到硬盘读取值作为延迟时间返回结果给消息发送者时间到期后重新投递消息到指定队列使用插件的使用也非常简单声明一个交换机交换机的类型可以是任意类型只需要设定属性为即可然后声明队列与其绑定即可声明基于注解方式推荐消费者接收到了的延迟消息基于方式指定交换机类型和名称设置属性为持久化发送消息发送消息时一定要携带属性指定延迟的时间创建消息消息需要封装到中发送消息发送消息成功六惰性队列消息堆积问题当生产者发送消息的速度超过了消费者处理消息的速度就会导致队列中的消息堆积直到队列存储消息达到上限之后发送的消息就会成为死信可能会被丢弃这就是消息堆积问题解决消息堆积有两种思路增加更多消费者提高消费速度也就是我们之前说的模式扩大队列容积提高堆积上限要提升队列容积把消息保存在内存中显然是不行的惰性队列从的版本开始就增加了的概念也就是惰性队列惰性队列的特征如下接收到消息后直接存入磁盘而非内存消费者要消费消息时才会从磁盘中读取并加载到内存支持数百万条的消息存储基于命令行设置而要设置一个队列为惰性队列只需要在声明队列时指定属性为即可可以通过命令行将一个运行中的队列修改为惰性队列命令解读的命令行工具添加一个策略策略名称可以自定义用正则表达式匹配队列的名字设置队列模式为模式策略的作用对象是所有的队列基于声明开启为基于声明接收到的消息总结惰性队列的优缺点惰性队列的优点有哪些基于磁盘存储消息上限高没有间歇性的性能比较稳定惰性队列的缺点有哪些基于磁盘存储消息时效性会降低性能受限于磁盘的七集群集群分类的是基于语言编写而又是一个面向并发的语言天然支持集群模式的集群有两种模式普通集群是一种分布式集群将队列分散到集群的各个节点从而提高整个集群的并发能力镜像集群是一种主从集群普通集群的基础上添加了主从备份功能提高集群的数据可用性镜像集群虽然支持主从但主从同步并不是强一致的某些情况下可能有数据丢失的风险因此在的版本以后推出了新的功能仲裁队列来代替镜像集群底层采用协议确保主从的数据一致性普通集群集群结构和特征普通集群或者叫标准集群具备下列特征会在集群的各个节点间共享部分数据包括交换机队列元信息不包含队列中的消息当访问集群某节点时如果队列不在该节点会从数据所在节点传递到当前节点并返回队列所在节点宕机队列中的消息就会丢失结构如图部署这里不再给出详细部署步骤请读者自行查阅镜像集群集群结构和特征镜像集群本质是主从模式具备下面的特征交换机队列队列中的消息会在各个的镜像节点之间同步备份创建队列的节点被称为该队列的主节点备份到的其它节点叫做该队列的镜像节点一个队列的主节点可能是另一个队列的镜像节点所有操作都是主节点完成然后同步给镜像节点主宕机后镜像节点会替代成新的主结构如图部署这里不再给出详细部署步骤请读者自行查阅仲裁队列集群特征仲裁队列是版本以后才有的新功能用来替代镜像队列具备下列特征与镜像队列一样都是主从模式支持主从数据同步使用非常简单没有复杂的配置主从同步基于协议强一致部署这里不再给出详细部署步骤请读者自行查阅创建仲裁队列持久化仲裁队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-14 22:34:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小奥</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 1.05rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 1.05rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 1.05rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 1.05rem;">Feed流<sup>1</sup></a><a href="/tags/Full-GC/" style="font-size: 1.05rem;">Full GC<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 1.05rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 1.05rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 1.05rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 1.05rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 1.05rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 1.05rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 1.05rem;">ReentrantLock<sup>1</sup></a><a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">SQL优化<sup>2</sup></a><a href="/tags/Servlet/" style="font-size: 1.05rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 1.05rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 1.05rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 1.05rem;">synchronized<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>3</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>2</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 1.05rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 1.05rem;">文件上传<sup>1</sup></a><a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 1.05rem;">死锁<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 1.05rem;">算法模板<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url">消息队列</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/RabbitMQ/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>RabbitMQ</span></a></span></div></div><h1 class="post-title" itemprop="name headline">RabbitMQ使用篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-01-14T08:29:24.000Z" title="发表于 2024-01-14 16:29:24">2024-01-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-01-14T14:34:03.573Z" title="更新于 2024-01-14 22:34:03">2024-01-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为河南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>河南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/png/10.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url">消息队列</a><a href="/tags/RabbitMQ/" tabindex="-1" itemprop="url">RabbitMQ</a><h1 id="CrawlerTitle" itemprop="name headline">RabbitMQ使用篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小奥</span><time itemprop="dateCreated datePublished" datetime="2024-01-14T08:29:24.000Z" title="发表于 2024-01-14 16:29:24">2024-01-14</time><time itemprop="dateCreated datePublished" datetime="2024-01-14T14:34:03.573Z" title="更新于 2024-01-14 22:34:03">2024-01-14</time></header><h1 id="RabbitMQ使用篇"><a href="#RabbitMQ使用篇" class="headerlink" title="RabbitMQ使用篇"></a>RabbitMQ使用篇</h1><h1 id="一、消息队列概述"><a href="#一、消息队列概述" class="headerlink" title="一、消息队列概述"></a>一、消息队列概述</h1><h2 id="1-1-同步通讯和异步通讯"><a href="#1-1-同步通讯和异步通讯" class="headerlink" title="1.1 同步通讯和异步通讯"></a>1.1 同步通讯和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p>
<ul>
<li>同步通讯</li>
<li>异步通讯</li>
</ul>
<blockquote>
<p>同步通讯</p>
</blockquote>
<p>微服务之间的Feign调用就属于同步方式，虽然<strong>调用可以实时得到结果</strong>，但存在下面的问题：</p>
<ul>
<li><strong>耦合度高</strong>：每次加入新的需求，都要修改原来的代码</li>
<li><strong>性能下降</strong>：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和</li>
<li><strong>资源浪费</strong>：调用链中的每个服务在等待响应过程中，不能释放占用的资源，高并发场景下会极度浪费系统资源</li>
<li><strong>级联失败</strong>：如果服务调用者出现问题，所有调用方都会跟着出问题，迅速会导致微服务群故障</li>
</ul>
<blockquote>
<p>异步通讯</p>
</blockquote>
<p>异步调用则可以避免上述问题：</p>
<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>
<ul>
<li><p>在事件模式中，支付服务是<strong>事件发布者（publisher）</strong>，在支付完成后只需要发布一个支付成功的<strong>事件（event）</strong>，事件中带上订单id。</p>
</li>
<li><p>订单服务和物流服务是<strong>事件订阅者（Consumer）</strong>，订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
</li>
</ul>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个<strong>中间人（Broker）</strong>。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114163618297.png" alt="image-20240114163618297"></p>
<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>
<p>好处：</p>
<ul>
<li><p><strong>吞吐量提升</strong>：无需等待订阅者处理完成，响应更快速</p>
</li>
<li><p><strong>故障隔离</strong>：服务没有直接调用，不存在级联失败问题</p>
</li>
<li><p><strong>调用间没有阻塞</strong>，不会造成无效的资源占用</p>
</li>
<li><p><strong>耦合度极低</strong>，每个服务都可以灵活插拔，可替换</p>
</li>
<li><p><strong>流量削峰</strong>：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<h2 id="1-2-MQ对比"><a href="#1-2-MQ对比" class="headerlink" title="1.2 MQ对比"></a>1.2 MQ对比</h2><p>MQ，中文是<strong>消息队列</strong>（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<p>比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire，STOMP，REST，XMPP，AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<ul>
<li>追求可用性：Kafka、 RocketMQ 、RabbitMQ</li>
<li>追求可靠性：RabbitMQ、RocketMQ</li>
<li>追求吞吐能力：RocketMQ、Kafka</li>
<li>追求消息低延迟：RabbitMQ、Kafka</li>
</ul>
<h1 id="二、-RabbitMQ"><a href="#二、-RabbitMQ" class="headerlink" title="二、 RabbitMQ"></a>二、 RabbitMQ</h1><p>RabbitMQ中的一些角色：</p>
<ul>
<li><code>publisher</code>：生产者</li>
<li><code>consumer</code>：消费者</li>
<li><code>exchange</code>：交换机，负责消息路由</li>
<li><code>queue</code>：队列，存储消息</li>
<li><code>virtualHost</code>：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114163825824.png" alt="image-20240114163825824"></p>
<h2 id="2-1-消息模型"><a href="#2-1-消息模型" class="headerlink" title="2.1 消息模型"></a>2.1 消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114164119149.png" alt="image-20240114164119149"></p>
<h2 id="2-2-入门案例"><a href="#2-2-入门案例" class="headerlink" title="2.2 入门案例"></a>2.2 入门案例</h2><p>简单队列模式的模型图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114164253945.png" alt="image-20240114164253945"></p>
<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li><code>publisher</code>：消息发布者，将消息发送到队列queue</li>
<li><code>queue</code>：消息队列，负责接受并缓存消息</li>
<li><code>consumer</code>：订阅队列，处理队列中的消息</li>
</ul>
<h3 id="1-publisher实现"><a href="#1-publisher实现" class="headerlink" title="(1) publisher实现"></a>(1) publisher实现</h3><p>思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>发送消息</li>
<li>关闭连接和channel</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-consumer实现"><a href="#2-consumer实现" class="headerlink" title="(2) consumer实现"></a>(2) consumer实现</h3><p>代码思路：</p>
<ul>
<li>建立连接</li>
<li>创建Channel</li>
<li>声明队列</li>
<li>订阅消息</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p>基本消息队列的消息发送流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>利用channel向队列发送消息</p>
</li>
</ol>
<p>基本消息队列的消息接收流程：</p>
<ol>
<li><p>建立connection</p>
</li>
<li><p>创建channel</p>
</li>
<li><p>利用channel声明队列</p>
</li>
<li><p>定义consumer的消费行为handleDelivery()</p>
</li>
<li><p>利用channel将消费者与队列绑定</p>
</li>
</ol>
<h1 id="三、SpringAMQP"><a href="#三、SpringAMQP" class="headerlink" title="三、SpringAMQP"></a>三、SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAmqp的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114164518727.png" alt="image-20240114164518727"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114164529029.png" alt="image-20240114164529029"></p>
<p>SpringAMQP提供了三个功能：</p>
<ul>
<li><strong>自动声明队列、交换机及其绑定关系</strong></li>
<li><strong>基于注解的监听器模式，异步接收消息</strong></li>
<li><strong>封装了<code>RabbitTemplate</code>工具，用于发送消息</strong></li>
</ul>
<p>在使用SpringAMQP之前，我们首先需要在项目中引入MQ依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>下面我们就通过实现这五种不同的模型来进行学习RabbitMQ。</p>
<h2 id="3-1-Basic-Queue-基本消息队列"><a href="#3-1-Basic-Queue-基本消息队列" class="headerlink" title="3.1 Basic Queue 基本消息队列"></a>3.1 Basic Queue 基本消息队列</h2><h3 id="1-消息发送"><a href="#1-消息发送" class="headerlink" title="(1) 消息发送"></a>(1) 消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">192.168</span>.x.x # 主机名</span><br><span class="line">    port: <span class="number">5672</span> # 端口</span><br><span class="line">    virtual-host: / # 虚拟主机</span><br><span class="line">    username: xxx # 用户名</span><br><span class="line">    password: xxx # 密码</span><br></pre></td></tr></table></figure>

<p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-消息接收"><a href="#2-消息接收" class="headerlink" title="(2) 消息接收"></a>(2) 消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="string">.x.x</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxx</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>



<p>然后在<code>consumer</code>服务的包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="(3) 测试"></a>(3) 测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。</p>
<h2 id="3-2-WorkQueue工作消息队列"><a href="#3-2-WorkQueue工作消息队列" class="headerlink" title="3.2 WorkQueue工作消息队列"></a>3.2 WorkQueue工作消息队列</h2><p><code>Work queues</code>，也被称为（<code>Task queues</code>）任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114165302909.png" alt="image-20240114165302909"></p>
<p>当消息处理<strong>比较耗时</strong>的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>
<p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>
<h3 id="1-消息发送-1"><a href="#1-消息发送-1" class="headerlink" title="(1) 消息发送"></a>(1) 消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p>
<p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * workQueue</span></span><br><span class="line"><span class="comment">    * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">// 队列名称</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">       <span class="comment">// 消息</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 发送消息</span></span><br><span class="line">           rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">           Thread.sleep(<span class="number">20</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-消息接收-1"><a href="#2-消息接收-1" class="headerlink" title="(2) 消息接收"></a>(2) 消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这个消费者sleep了，用来模拟任务耗时。</p>
<h3 id="3-测试-1"><a href="#3-测试-1" class="headerlink" title="(3) 测试"></a>(3) 测试</h3><p>启动<code>ConsumerApplication</code>后，在执行<code>publisher</code>服务中刚刚编写的发送测试方法<code>testWorkQueue</code>。</p>
<p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p>
<p>也就是说消息是<strong>平均分配</strong>给每个消费者，并<strong>没有考虑到消费者的处理能力</strong>。这样显然是有问题的。</p>
<h3 id="4-按需获取消息"><a href="#4-按需获取消息" class="headerlink" title="(4) 按需获取消息"></a>(4) 按需获取消息</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-发布-订阅模型"><a href="#3-3-发布-订阅模型" class="headerlink" title="3.3 发布&#x2F;订阅模型"></a>3.3 发布&#x2F;订阅模型</h2><p>发布订阅的模型如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114165820401.png" alt="image-20240114165820401"></p>
<p>可以看到，在订阅模型中，多了一个<code>exchange</code>角色，而且过程略有变化：</p>
<ul>
<li><code>Publisher</code>：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给<code>exchange</code>。</li>
<li><code>Exchange</code>：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li><code>Fanout</code>：<strong>广播</strong>，将消息交给所有绑定到交换机的队列。</li>
<li><code>Direct</code>：<strong>定向</strong>，把消息交给符合指定routing key 的队列。</li>
<li><code>Topic</code>：<strong>通配符</strong>，把消息交给符合routing pattern（路由模式） 的队列。</li>
</ul>
</li>
<li><code>Consumer</code>：消费者，与以前一样，订阅队列，没有变化。</li>
<li><code>Queue</code>：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="3-4-Fanout广播消息队列"><a href="#3-4-Fanout广播消息队列" class="headerlink" title="3.4 Fanout广播消息队列"></a>3.4 Fanout广播消息队列</h2><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>可以有多个队列</li>
<li>每个队列都要绑定到Exchange（交换机）</li>
<li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>订阅队列的消费者都能拿到消息</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114170051357.png" alt="image-20240114170051357"></p>
<p>在实际应用中是这样的：</p>
<ul>
<li>创建一个交换机<code>xxx.fanout</code>，类型是<code>Fanout</code></li>
<li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>xxx.fanout</code></li>
</ul>
<h3 id="1-Spring原生声明交换机和队列"><a href="#1-Spring原生声明交换机和队列" class="headerlink" title="(1) Spring原生声明交换机和队列"></a>(1) Spring原生声明交换机和队列</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114170313963.png" alt="image-20240114170313963"></p>
<p>在<code>consumer</code>中创建一个类，声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;xxx.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-消息发送"><a href="#2-消息发送" class="headerlink" title="(2) 消息发送"></a>(2) 消息发送</h3><p>在<code>publisher</code>服务的<code>SpringAmqpTest</code>类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-消息接收"><a href="#3-消息接收" class="headerlink" title="(3) 消息接收"></a>(3) 消息接收</h3><p>在<code>consumer</code>服务的<code>SpringRabbitListener</code>中添加两个方法，作为消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-Direct定向消息队列"><a href="#3-5-Direct定向消息队列" class="headerlink" title="3.5 Direct定向消息队列"></a>3.5 Direct定向消息队列</h2><p>在<code>Fanout</code>模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到<code>Direct</code>类型的<code>Exchange</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114170556660.png" alt="image-20240114170556660"></p>
<p>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<h3 id="1-基于注解声明交换机和队列"><a href="#1-基于注解声明交换机和队列" class="headerlink" title="(1) 基于注解声明交换机和队列"></a>(1) 基于注解声明交换机和队列</h3><p>基于<code>@Bean</code>的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p>
<p>在<code>consumer</code>的<code>SpringRabbitListener</code>中添加两个消费者，同时基于注解来声明队列和交换机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-消息发送-1"><a href="#2-消息发送-1" class="headerlink" title="(2) 消息发送"></a>(2) 消息发送</h3><p>在<code>publisher</code>服务的<code>SpringAmqpTest</code>类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;xxx.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-Topic通配消息队列"><a href="#3-6-Topic通配消息队列" class="headerlink" title="3.6 Topic通配消息队列"></a>3.6 Topic通配消息队列</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p><code>#</code>：匹配一个或多个词</p>
<p><code>*</code>：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
<p><code>item.*</code>：只能匹配<code>item.spu</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114170913116.png" alt="image-20240114170913116"></p>
<p>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue4：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<h3 id="1-消息发送-2"><a href="#1-消息发送-2" class="headerlink" title="(1) 消息发送"></a>(1) 消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * topicExchange</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 交换机名称</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;xxx.topic&quot;</span>;</span><br><span class="line">       <span class="comment">// 消息</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">       <span class="comment">// 发送消息</span></span><br><span class="line">       rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-消息接收-2"><a href="#2-消息接收-2" class="headerlink" title="(2) 消息接收"></a>(2) 消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7 消息转换器"></a>3.7 消息转换器</h2><p>Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p>
<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<h3 id="1-配置JSON序列化"><a href="#1-配置JSON序列化" class="headerlink" title="(1) 配置JSON序列化"></a>(1) 配置JSON序列化</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置消息转换器。</p>
<p>在启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在MQ控制台看到我们的消息的数据了，而不是以字节的方式显示。</p>
<h1 id="四、消息可靠性"><a href="#四、消息可靠性" class="headerlink" title="四、消息可靠性"></a>四、消息可靠性</h1><p>消息从发送，到消费者接收，会经理多个过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114171504698.png" alt="image-20240114171504698"></p>
<p>其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p>
<ul>
<li><strong>发送时丢失</strong>：<ul>
<li>生产者发送的消息未送达exchange</li>
<li>消息到达exchange后未到达queue</li>
</ul>
</li>
<li><strong>MQ宕机</strong>，queue将消息丢失</li>
<li><strong>consumer接收到消息后未消费</strong>就宕机</li>
</ul>
<p>针对这些问题，RabbitMQ分别给出了解决方案：</p>
<ul>
<li><strong>生产者确认机制</strong></li>
<li><strong>mq持久化</strong></li>
<li><strong>消费者确认机制</strong></li>
<li><strong>失败重试机制</strong></li>
</ul>
<h2 id="4-1-生产者消息确认"><a href="#4-1-生产者消息确认" class="headerlink" title="4.1 生产者消息确认"></a>4.1 生产者消息确认</h2><p>RabbitMQ提供了<code>publisher confirm</code>机制来避免消息发送到MQ过程中丢失。<strong>这种机制必须给每个消息指定一个唯一ID。</strong>消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p>
<p>返回结果有两种方式：</p>
<ul>
<li><code>publisher-confirm</code>，发送者确认<ul>
<li>消息<strong>成功投递</strong>到交换机，返回<strong>ack</strong></li>
<li>消息<strong>未投递</strong>到交换机，返回<strong>nack</strong></li>
</ul>
</li>
<li><code>publisher-return</code>，发送者回执<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114184434333.png" alt="image-20240114184434333"></p>
<blockquote>
<p>注意，确定机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突。</p>
</blockquote>
<h3 id="1-修改配置"><a href="#1-修改配置" class="headerlink" title="(1) 修改配置"></a>(1) 修改配置</h3><p>首先，修改<code>publisher</code>服务中的<code>application.yml</code>文件，添加下面的内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 异步回调</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment"># 消息路由失败策略，回调ReturnCallback</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>publish-confirm-type</code>：开启<code>publisher-confirm</code>，这里支持两种类型：<ul>
<li><code>simple</code>：<strong>同步</strong>等待confirm结果，直到超时</li>
<li><code>correlated</code>：<strong>异步</strong>回调，定义<code>ConfirmCallback</code>，MQ返回结果时会回调这个<code>ConfirmCallback</code></li>
</ul>
</li>
<li><code>publish-returns</code>：开启<code>publish-return</code>功能，同样是基于<code>callback</code>机制，不过是定义<code>ReturnCallback</code></li>
<li><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用<code>ReturnCallback</code>；false，则直接丢弃消息。</li>
</ul>
<h3 id="2-定义Return回调"><a href="#2-定义Return回调" class="headerlink" title="(2) 定义Return回调"></a>(2) 定义Return回调</h3><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此需要在项目加载时配置：</p>
<p>修改publisher服务，添加一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">        <span class="comment">// 设置ReturnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 投递失败，记录日志</span></span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                     replyCode, replyText, exchange, routingKey, message.toString());</span><br><span class="line">            <span class="comment">// 如果有业务需要，可以重发消息</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-定义ConfirmCallback"><a href="#3-定义ConfirmCallback" class="headerlink" title="(3) 定义ConfirmCallback"></a>(3) 定义ConfirmCallback</h3><p><code>ConfirmCallback</code>可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。</p>
<p>在publisher服务中，定义一个单元测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 1.消息体</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 3.添加callback</span></span><br><span class="line">    correlationData.getFuture().addCallback(</span><br><span class="line">        result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123;</span><br><span class="line">                <span class="comment">// 3.1.ack，消息成功</span></span><br><span class="line">                log.debug(<span class="string">&quot;消息发送成功, ID:&#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 3.2.nack，消息失败</span></span><br><span class="line">                log.error(<span class="string">&quot;消息发送失败, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(), result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ex -&gt; log.error(<span class="string">&quot;消息发送异常, ID:&#123;&#125;, 原因&#123;&#125;&quot;</span>,correlationData.getId(),ex.getMessage())</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task.direct&quot;</span>, <span class="string">&quot;task&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">// 休眠一会儿，等待ack回执</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-消息持久化"><a href="#4-2-消息持久化" class="headerlink" title="4.2 消息持久化"></a>4.2 消息持久化</h2><p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。</p>
<p>要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p>
<ul>
<li>交换机持久化</li>
<li>队列持久化</li>
<li>消息持久化</li>
</ul>
<h3 id="1-交换机持久化"><a href="#1-交换机持久化" class="headerlink" title="(1) 交换机持久化"></a>(1) 交换机持久化</h3><p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的交换机都会带上<code>D</code>的标示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114185157134.png" alt="image-20240114185157134"></p>
<h3 id="2-队列持久化"><a href="#2-队列持久化" class="headerlink" title="(2) 队列持久化"></a>(2) 队列持久化</h3><p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。</p>
<p>SpringAMQP中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由SpringAMQP声明的队列都是持久化的。</p>
<p>可以在RabbitMQ控制台看到持久化的队列都会带上<code>D</code>的标示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114185226298.png" alt="image-20240114185226298"></p>
<h3 id="3-消息持久化"><a href="#3-消息持久化" class="headerlink" title="(3) 消息持久化"></a>(3) 消息持久化</h3><p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p>
<ul>
<li>1：非持久化</li>
<li>2：持久化</li>
</ul>
<p>用java代码指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDurableMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello, spring&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="comment">// PERSISTENT 持久化</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p>
<h2 id="4-3-消费者确认"><a href="#4-3-消费者确认" class="headerlink" title="4.3 消费者确认"></a>4.3 消费者确认</h2><p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ确认消息被消费者消费后会立刻删除。</p>
<p>而RabbitMQ是<strong>通过消费者回执来确认消费者是否成功处理消息</strong>的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p>
<p>设想这样的场景：</p>
<ul>
<li>RabbitMQ投递消息给消费者</li>
<li>消费者获取消息后，返回ACK给RabbitMQ</li>
<li>RabbitMQ删除消息</li>
<li>消费者宕机，消息尚未处理</li>
</ul>
<p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p>
<p>而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><code>manual</code>：<strong>手动ack</strong>，需要在业务代码结束后，调用api发送ack。</li>
<li><code>auto</code>：<strong>自动ack</strong>，由spring监测<code>listener</code>代码是否出现异常，没有异常则返回ack，抛出异常则返回nack。</li>
<li><code>none</code>：<strong>关闭ack</strong>，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除。</li>
</ul>
<p>由此可知：</p>
<ul>
<li>none模式下，消息投递是不可靠的，可能丢失。</li>
<li>auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack。</li>
<li>manual：自己根据业务情况，判断什么时候该ack。</li>
</ul>
<p>一般，<strong>我们都是使用默认的auto即可</strong>。</p>
<h3 id="1-none模式"><a href="#1-none模式" class="headerlink" title="(1) none模式"></a>(1) none模式</h3><p>修改<code>consumer</code>服务的<code>application.yml</code>文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure>

<p>修改<code>consumer</code>服务的<code>SpringRabbitListener</code>类中的方法，模拟一个消息处理异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到simple.queue的消息：【&#123;&#125;】&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// 模拟异常</span></span><br><span class="line">    System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;消息处理完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试可以发现，当消息处理抛异常时，消息依然被RabbitMQ删除了。</p>
<h3 id="2-auto模式"><a href="#2-auto模式" class="headerlink" title="(2) auto模式"></a>(2) auto模式</h3><p>再次把确认机制修改为auto:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 关闭ack</span></span><br></pre></td></tr></table></figure>

<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为unack（未确定状态）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114185940238.png" alt="image-20240114185940238"></p>
<p>抛出异常后，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114185959248.png" alt="image-20240114185959248"></p>
<h2 id="4-4-消费者失败重试机制"><a href="#4-4-消费者失败重试机制" class="headerlink" title="4.4 消费者失败重试机制"></a>4.4 消费者失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力。</p>
<h3 id="1-本地重试"><a href="#1-本地重试" class="headerlink" title="(1) 本地重试"></a>(1) 本地重试</h3><p>我们可以利用Spring的<code>retry</code>机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p>
<p>修改consumer服务的application.yml文件，添加内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>重启consumer服务，重复之前的测试。可以发现：</p>
<ul>
<li>在重试3次后，SpringAMQP会抛出异常<code>AmqpRejectAndDontRequeueException</code>，说明本地重试触发了</li>
<li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li>
</ul>
<p>结论：</p>
<ul>
<li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li>
<li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li>
</ul>
<h3 id="2-失败策略"><a href="#2-失败策略" class="headerlink" title="(2) 失败策略"></a>(2) 失败策略</h3><p>在之前的测试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。</p>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有<code>MessageRecovery</code>接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><code>RejectAndDontRequeueRecoverer</code>：重试次数耗尽后，直接reject，丢弃消息。默认就是这种方式。</p>
</li>
<li><p><code>ImmediateRequeueMessageRecoverer</code>：重试次数耗尽后，返回nack，消息重新入队。</p>
</li>
<li><p><code>RepublishMessageRecoverer</code>：重试次数耗尽后，将失败消息投递到指定的交换机。</p>
</li>
</ul>
<p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，<strong>失败后将消息投递到一个指定的，专门存放异常消息的队列</strong>，后续由人工集中处理。</p>
<p>1）在<code>consumer</code>服务中定义处理失败消息的交换机和队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）定义一个<code>RepublishMessageRecoverer</code>，关联队列和交换机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：如何保证RabbitMQ的消息可靠性？</p>
</blockquote>
<ul>
<li>开启<strong>生产者确认机制</strong>，确保生产者的消息能到达队列</li>
<li>开启<strong>消息持久化功能</strong>，确保消息未消费前在队列中不会丢失</li>
<li>开启<strong>消费者确认机制为auto</strong>，由spring确认消息处理成功后完成ack</li>
<li>开启<strong>消费者失败重试机制</strong>，并设置<code>MessageRecoverer</code>，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<h1 id="五、死信交换机"><a href="#五、死信交换机" class="headerlink" title="五、死信交换机"></a>五、死信交换机</h1><h2 id="5-1-死信交换机"><a href="#5-1-死信交换机" class="headerlink" title="5.1 死信交换机"></a>5.1 死信交换机</h2><p>什么是死信？</p>
<p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>（dead letter）：</p>
<ul>
<li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为<code>false</code></li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息满了，无法投递</li>
</ul>
<p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么<strong>队列中的死信就会投递到这个交换机</strong>中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，简称DLX）。</p>
<p>如图，一个消息被消费者拒绝了，变成了死信：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114190725300.png" alt="image-20240114190725300"></p>
<p>因为<code>simple.queue</code>绑定了死信交换机 <code>dl.direct</code>，因此死信会投递给这个交换机：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114190806506.png" alt="image-20240114190806506"></p>
<p>如果这个死信交换机也绑定了一个队列，则消息最终会进入这个存放死信的队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114190821720.png" alt="image-20240114190821720"></p>
<p>另外，队列将死信投递给死信交换机时，必须知道两个信息：</p>
<ul>
<li><strong>死信交换机名称</strong></li>
<li><strong>死信交换机与死信队列绑定的RoutingKey</strong></li>
</ul>
<p>这样才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114190850417.png" alt="image-20240114190850417"></p>
<h3 id="利用死信交换机接收死信"><a href="#利用死信交换机接收死信" class="headerlink" title="利用死信交换机接收死信"></a>利用死信交换机接收死信</h3><p>在失败重试策略中，默认的<code>RejectAndDontRequeueRecoverer</code>会在本地重试次数耗尽后，发送<code>reject</code>给RabbitMQ，消息变成死信，被丢弃。</p>
<p>我们可以给<code>simple.queue</code>添加一个死信交换机，给死信交换机绑定一个队列。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114191025460.png" alt="image-20240114191025460"></p>
<p>我们在consumer服务中，定义一组死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明普通的 simple.queue队列，并且为其指定死信交换机：dl.direct</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">simpleQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">           .deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">           .build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明死信交换机 dl.direct</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> DirectExchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;dl.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明存储死信的队列 dl.queue</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;dl.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将死信队列 与 死信交换机绑定</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">dlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-TTL"><a href="#5-2-TTL" class="headerlink" title="5.2 TTL"></a>5.2 TTL</h2><p>一个队列中的消息如果超时未消费，则会变为死信，超时分为两种情况：</p>
<ul>
<li>消息所在的<strong>队列</strong>设置了超时时间</li>
<li><strong>消息本身</strong>设置了超时时间</li>
</ul>
<h3 id="1-接收超时死信的死信交换机"><a href="#1-接收超时死信的死信交换机" class="headerlink" title="(1) 接收超时死信的死信交换机"></a>(1) 接收超时死信的死信交换机</h3><p>在<code>consumer</code>服务的<code>SpringRabbitListener</code>中，定义一个新的消费者，并且声明 死信交换机、死信队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;dl.ttl.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;dl.ttl.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;ttl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 dl.ttl.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-声明队列，并设置TTL"><a href="#2-声明队列，并设置TTL" class="headerlink" title="(2) 声明队列，并设置TTL"></a>(2) 声明队列，并设置TTL</h3><p>要给队列设置超时时间，需要在声明队列时配置<code>x-message-ttl</code>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">// 指定队列名称，并持久化</span></span><br><span class="line">        .ttl(<span class="number">10000</span>) <span class="comment">// 设置队列的超时时间，10秒</span></span><br><span class="line">        .deadLetterExchange(<span class="string">&quot;dl.ttl.direct&quot;</span>) <span class="comment">// 指定死信交换机</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个队列设定了死信交换机为<code>dl.ttl.direct</code>。</p>
<p>声明交换机，将<code>ttl</code>与交换机绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">ttlBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息，但是不要指定TTL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, ttl queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为队列的TTL值是10000ms，也就是10秒。可以通过日志查看消息发送与接收之间的时差刚好是10秒。</p>
<h3 id="3-发送消息，设定TTL"><a href="#3-发送消息，设定TTL" class="headerlink" title="(3) 发送消息，设定TTL"></a>(3) 发送消息，设定TTL</h3><p>在发送消息时，也可以指定TTL：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">        .withBody(<span class="string">&quot;hello, ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>, <span class="string">&quot;ttl&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意，当队列、消息都设置了TTL时，任意一个到期该消息就会成为死信。</p>
<h2 id="5-3-延迟队列"><a href="#5-3-延迟队列" class="headerlink" title="5.3 延迟队列"></a>5.3 延迟队列</h2><p>利用<strong>TTL结合死信交换机</strong>，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为<strong>延迟队列</strong>（Delay Queue）模式。</p>
<p>延迟队列的使用场景包括：</p>
<ul>
<li>延迟发送短信</li>
<li>用户下单，如果用户在15 分钟内未支付，则自动取消</li>
<li>预约工作会议，20分钟后自动通知所有参会人员</li>
</ul>
<p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。</p>
<p>这个插件就是DelayExchange插件。参考RabbitMQ的插件列表页面：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></p>
<p>使用方式可以参考官网地址：<a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq</a></p>
<h3 id="1-DelayExchange原理"><a href="#1-DelayExchange原理" class="headerlink" title="(1) DelayExchange原理"></a>(1) DelayExchange原理</h3><p>DelayExchange需要将一个交换机声明为<code>delayed</code>类型。当我们发送消息到<code>delayExchange</code>时，流程如下：</p>
<ul>
<li>接收消息</li>
<li>判断消息是否具备<code>x-delay</code>属性</li>
<li>如果有<code>x-delay</code>属性，说明是延迟消息，持久化到硬盘，读取<code>x-delay</code>值，作为延迟时间</li>
<li>返回<code>routing not found</code>结果给消息发送者</li>
<li><code>x-delay</code>时间到期后，重新投递消息到指定队列</li>
</ul>
<h3 id="2-使用DelayExchange"><a href="#2-使用DelayExchange" class="headerlink" title="(2) 使用DelayExchange"></a>(2) 使用DelayExchange</h3><p>插件的使用也非常简单：声明一个交换机，交换机的类型可以是任意类型，只需要设定delayed属性为true即可，然后声明队列与其绑定即可。</p>
<h4 id="①-声明DelayExchange"><a href="#①-声明DelayExchange" class="headerlink" title="① 声明DelayExchange"></a>① 声明DelayExchange</h4><blockquote>
<p>基于注解方式（推荐）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayExchange</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到了delay.queue的延迟消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于bean方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">            .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称 </span></span><br><span class="line">            .delayed() <span class="comment">// 设置delay属性为true</span></span><br><span class="line">            .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">delayBinding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-发送消息"><a href="#②-发送消息" class="headerlink" title="② 发送消息"></a>② 发送消息</h4><p>发送消息时，一定要携带<code>x-delay</code>属性，指定延迟的时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelayedMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">            .withBody(<span class="string">&quot;hello, delayed message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            .setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 消息id，需要封装到CorrelationData中</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, correlationData);</span><br><span class="line">    log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、惰性队列"><a href="#六、惰性队列" class="headerlink" title="六、惰性队列"></a>六、惰性队列</h1><h2 id="6-1-消息堆积问题"><a href="#6-1-消息堆积问题" class="headerlink" title="6.1 消息堆积问题"></a>6.1 消息堆积问题</h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是<strong>消息堆积</strong>问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114193209986.png" alt="image-20240114193209986"></p>
<p>解决消息堆积有两种思路：</p>
<ul>
<li><strong>增加更多消费者，提高消费速度</strong>。也就是我们之前说的<code>work queue</code>模式</li>
<li><strong>扩大队列容积，提高堆积上限</strong>。</li>
</ul>
<p>要提升队列容积，把消息保存在内存中显然是不行的。</p>
<h2 id="6-2-惰性队列"><a href="#6-2-惰性队列" class="headerlink" title="6.2 惰性队列"></a>6.2 惰性队列</h2><p>从RabbitMQ的3.6.0版本开始，就增加了<code>Lazy Queues</code>的概念，也就是<strong>惰性队列</strong>。惰性队列的特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<h3 id="1-基于命令行设置lazy-queue"><a href="#1-基于命令行设置lazy-queue" class="headerlink" title="(1) 基于命令行设置lazy-queue"></a>(1) 基于命令行设置lazy-queue</h3><p>而要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为<code>lazy</code>即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues  </span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li>
<li><code>set_policy</code> ：添加一个策略</li>
<li><code>Lazy</code> ：策略名称，可以自定义</li>
<li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li>
<li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li>
<li><code>--apply-to queues  </code>：策略的作用对象，是所有的队列</li>
</ul>
<h3 id="2-基于Bean声明lazy-queue"><a href="#2-基于Bean声明lazy-queue" class="headerlink" title="(2) 基于Bean声明lazy-queue"></a>(2) 基于Bean声明lazy-queue</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue lazyQueue() &#123;</span><br><span class="line">    return QueueBuilder.durable(&quot;lazy.queue&quot;)</span><br><span class="line">            .lazy() // 开启x-queue-mode为lazy</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-基于-RabbitListener声明lazy-queue"><a href="#3-基于-RabbitListener声明lazy-queue" class="headerlink" title="(3) 基于@RabbitListener声明lazy-queue"></a>(3) 基于@RabbitListener声明lazy-queue</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：惰性队列的优缺点？</p>
</blockquote>
<p>惰性队列的优点有哪些？</p>
<ul>
<li>基于磁盘存储，消息上限高</li>
<li>没有间歇性的<code>page-out</code>，性能比较稳定</li>
</ul>
<p>惰性队列的缺点有哪些？</p>
<ul>
<li>基于磁盘存储，消息时效性会降低</li>
<li>性能受限于磁盘的IO</li>
</ul>
<h1 id="七、MQ集群"><a href="#七、MQ集群" class="headerlink" title="七、MQ集群"></a>七、MQ集群</h1><h2 id="7-1-集群分类"><a href="#7-1-集群分类" class="headerlink" title="7.1 集群分类"></a>7.1 集群分类</h2><p>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：</p>
<ul>
<li><strong>普通集群</strong>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</li>
<li><strong>镜像集群</strong>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</li>
</ul>
<p>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：<strong>仲裁队列</strong>来代替镜像集群，底层采用<code>Raft</code>协议确保主从的数据一致性。</p>
<h2 id="7-2-普通集群"><a href="#7-2-普通集群" class="headerlink" title="7.2 普通集群"></a>7.2 普通集群</h2><h3 id="1-集群结构和特征"><a href="#1-集群结构和特征" class="headerlink" title="(1) 集群结构和特征"></a>(1) 集群结构和特征</h3><p><strong>普通集群</strong>，或者叫<strong>标准集群</strong>（classic cluster），具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<p>结构如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114194106693.png" alt="image-20240114194106693"></p>
<h3 id="2-部署"><a href="#2-部署" class="headerlink" title="(2) 部署"></a>(2) 部署</h3><p>这里不再给出详细部署步骤，请读者自行查阅。</p>
<h2 id="7-3-镜像集群"><a href="#7-3-镜像集群" class="headerlink" title="7.3 镜像集群"></a>7.3 镜像集群</h2><h3 id="1-集群结构和特征-1"><a href="#1-集群结构和特征-1" class="headerlink" title="(1) 集群结构和特征"></a>(1) 集群结构和特征</h3><p><strong>镜像集群</strong>，本质是<strong>主从模式</strong>，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<p>结构如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20240114194312206.png" alt="image-20240114194312206"></p>
<h3 id="2-部署-1"><a href="#2-部署-1" class="headerlink" title="(2) 部署"></a>(2) 部署</h3><p>这里不再给出详细部署步骤，请读者自行查阅。</p>
<h2 id="7-4-仲裁队列"><a href="#7-4-仲裁队列" class="headerlink" title="7.4 仲裁队列"></a>7.4 仲裁队列</h2><h3 id="1-集群特征"><a href="#1-集群特征" class="headerlink" title="(1) 集群特征"></a>(1) 集群特征</h3><p>仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致</li>
</ul>
<h3 id="2-部署-2"><a href="#2-部署-2" class="headerlink" title="(2) 部署"></a>(2) 部署</h3><p>这里不再给出详细部署步骤，请读者自行查阅。</p>
<h3 id="3-创建仲裁队列"><a href="#3-创建仲裁队列" class="headerlink" title="(3) 创建仲裁队列"></a>(3) 创建仲裁队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">        .quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">小奥</div><div class="post-copyright__author_desc">浮生若梦 为欢几何</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/')">RabbitMQ使用篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=RabbitMQ使用篇&amp;url=http://example.com/2024/01/14/RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87/&amp;pic=/img/png/10.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">小奥</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>消息队列<span class="categoryesPageCount">1</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/RabbitMQ/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>RabbitMQ<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/png/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/13/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedList%E6%BA%90%E7%A0%81%E7%AF%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/7.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java集合之LinkedList源码篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/14/StopWatch%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">StopWatch使用详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">Java、数据库、中间件</b>相关的学习笔记，还有<b style="color:#fff">面试题总结</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小奥</h1><div class="author-info__desc">浮生若梦 为欢几何</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoaozz" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E4%BD%BF%E7%94%A8%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">RabbitMQ使用篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">一、消息队列概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 同步通讯和异步通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-MQ%E5%AF%B9%E6%AF%94"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 MQ对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-RabbitMQ"><span class="toc-number">3.</span> <span class="toc-text">二、 RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 消息模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-publisher%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">(1) publisher实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-consumer%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">(2) consumer实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81SpringAMQP"><span class="toc-number">4.</span> <span class="toc-text">三、SpringAMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Basic-Queue-%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 Basic Queue 基本消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">(1) 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">(2) 消息接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95"><span class="toc-number">4.1.3.</span> <span class="toc-text">(3) 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-WorkQueue%E5%B7%A5%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 WorkQueue工作消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">(1) 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">(2) 消息接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95-1"><span class="toc-number">4.2.3.</span> <span class="toc-text">(3) 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%89%E9%9C%80%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF"><span class="toc-number">4.2.4.</span> <span class="toc-text">(4) 按需获取消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 发布&#x2F;订阅模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Fanout%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 Fanout广播消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring%E5%8E%9F%E7%94%9F%E5%A3%B0%E6%98%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">(1) Spring原生声明交换机和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">4.4.2.</span> <span class="toc-text">(2) 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6"><span class="toc-number">4.4.3.</span> <span class="toc-text">(3) 消息接收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Direct%E5%AE%9A%E5%90%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 Direct定向消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">4.5.1.</span> <span class="toc-text">(1) 基于注解声明交换机和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">(2) 消息发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Topic%E9%80%9A%E9%85%8D%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 Topic通配消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-2"><span class="toc-number">4.6.1.</span> <span class="toc-text">(1) 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6-2"><span class="toc-number">4.6.2.</span> <span class="toc-text">(2) 消息接收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 消息转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AEJSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.7.1.</span> <span class="toc-text">(1) 配置JSON序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">四、消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 生产者消息确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">5.1.1.</span> <span class="toc-text">(1) 修改配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89Return%E5%9B%9E%E8%B0%83"><span class="toc-number">5.1.2.</span> <span class="toc-text">(2) 定义Return回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89ConfirmCallback"><span class="toc-number">5.1.3.</span> <span class="toc-text">(3) 定义ConfirmCallback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 消息持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">(1) 交换机持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.2.</span> <span class="toc-text">(2) 队列持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">5.2.3.</span> <span class="toc-text">(3) 消息持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 消费者确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-none%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">(1) none模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-auto%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">(2) auto模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 消费者失败重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%AC%E5%9C%B0%E9%87%8D%E8%AF%95"><span class="toc-number">5.4.1.</span> <span class="toc-text">(1) 本地重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">5.4.2.</span> <span class="toc-text">(2) 失败策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">五、死信交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 死信交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E6%94%B6%E6%AD%BB%E4%BF%A1"><span class="toc-number">6.1.1.</span> <span class="toc-text">利用死信交换机接收死信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-TTL"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E6%94%B6%E8%B6%85%E6%97%B6%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.2.1.</span> <span class="toc-text">(1) 接收超时死信的死信交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AETTL"><span class="toc-number">6.2.2.</span> <span class="toc-text">(2) 声明队列，并设置TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%8C%E8%AE%BE%E5%AE%9ATTL"><span class="toc-number">6.2.3.</span> <span class="toc-text">(3) 发送消息，设定TTL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DelayExchange%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">(1) DelayExchange原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8DelayExchange"><span class="toc-number">6.3.2.</span> <span class="toc-text">(2) 使用DelayExchange</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%A3%B0%E6%98%8EDelayExchange"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">① 声明DelayExchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">② 发送消息</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">六、惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 消息堆积问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AElazy-queue"><span class="toc-number">7.2.1.</span> <span class="toc-text">(1) 基于命令行设置lazy-queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8EBean%E5%A3%B0%E6%98%8Elazy-queue"><span class="toc-number">7.2.2.</span> <span class="toc-text">(2) 基于Bean声明lazy-queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E-RabbitListener%E5%A3%B0%E6%98%8Elazy-queue"><span class="toc-number">7.2.3.</span> <span class="toc-text">(3) 基于@RabbitListener声明lazy-queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81MQ%E9%9B%86%E7%BE%A4"><span class="toc-number">8.</span> <span class="toc-text">七、MQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 集群分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 普通集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">8.2.1.</span> <span class="toc-text">(1) 集群结构和特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%83%A8%E7%BD%B2"><span class="toc-number">8.2.2.</span> <span class="toc-text">(2) 部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 镜像集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E5%BE%81-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">(1) 集群结构和特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%83%A8%E7%BD%B2-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">(2) 部署</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 仲裁队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E7%BE%A4%E7%89%B9%E5%BE%81"><span class="toc-number">8.4.1.</span> <span class="toc-text">(1) 集群特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%83%A8%E7%BD%B2-2"><span class="toc-number">8.4.2.</span> <span class="toc-text">(2) 部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">8.4.3.</span> <span class="toc-text">(3) 创建仲裁队列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/25/MySQL%E4%B9%8BACID%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="MySQL之ACID实现原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL之ACID实现原理"/></a><div class="content"><a class="title" href="/2024/03/25/MySQL%E4%B9%8BACID%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="MySQL之ACID实现原理">MySQL之ACID实现原理</a><time datetime="2024-03-25T07:52:05.000Z" title="发表于 2024-03-25 15:52:05">2024-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/24/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E7%AF%87/" title="Spring之事务原理篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/15.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring之事务原理篇"/></a><div class="content"><a class="title" href="/2024/03/24/Spring%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E7%AF%87/" title="Spring之事务原理篇">Spring之事务原理篇</a><time datetime="2024-03-24T09:54:42.000Z" title="发表于 2024-03-24 17:54:42">2024-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/Spring%E4%B9%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%8B%E5%8A%A1/" title="Spring之如何选择事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring之如何选择事务"/></a><div class="content"><a class="title" href="/2024/03/15/Spring%E4%B9%8B%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BA%8B%E5%8A%A1/" title="Spring之如何选择事务">Spring之如何选择事务</a><time datetime="2024-03-15T11:31:48.000Z" title="发表于 2024-03-15 19:31:48">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/09/JVM%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%92%8C%E8%A7%A3%E5%86%B3Full-GC/" title="JVM之认识和解决Full GC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/17.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之认识和解决Full GC"/></a><div class="content"><a class="title" href="/2024/03/09/JVM%E4%B9%8B%E8%AE%A4%E8%AF%86%E5%92%8C%E8%A7%A3%E5%86%B3Full-GC/" title="JVM之认识和解决Full GC">JVM之认识和解决Full GC</a><time datetime="2024-03-09T12:33:59.000Z" title="发表于 2024-03-09 20:33:59">2024-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="Java并发之线程池详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/png/13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发之线程池详解"/></a><div class="content"><a class="title" href="/2024/02/28/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" title="Java并发之线程池详解">Java并发之线程池详解</a><time datetime="2024-02-28T11:18:05.000Z" title="发表于 2024-02-28 19:18:05">2024-02-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="小奥" target="_blank">小奥</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">13</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://xiaoaozz.github.io/" title="个人博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="个人博客"/><span class="back-menu-item-text">个人博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/xiaoaozz" title="Github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/104616274?v=4" alt="Github"/><span class="back-menu-item-text">Github</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AQS/" style="font-size: 0.88rem;">AQS<sup>1</sup></a><a href="/tags/ArrayList/" style="font-size: 0.88rem;">ArrayList<sup>1</sup></a><a href="/tags/BigDecimal/" style="font-size: 0.88rem;">BigDecimal<sup>1</sup></a><a href="/tags/Feed%E6%B5%81/" style="font-size: 0.88rem;">Feed流<sup>1</sup></a><a href="/tags/Full-GC/" style="font-size: 0.88rem;">Full GC<sup>1</sup></a><a href="/tags/Go%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Go面经<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 0.88rem;">HashMap<sup>1</sup></a><a href="/tags/JDK8/" style="font-size: 0.88rem;">JDK8<sup>1</sup></a><a href="/tags/Java%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">Java面经<sup>1</sup></a><a href="/tags/LinkedList/" style="font-size: 0.88rem;">LinkedList<sup>1</sup></a><a href="/tags/MySQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">MySQL优化<sup>2</sup></a><a href="/tags/MySQL%E5%BA%94%E7%94%A8/" style="font-size: 0.88rem;">MySQL应用<sup>1</sup></a><a href="/tags/MySQL%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">MySQL面经<sup>1</sup></a><a href="/tags/OOM/" style="font-size: 0.88rem;">OOM<sup>1</sup></a><a href="/tags/RabbitMQ/" style="font-size: 0.88rem;">RabbitMQ<sup>1</sup></a><a href="/tags/Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redission分布式锁<sup>1</sup></a><a href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 0.88rem;">Redis分布式锁<sup>1</sup></a><a href="/tags/ReentrantLock/" style="font-size: 0.88rem;">ReentrantLock<sup>1</sup></a><a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">SQL优化<sup>2</sup></a><a href="/tags/Servlet/" style="font-size: 0.88rem;">Servlet<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 0.88rem;">Socket<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/StopWatch/" style="font-size: 0.88rem;">StopWatch<sup>1</sup></a><a href="/tags/synchronized/" style="font-size: 0.88rem;">synchronized<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>3</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">分布式事务<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>2</sup></a><a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 0.88rem;">接口限流<sup>1</sup></a><a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size: 0.88rem;">文件上传<sup>1</sup></a><a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 0.88rem;">死锁<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" style="font-size: 0.88rem;">算法模板<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" style="font-size: 0.88rem;">计算机网络面经<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8956954060&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 小奥 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>